{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar le5le_store_1 = require(\"le5le-store\");\n\nvar node_1 = require(\"./models/node\");\n\nvar line_1 = require(\"./models/line\");\n\nvar rect_1 = require(\"./models/rect\");\n\nvar point_1 = require(\"./models/point\");\n\nvar status_1 = require(\"./models/status\");\n\nvar middles_1 = require(\"./middles\");\n\nvar ActiveLayer =\n/** @class */\nfunction () {\n  function ActiveLayer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = options;\n    this.data = le5le_store_1.Store.get('topology-data');\n    this.rotateCPs = [];\n    this.sizeCPs = [];\n    this.nodes = [];\n    this.lines = [];\n    this.rotate = 0; // 备份初始位置，方便移动事件处理\n\n    this.initialSizeCPs = [];\n    this.nodeRects = [];\n    this.childrenRects = {};\n    this.childrenRotate = {}; // nodes移动时，停靠点的参考位置\n\n    this.dockWatchers = [];\n    this.rotating = false;\n    le5le_store_1.Store.set('LT:ActiveLayer', this);\n\n    if (!this.options.activeColor) {\n      this.options.activeColor = '#d4380d';\n    }\n  }\n\n  ActiveLayer.prototype.calcControlPoints = function () {\n    if (this.nodes.length === 1) {\n      this.rect = this.nodes[0].rect;\n      this.sizeCPs = this.nodes[0].rect.toPoints();\n      this.rotateCPs = [new point_1.Point(this.nodes[0].rect.x + this.nodes[0].rect.width / 2, this.nodes[0].rect.y - 35), new point_1.Point(this.nodes[0].rect.x + this.nodes[0].rect.width / 2, this.nodes[0].rect.y)];\n\n      if (this.rotate || this.nodes[0].rotate) {\n        for (var _i = 0, _a = this.sizeCPs; _i < _a.length; _i++) {\n          var pt = _a[_i];\n\n          if (this.nodes[0].rotate) {\n            pt.rotate(this.nodes[0].rotate, this.nodes[0].rect.center);\n          }\n\n          if (this.rotate) {\n            pt.rotate(this.rotate, this.rect.center);\n          }\n        }\n\n        for (var _b = 0, _c = this.rotateCPs; _b < _c.length; _b++) {\n          var pt = _c[_b];\n\n          if (this.nodes[0].rotate) {\n            pt.rotate(this.nodes[0].rotate, this.nodes[0].rect.center);\n          }\n\n          if (this.rotate) {\n            pt.rotate(this.rotate, this.rect.center);\n          }\n        }\n      }\n\n      if (this.options.hideRotateCP) {\n        this.rotateCPs = [new point_1.Point(-1000, -1000), new point_1.Point(-1000, -1000)];\n      }\n\n      return;\n    }\n\n    var x1 = 99999;\n    var y1 = 99999;\n    var x2 = -99999;\n    var y2 = -99999;\n    var pts = this.getPoints();\n\n    for (var _d = 0, pts_1 = pts; _d < pts_1.length; _d++) {\n      var item = pts_1[_d];\n\n      if (x1 > item.x) {\n        x1 = item.x;\n      }\n\n      if (y1 > item.y) {\n        y1 = item.y;\n      }\n\n      if (x2 < item.x) {\n        x2 = item.x;\n      }\n\n      if (y2 < item.y) {\n        y2 = item.y;\n      }\n    }\n\n    this.rect = new rect_1.Rect(x1, y1, x2 - x1, y2 - y1);\n    this.sizeCPs = [new point_1.Point(x1, y1), new point_1.Point(x2, y1), new point_1.Point(x2, y2), new point_1.Point(x1, y2)];\n    this.rotateCPs = [new point_1.Point(x1 + (x2 - x1) / 2, y1 - 35), new point_1.Point(x1 + (x2 - x1) / 2, y1)];\n\n    if (this.options.hideRotateCP) {\n      this.rotateCPs = [new point_1.Point(-1000, -1000), new point_1.Point(-1000, -1000)];\n    }\n  };\n\n  ActiveLayer.prototype.locked = function () {\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (!item.locked) {\n        return false;\n      }\n    }\n\n    for (var _b = 0, _c = this.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n\n      if (!item.locked) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ActiveLayer.prototype.getPoints = function () {\n    var points = [];\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var pts = item.rect.toPoints();\n\n      if (item.rotate) {\n        for (var _b = 0, pts_2 = pts; _b < pts_2.length; _b++) {\n          var pt = pts_2[_b];\n          pt.rotate(item.rotate, item.rect.center);\n        }\n      }\n\n      points.push.apply(points, pts);\n    }\n\n    return points;\n  };\n\n  ActiveLayer.prototype.clear = function () {\n    this.lines = [];\n    this.nodes = [];\n    this.sizeCPs = [];\n    this.rotateCPs = [];\n    le5le_store_1.Store.set('LT:activeNode', null);\n  }; // 即将缩放选中的nodes，备份nodes最初大小，方便缩放比例计算\n\n\n  ActiveLayer.prototype.saveNodeRects = function () {\n    this.nodeRects = [];\n    this.childrenRects = {};\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.nodeRects.push(new rect_1.Rect(item.rect.x, item.rect.y, item.rect.width, item.rect.height));\n      this.saveChildrenRects(item);\n    }\n\n    this.initialSizeCPs = [];\n\n    for (var _b = 0, _c = this.sizeCPs; _b < _c.length; _b++) {\n      var item = _c[_b];\n      this.initialSizeCPs.push(item.clone());\n    }\n\n    this.getDockWatchers();\n  };\n\n  ActiveLayer.prototype.saveChildrenRects = function (node) {\n    if (!node.children) {\n      return;\n    }\n\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.childrenRects[item.id] = new rect_1.Rect(item.rect.x, item.rect.y, item.rect.width, item.rect.height);\n      this.childrenRotate[item.id] = item.rotate;\n      this.saveChildrenRects(item);\n    }\n  }; // pt1 - the point of mouse down.\n  // pt2 - the point of mouse move.\n\n\n  ActiveLayer.prototype.resizeNodes = function (type, pt1, pt2) {\n    var p1 = new point_1.Point(pt1.x, pt1.y);\n    var p2 = new point_1.Point(pt2.x, pt2.y);\n\n    if (this.nodes.length === 1 && this.nodes[0].rotate % 360) {\n      p1.rotate(-this.nodes[0].rotate, this.nodeRects[0].center);\n      p2.rotate(-this.nodes[0].rotate, this.nodeRects[0].center);\n    }\n\n    var offsetX = p2.x - p1.x;\n    var offsetY = p2.y - p1.y;\n    var lines = [];\n\n    switch (type) {\n      case 0:\n        offsetX = -offsetX;\n        offsetY = -offsetY;\n        break;\n\n      case 1:\n        offsetY = -offsetY;\n        break;\n\n      case 3:\n        offsetX = -offsetX;\n        break;\n    }\n\n    var i = 0;\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.rect.width = this.nodeRects[i].width + offsetX;\n      item.rect.height = this.nodeRects[i].height + offsetY;\n\n      if (item.rect.width < 10) {\n        item.rect.width = 10;\n      }\n\n      if (item.rect.height < 10) {\n        item.rect.height = 10;\n      }\n\n      switch (type) {\n        case 0:\n          item.rect.x = item.rect.ex - item.rect.width;\n          item.rect.y = item.rect.ey - item.rect.height;\n          break;\n\n        case 1:\n          item.rect.ex = item.rect.x + item.rect.width;\n          item.rect.y = item.rect.ey - item.rect.height;\n          break;\n\n        case 2:\n          item.rect.ex = item.rect.x + item.rect.width;\n          item.rect.ey = item.rect.y + item.rect.height;\n          break;\n\n        case 3:\n          item.rect.x = item.rect.ex - item.rect.width;\n          item.rect.ey = item.rect.y + item.rect.height;\n          break;\n      }\n\n      item.rect.calceCenter();\n      item.init();\n      this.updateChildren(item); // this.getLinesOfNode(item);\n      // for (const line of lines) {\n      //   for (const p of line.controlPoints) {\n      //     //\n      //   }\n      // }\n\n      ++i;\n    }\n\n    this.updateLines();\n  };\n\n  ActiveLayer.prototype.moveNodes = function (x, y) {\n    if (this.nodeRects.length !== this.nodes.length) {\n      return;\n    }\n\n    var i = 0;\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.locked) {\n        continue;\n      }\n\n      var offsetX = this.nodeRects[i].x + x - item.rect.x;\n      var offsetY = this.nodeRects[i].y + y - item.rect.y;\n      item.translate(offsetX, offsetY);\n      var lines = this.getLinesOfNode(item);\n\n      for (var _b = 0, lines_1 = lines; _b < lines_1.length; _b++) {\n        var line = lines_1[_b];\n        line.translate(offsetX, offsetY);\n      }\n\n      this.updateChildren(item);\n\n      if (item.parentId && item.stand) {\n        var parent_1 = void 0;\n\n        for (var _c = 0, _d = this.data.nodes; _c < _d.length; _c++) {\n          var n = _d[_c];\n\n          if (n.id === item.parentId) {\n            parent_1 = n;\n            break;\n          }\n        }\n\n        item.calcRectInParent(parent_1);\n      }\n\n      ++i;\n    }\n\n    this.updateLines();\n\n    if (this.options.on) {\n      this.options.on('moveNodes', this.nodes);\n    }\n  };\n\n  ActiveLayer.prototype.updateChildren = function (node) {\n    if (!node.children) {\n      return;\n    }\n\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.calcChildRect(node);\n      item.init();\n      this.updateChildren(item);\n    }\n  };\n\n  ActiveLayer.prototype.getAllChildren = function (result, node) {\n    if (!node.children) {\n      return;\n    }\n\n    result.push.apply(result, node.children);\n\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n      var n = _a[_i];\n      result.push(n);\n      this.getAllChildren(result, n);\n    }\n  };\n\n  ActiveLayer.prototype.getLinesOfNode = function (node) {\n    var result = [];\n    var nodes = [node];\n    this.getAllChildren(nodes, node);\n\n    for (var _i = 0, _a = this.data.lines; _i < _a.length; _i++) {\n      var line = _a[_i];\n      var fromIn = false;\n      var toIn = false;\n\n      for (var _b = 0, nodes_1 = nodes; _b < nodes_1.length; _b++) {\n        var item = nodes_1[_b];\n\n        if (line.from.id === item.id) {\n          fromIn = true;\n        }\n\n        if (line.to.id === item.id) {\n          toIn = true;\n        }\n      }\n\n      if (fromIn && toIn) {\n        result.push(line);\n      }\n    }\n\n    return result;\n  };\n\n  ActiveLayer.prototype.updateLines = function (nodes) {\n    if (!nodes) {\n      nodes = this.nodes;\n    }\n\n    for (var _i = 0, _a = this.data.lines; _i < _a.length; _i++) {\n      var line = _a[_i];\n\n      for (var _b = 0, nodes_2 = nodes; _b < nodes_2.length; _b++) {\n        var item = nodes_2[_b];\n        var cnt = 0;\n\n        if (line.from.id === item.id) {\n          line.from.x = item.rotatedAnchors[line.from.anchorIndex].x;\n          line.from.y = item.rotatedAnchors[line.from.anchorIndex].y;\n          ++cnt;\n        }\n\n        if (line.to.id === item.id) {\n          line.to.x = item.rotatedAnchors[line.to.anchorIndex].x;\n          line.to.y = item.rotatedAnchors[line.to.anchorIndex].y;\n          ++cnt;\n        }\n\n        if (cnt < 2) {\n          line.calcControlPoints();\n        }\n\n        line.textRect = null;\n        le5le_store_1.Store.set('pts-' + line.id, null);\n\n        if (item.children) {\n          this.updateLines(item.children);\n        }\n      }\n    }\n  };\n\n  ActiveLayer.prototype.changeLineType = function () {\n    for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.calcControlPoints();\n    }\n  };\n\n  ActiveLayer.prototype.offsetRotate = function (angle) {\n    this.rotating = true;\n    var i = 0;\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var center = this.nodeRects[i].center.clone();\n\n      if (this.nodes.length > 1) {\n        center.rotate(angle, this.rect.center);\n      }\n\n      item.rect.x = center.x - item.rect.width / 2;\n      item.rect.y = center.y - item.rect.height / 2;\n      item.rect.ex = item.rect.x + item.rect.width;\n      item.rect.ey = item.rect.y + item.rect.height;\n      item.rect.calceCenter();\n      item.init();\n      item.offsetRotate = angle;\n      item.calcRotateAnchors(item.rotate + item.offsetRotate);\n      this.rotateChildren(item);\n      ++i;\n    }\n\n    this.rotate = angle;\n\n    if (this.options.on) {\n      this.options.on('rotateNodes', this.nodes);\n    }\n  };\n\n  ActiveLayer.prototype.rotateChildren = function (node) {\n    if (!node.children) {\n      return;\n    }\n\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var oldCenter = this.childrenRects[item.id].center.clone();\n      var newCenter = this.childrenRects[item.id].center.clone().rotate(this.rotate, this.rect.center);\n      var rect = this.childrenRects[item.id].clone();\n      rect.translate(newCenter.x - oldCenter.x, newCenter.y - oldCenter.y);\n      item.rect = rect;\n      item.rotate = this.childrenRotate[item.id] + this.rotate;\n      item.init();\n      this.rotateChildren(item);\n    }\n  };\n\n  ActiveLayer.prototype.updateRotate = function () {\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.rotate += item.offsetRotate;\n      item.offsetRotate = 0;\n    }\n\n    this.rotate = 0;\n    this.rotating = false;\n  };\n\n  ActiveLayer.prototype.addNode = function (node) {\n    this.nodes.push(node);\n\n    if (this.nodes.length === 1) {\n      le5le_store_1.Store.set('LT:activeNode', this.nodes[0]);\n    }\n  };\n\n  ActiveLayer.prototype.setNodes = function (nodes) {\n    this.nodes = nodes;\n    this.lines = [];\n\n    if (this.nodes.length === 1) {\n      le5le_store_1.Store.set('LT:activeNode', this.nodes[0]);\n    }\n  };\n\n  ActiveLayer.prototype.hasNode = function (node) {\n    var found = false;\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.id === node.id) {\n        found = true;\n        break;\n      }\n    }\n\n    return found;\n  };\n\n  ActiveLayer.prototype.setLines = function (lines) {\n    this.nodes = [];\n    this.lines = lines;\n  };\n\n  ActiveLayer.prototype.addLine = function (line) {\n    for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.id === line.id) {\n        return;\n      }\n    }\n\n    this.lines.push(line);\n  };\n\n  ActiveLayer.prototype.render = function (ctx) {\n    if (this.data.locked > status_1.Lock.Readonly) {\n      return;\n    }\n\n    if (!this.nodes.length && !this.lines.length) {\n      return;\n    }\n\n    if (this.nodes.length === 1 || !this.rotating) {\n      this.calcControlPoints();\n    }\n\n    ctx.save();\n    ctx.strokeStyle = this.options.activeColor;\n    ctx.fillStyle = '#fff';\n    ctx.lineWidth = 1;\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var tmp = new node_1.Node(item, true);\n      tmp.data = null;\n      tmp.fillStyle = null;\n      tmp.bkType = 0;\n      tmp.icon = '';\n      tmp.image = '';\n      tmp.text = '';\n\n      if (tmp.strokeStyle !== 'transparent') {\n        tmp.strokeStyle = '#ffffff';\n        tmp.lineWidth += 2;\n        tmp.render(ctx);\n        tmp.strokeStyle = this.options.activeColor;\n        tmp.lineWidth -= 2;\n      }\n\n      tmp.render(ctx);\n    }\n\n    for (var _b = 0, _c = this.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n\n      if (!item.to) {\n        continue;\n      }\n\n      var tmp = new line_1.Line(item);\n\n      if (tmp.lineWidth < 3) {\n        var bk = new line_1.Line(item);\n        bk.strokeStyle = '#ffffff';\n        bk.render(ctx);\n      }\n\n      tmp.strokeStyle = this.options.activeColor;\n      tmp.fromArrowColor = this.options.activeColor;\n      tmp.toArrowColor = this.options.activeColor;\n      tmp.render(ctx);\n\n      if (!item.locked) {\n        middles_1.drawLineFns[item.name].drawControlPointsFn(ctx, item);\n      }\n    } // This is diffence between single node and more.\n\n\n    if (this.rotate && this.nodes.length > 1) {\n      ctx.translate(this.rect.center.x, this.rect.center.y);\n      ctx.rotate(this.rotate * Math.PI / 180);\n      ctx.translate(-this.rect.center.x, -this.rect.center.y);\n    } // Occupied territory.\n\n\n    ctx.save();\n    ctx.globalAlpha = 0.3;\n    ctx.translate(0.5, 0.5);\n    ctx.beginPath();\n    ctx.moveTo(this.sizeCPs[0].x, this.sizeCPs[0].y);\n    ctx.lineTo(this.sizeCPs[1].x, this.sizeCPs[1].y);\n    ctx.lineTo(this.sizeCPs[2].x, this.sizeCPs[2].y);\n    ctx.lineTo(this.sizeCPs[3].x, this.sizeCPs[3].y);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n\n    if (this.data.locked || this.locked()) {\n      ctx.restore();\n      return;\n    } // Draw rotate control point.\n\n\n    ctx.beginPath();\n    ctx.moveTo(this.rotateCPs[0].x, this.rotateCPs[0].y);\n    ctx.lineTo(this.rotateCPs[1].x, this.rotateCPs[1].y);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(this.rotateCPs[0].x, this.rotateCPs[0].y, 5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke(); // Draw size control points.\n\n    if (!this.options.hideSizeCP) {\n      ctx.lineWidth = 1;\n\n      for (var _d = 0, _e = this.sizeCPs; _d < _e.length; _d++) {\n        var item = _e[_d];\n        ctx.save();\n        ctx.beginPath();\n\n        if (this.nodes.length === 1 && (this.nodes[0].rotate || this.rotate)) {\n          ctx.translate(item.x, item.y);\n          ctx.rotate((this.nodes[0].rotate + this.rotate) * Math.PI / 180);\n          ctx.translate(-item.x, -item.y);\n        }\n\n        ctx.fillRect(item.x - 4.5, item.y - 4.5, 8, 8);\n        ctx.strokeRect(item.x - 5.5, item.y - 5.5, 10, 10);\n        ctx.restore();\n      }\n    }\n\n    ctx.restore();\n  };\n\n  ActiveLayer.prototype.getDockWatchers = function () {\n    if (this.nodes.length === 1) {\n      this.dockWatchers = this.nodeRects[0].toPoints();\n      this.dockWatchers.unshift(this.nodeRects[0].center);\n      return;\n    }\n\n    if (!this.rect) {\n      return;\n    }\n\n    this.dockWatchers = this.rect.toPoints();\n    this.dockWatchers.unshift(this.rect.center);\n  };\n\n  ActiveLayer.prototype.alignNodes = function (align) {\n    switch (align) {\n      case 'left':\n        for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n          var item = _a[_i];\n          item.rect.x = this.rect.x;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n\n      case 'right':\n        for (var _b = 0, _c = this.nodes; _b < _c.length; _b++) {\n          var item = _c[_b];\n          item.rect.x = this.rect.ex - item.rect.width;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n\n      case 'top':\n        for (var _d = 0, _e = this.nodes; _d < _e.length; _d++) {\n          var item = _e[_d];\n          item.rect.y = this.rect.y;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n\n      case 'bottom':\n        for (var _f = 0, _g = this.nodes; _f < _g.length; _f++) {\n          var item = _g[_f];\n          item.rect.y = this.rect.ey - item.rect.height;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n\n      case 'center':\n        for (var _h = 0, _j = this.nodes; _h < _j.length; _h++) {\n          var item = _j[_h];\n          item.rect.x = this.rect.center.x - item.rect.width / 2;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n\n      case 'middle':\n        for (var _k = 0, _l = this.nodes; _k < _l.length; _k++) {\n          var item = _l[_k];\n          item.rect.y = this.rect.center.y - item.rect.height / 2;\n          item.rect.floor();\n          item.rect.calceCenter();\n          item.init();\n          this.updateChildren(item);\n        }\n\n        break;\n    }\n\n    this.updateLines();\n  };\n\n  return ActiveLayer;\n}();\n\nexports.ActiveLayer = ActiveLayer;","map":null,"metadata":{},"sourceType":"script"}