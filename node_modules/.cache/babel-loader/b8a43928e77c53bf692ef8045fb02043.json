{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nrequire('slate');\n\nvar _utils = require('../utils');\n/**\n * Create a schema definition with rules to normalize lists\n */\n\n\nfunction normalizeNode(opts) {\n  return function (node, editor, next) {\n    return joinAdjacentLists(opts, node, next);\n  };\n}\n/**\n * A rule that joins adjacent lists of the same type\n */\n\n\nfunction joinAdjacentLists(opts, node, next) {\n  if (node.object !== 'document' && node.object !== 'block') {\n    return next();\n  }\n\n  var invalids = node.nodes.map(function (child, i) {\n    if (!(0, _utils.isList)(opts, child)) return null;\n    var nextNode = node.nodes.get(i + 1);\n\n    if (!nextNode || !(0, _utils.isList)(opts, nextNode) || !opts.canMerge(child, nextNode)) {\n      return null;\n    }\n\n    return [child, nextNode];\n  }).filter(Boolean);\n\n  if (invalids.isEmpty()) {\n    return next();\n  }\n  /**\n   * Join the list pairs\n   */\n  // We join in reverse order, so that multiple lists folds onto the first one\n\n\n  return function (change) {\n    change.withoutNormalizing(function () {\n      invalids.reverse().forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            first = _pair[0],\n            second = _pair[1];\n\n        var updatedSecond = change.value.document.getDescendant(second.key);\n        updatedSecond.nodes.forEach(function (secondNode, index) {\n          change.moveNodeByKey(secondNode.key, first.key, first.nodes.size + index);\n        });\n        change.removeNodeByKey(second.key);\n      });\n    });\n  };\n}\n\nexports.default = normalizeNode;","map":null,"metadata":{},"sourceType":"script"}