{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = require(\"../../models/point\");\n\nvar direction_1 = require(\"../../models/direction\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar minDistance = 50;\n\nfunction polyline(ctx, l) {\n  ctx.beginPath();\n  ctx.moveTo(l.from.x, l.from.y);\n\n  for (var _i = 0, _a = l.controlPoints; _i < _a.length; _i++) {\n    var item = _a[_i];\n    ctx.lineTo(item.x, item.y);\n  }\n\n  ctx.lineTo(l.to.x, l.to.y);\n  ctx.stroke();\n}\n\nexports.polyline = polyline;\n\nfunction polylineControlPoints(ctx, l) {\n  ctx.save();\n  ctx.fillStyle = '#fff';\n  ctx.lineWidth = 2;\n\n  for (var _i = 0, _a = l.controlPoints; _i < _a.length; _i++) {\n    var item = _a[_i];\n    ctx.beginPath();\n    ctx.arc(item.x, item.y, 4, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.fill();\n  }\n\n  ctx.restore();\n}\n\nexports.polylineControlPoints = polylineControlPoints;\n\nfunction calcPolylineControlPoints(l) {\n  l.controlPoints = [];\n  var from = getDirectionPoint(l.from, l.to);\n\n  if (l.from.direction) {\n    l.controlPoints.push(from);\n  }\n\n  var to = getDirectionPoint(l.to, l.from);\n  var pts;\n\n  switch (from.direction) {\n    case direction_1.Direction.Up:\n      pts = getNextPointByUp(from, to);\n      break;\n\n    case direction_1.Direction.Right:\n      pts = getNextPointByRight(from, to);\n      break;\n\n    case direction_1.Direction.Bottom:\n      pts = getNextPointByBottom(from, to);\n      break;\n\n    case direction_1.Direction.Left:\n      pts = getNextPointByLeft(from, to);\n      break;\n  }\n\n  l.controlPoints.push.apply(l.controlPoints, pts);\n\n  if (l.to.direction) {\n    l.controlPoints.push(to);\n  }\n}\n\nexports.calcPolylineControlPoints = calcPolylineControlPoints;\n\nfunction pointInPolyline(point, l) {\n  if (!l.controlPoints || !l.controlPoints.length) {\n    return utils_1.pointInLine(point, l.from, l.to);\n  }\n\n  if (utils_1.pointInLine(point, l.from, l.controlPoints[0])) {\n    return true;\n  }\n\n  if (utils_1.pointInLine(point, l.to, l.controlPoints[l.controlPoints.length - 1])) {\n    return true;\n  }\n\n  for (var i = 0; i < l.controlPoints.length - 1; ++i) {\n    if (utils_1.pointInLine(point, l.controlPoints[i], l.controlPoints[i + 1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.pointInPolyline = pointInPolyline;\n\nfunction dockPolylineControlPoint(point, l) {\n  var pts = [l.from];\n  pts.push.apply(pts, l.controlPoints);\n  pts.push(l.to);\n\n  for (var _i = 0, pts_1 = pts; _i < pts_1.length; _i++) {\n    var item = pts_1[_i];\n\n    if (Math.abs(point.x - item.x) < 7) {\n      point.x = item.x;\n    }\n\n    if (Math.abs(point.y - item.y) < 7) {\n      point.y = item.y;\n    }\n  }\n}\n\nexports.dockPolylineControlPoint = dockPolylineControlPoint;\n\nfunction getDirectionPoint(pt, to) {\n  var point = pt.clone();\n\n  switch (pt.direction) {\n    case direction_1.Direction.Up:\n      if (to.y < pt.y) {\n        point.y -= Math.floor((pt.y - to.y) / 2);\n      } else {\n        point.y -= minDistance;\n      }\n\n      break;\n\n    case direction_1.Direction.Right:\n      if (to.x > pt.x) {\n        point.x += Math.floor((to.x - pt.x) / 2);\n      } else {\n        point.x += minDistance;\n      }\n\n      break;\n\n    case direction_1.Direction.Bottom:\n      if (to.y > pt.y) {\n        point.y += Math.floor((to.y - pt.y) / 2);\n      } else {\n        point.y += minDistance;\n      }\n\n      break;\n\n    case direction_1.Direction.Left:\n      if (to.x < pt.x) {\n        point.x -= Math.floor((pt.x - to.x) / 2);\n      } else {\n        point.x -= minDistance;\n      }\n\n      break;\n  }\n\n  return point;\n}\n\nfunction getNextPointByUp(from, to) {\n  if (from.x === to.x || from.y === to.y) {\n    return [];\n  } // The to point above the from point.\n\n\n  if (from.y > to.y) {\n    if (to.direction === direction_1.Direction.Up && from.y - to.y > 3 * minDistance) {\n      if (from.x < to.x) {\n        if (to.x - from.x < minDistance) {\n          return [new point_1.Point(from.x - 2 * minDistance, from.y), new point_1.Point(from.x - 2 * minDistance, to.y)];\n        }\n\n        return [new point_1.Point(from.x, to.y)];\n      } else {\n        if (from.x - to.x < minDistance) {\n          return [new point_1.Point(from.x + 2 * minDistance, from.y), new point_1.Point(from.x + 2 * minDistance, to.y)];\n        }\n\n        return [new point_1.Point(from.x, to.y)];\n      }\n    } else {\n      // Left top\n      if (to.direction === direction_1.Direction.Left && from.x > to.x || to.direction === direction_1.Direction.Right && from.x < to.x) {\n        return [new point_1.Point(to.x, from.y)];\n      }\n\n      return [new point_1.Point(from.x, to.y)];\n    } // The to point below the from point.\n\n  } else {\n    if (to.direction === direction_1.Direction.Bottom) {\n      if (from.x < to.x) {\n        return getHorizontalPoints(from, to);\n      } else {\n        var pts = getHorizontalPoints(to, from);\n        return [pts[1], pts[0]];\n      }\n    } else {\n      return [new point_1.Point(to.x, from.y)];\n    }\n  }\n}\n\nfunction getNextPointByBottom(from, to) {\n  if (from.x === to.x || from.y === to.y) {\n    return [];\n  } // The to point below the from point.\n\n\n  if (from.y < to.y) {\n    if (to.direction === direction_1.Direction.Bottom && to.y - from.y > 3 * minDistance) {\n      if (from.x < to.x) {\n        if (to.x - from.x < minDistance) {\n          return [new point_1.Point(from.x - 2 * minDistance, from.y), new point_1.Point(from.x - 2 * minDistance, to.y)];\n        }\n\n        return [new point_1.Point(from.x, to.y)];\n      } else {\n        if (from.x - to.x < minDistance) {\n          return [new point_1.Point(from.x + 2 * minDistance, from.y), new point_1.Point(from.x + 2 * minDistance, to.y)];\n        }\n\n        return [new point_1.Point(from.x, to.y)];\n      }\n    } else {\n      if (to.direction === direction_1.Direction.Left && from.x > to.x || to.direction === direction_1.Direction.Right && from.x < to.x) {\n        return [new point_1.Point(to.x, from.y)];\n      }\n\n      return [new point_1.Point(from.x, to.y)];\n    } // The to point below the from point.\n\n  } else {\n    if (to.direction === direction_1.Direction.Up) {\n      if (from.x < to.x) {\n        return getHorizontalPoints(from, to);\n      } else {\n        var pts = getHorizontalPoints(to, from);\n        return [pts[1], pts[0]];\n      }\n    } else {\n      return [new point_1.Point(to.x, from.y)];\n    }\n  }\n}\n\nfunction getNextPointByLeft(from, to) {\n  if (from.x === to.x || from.y === to.y) {\n    return [];\n  } // The to point is on the left.\n\n\n  if (from.x > to.x) {\n    if (to.direction === direction_1.Direction.Left && from.x - to.x > 3 * minDistance) {\n      if (from.y < to.y) {\n        if (to.y - from.y < minDistance) {\n          return [new point_1.Point(from.x, from.y + 2 * minDistance), new point_1.Point(to.x, from.y + 2 * minDistance)];\n        }\n\n        return [new point_1.Point(to.x, from.y)];\n      } else {\n        if (from.y - to.y < minDistance) {\n          return [new point_1.Point(from.x, from.y - 2 * minDistance), new point_1.Point(to.x, from.y - 2 * minDistance)];\n        }\n\n        return [new point_1.Point(to.x, from.y)];\n      }\n    } else {\n      if (to.direction === direction_1.Direction.Left || to.direction === direction_1.Direction.Up && from.y < to.y || to.direction === direction_1.Direction.Bottom && from.y > to.y) {\n        return [new point_1.Point(to.x, from.y)];\n      }\n\n      return [new point_1.Point(from.x, to.y)];\n    } // The to point is on the right.\n\n  } else {\n    if (to.direction === direction_1.Direction.Right) {\n      if (from.y < to.y) {\n        return getVerticalPoints(from, to);\n      } else {\n        var pts = getVerticalPoints(to, from);\n        return [pts[1], pts[0]];\n      }\n    } else {\n      return [new point_1.Point(from.x, to.y)];\n    }\n  }\n}\n\nfunction getNextPointByRight(from, to) {\n  if (from.x === to.x || from.y === to.y) {\n    return [];\n  } // The to point is on the right.\n\n\n  if (from.x < to.x) {\n    if (to.direction === direction_1.Direction.Right && to.x - from.x > 3 * minDistance) {\n      if (from.y < to.y) {\n        if (to.y - from.y < minDistance) {\n          return [new point_1.Point(from.x, from.y - 2 * minDistance), new point_1.Point(to.x, from.y - 2 * minDistance)];\n        }\n\n        return [new point_1.Point(to.x, from.y)];\n      } else {\n        if (from.y - to.y < minDistance) {\n          return [new point_1.Point(from.x, from.y + 2 * minDistance), new point_1.Point(to.x, from.y + 2 * minDistance)];\n        }\n\n        return [new point_1.Point(to.x, from.y)];\n      }\n    } else {\n      if (to.direction === direction_1.Direction.Right || to.direction === direction_1.Direction.Up && from.y < to.y || to.direction === direction_1.Direction.Bottom && from.y > to.y) {\n        return [new point_1.Point(to.x, from.y)];\n      }\n\n      return [new point_1.Point(from.x, to.y)];\n    } // The to point is on the left.\n\n  } else {\n    if (to.direction === direction_1.Direction.Left) {\n      if (from.y < to.y) {\n        return getVerticalPoints(from, to);\n      } else {\n        var pts = getVerticalPoints(to, from);\n        return [pts[1], pts[0]];\n      }\n    } else {\n      return [new point_1.Point(from.x, to.y)];\n    }\n  }\n}\n\nfunction getHorizontalPoints(left, right) {\n  var x = left.x + (right.x - left.x) / 2;\n  return [new point_1.Point(x, left.y), new point_1.Point(x, right.y)];\n}\n\nfunction getVerticalPoints(up, bottom) {\n  var y = up.y + (bottom.y - up.y) / 2;\n  return [new point_1.Point(up.x, y), new point_1.Point(bottom.x, y)];\n}","map":null,"metadata":{},"sourceType":"script"}