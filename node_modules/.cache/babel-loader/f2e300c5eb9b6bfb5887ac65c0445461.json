{"ast":null,"code":"import { Record, Range } from 'immutable';\nimport { Block, Text, Editor, Value } from 'slate';\nimport { cloneFragment } from 'slate-react';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n/**\n * The plugin options\n */\n\n\nvar Options = /*#__PURE__*/function (_Record) {\n  _inherits(Options, _Record);\n\n  function Options() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Options);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Options)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _this.isCell = function (node) {\n      return node.object == 'block' && node.type == _this.typeCell;\n    };\n\n    return _this;\n  }\n\n  return Options;\n}(Record({\n  typeTable: 'table',\n  typeRow: 'table_row',\n  typeCell: 'table_cell',\n  typeContent: 'paragraph',\n  exitBlockType: 'paragraph',\n  insertRowOnEnter: true,\n  edgeRowExitOnDirection: false\n}));\n/**\n * Create a new cell\n */\n\n\nfunction createCell(opts, nodes) {\n  return Block.create({\n    type: opts.typeCell,\n    nodes: nodes || [createEmptyContent(opts)]\n  });\n}\n/**\n * Create a new default content block\n */\n\n\nfunction createEmptyContent(opts) {\n  return Block.create({\n    type: opts.typeContent,\n    nodes: [Text.create()]\n  });\n}\n/**\n * Create a new row block\n */\n\n\nfunction createRow(opts, columns, getCellContent) {\n  var cellNodes = Range(0, columns).map(function (i) {\n    return createCell(opts, getCellContent ? getCellContent(i) : undefined);\n  }).toJS();\n  return Block.create({\n    type: opts.typeRow,\n    nodes: Block.createList(cellNodes)\n  });\n}\n/**\n * Create a table\n */\n\n\nfunction createTable(opts, columns, rows, getCellContent) {\n  var rowNodes = Range(0, rows).map(function (i) {\n    return createRow(opts, columns, getCellContent ? getCellContent.bind(null, i) : undefined);\n  }).toJS();\n  return Block.create({\n    type: opts.typeTable,\n    nodes: Block.createList(rowNodes)\n  });\n}\n\nvar TablePosition = /*#__PURE__*/function (_Record) {\n  _inherits(TablePosition, _Record);\n\n  function TablePosition() {\n    _classCallCheck(this, TablePosition);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TablePosition).apply(this, arguments));\n  }\n\n  _createClass(TablePosition, [{\n    key: \"isInCell\",\n\n    /**\n     * Check to see if this position is within a cell\n     */\n    value: function isInCell() {\n      return Boolean(this.cellBlock);\n    }\n    /**\n     * Check to see if this position is within a row\n     */\n\n  }, {\n    key: \"isInRow\",\n    value: function isInRow() {\n      return Boolean(this.rowBlock);\n    }\n    /**\n     * Check to see if this position is within a table\n     */\n\n  }, {\n    key: \"isInTable\",\n    value: function isInTable() {\n      return Boolean(this.tableBlock);\n    }\n    /**\n     * Check to see if this position is at the top of the cell.\n     */\n\n  }, {\n    key: \"isTopOfCell\",\n    value: function isTopOfCell() {\n      var cellBlock = this.cellBlock,\n          node = this.node;\n\n      if (!cellBlock || !node) {\n        return false;\n      }\n\n      return cellBlock.getPath(node.key).every(function (index) {\n        return index === 0;\n      });\n    }\n    /**\n     * Check to see if this position is at the bottom of the cell.\n     */\n\n  }, {\n    key: \"isBottomOfCell\",\n    value: function isBottomOfCell() {\n      var node = this.node,\n          cellBlock = this.cellBlock;\n\n      if (!node || !cellBlock) {\n        return false;\n      }\n\n      var ancestors = cellBlock.getAncestors(node.key);\n      return ancestors.every(function (node, index) {\n        var next = ancestors.get(index + 1);\n        if (!next) return true;\n        return node.nodes.indexOf(next) === node.nodes.size - 1;\n      });\n    }\n    /**\n     * Get count of columns\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var table = this.table;\n      var rows = table.nodes;\n      var cells = rows.first().nodes;\n      return cells.size;\n    }\n    /**\n     * Get count of rows\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var table = this.table;\n      var rows = table.nodes;\n      return rows.size;\n    }\n    /**\n     * Get index of current row in the table.\n     */\n\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex() {\n      var table = this.table,\n          row = this.row;\n      var rows = table.nodes;\n      return rows.findIndex(function (x) {\n        return x === row;\n      });\n    }\n    /**\n     * Get index of current column in the row.\n     */\n\n  }, {\n    key: \"getColumnIndex\",\n    value: function getColumnIndex() {\n      var row = this.row,\n          cell = this.cell;\n      var cells = row.nodes;\n      return cells.findIndex(function (x) {\n        return x === cell;\n      });\n    }\n    /**\n     * True if on first cell of the table\n     */\n\n  }, {\n    key: \"isFirstCell\",\n    value: function isFirstCell() {\n      return this.isFirstRow() && this.isFirstColumn();\n    }\n    /**\n     * True if on last cell of the table\n     */\n\n  }, {\n    key: \"isLastCell\",\n    value: function isLastCell() {\n      return this.isLastRow() && this.isLastColumn();\n    }\n    /**\n     * True if on first row\n     */\n\n  }, {\n    key: \"isFirstRow\",\n    value: function isFirstRow() {\n      return this.getRowIndex() === 0;\n    }\n    /**\n     * True if on last row\n     */\n\n  }, {\n    key: \"isLastRow\",\n    value: function isLastRow() {\n      return this.getRowIndex() === this.getHeight() - 1;\n    }\n    /**\n     * True if on first column\n     */\n\n  }, {\n    key: \"isFirstColumn\",\n    value: function isFirstColumn() {\n      return this.getColumnIndex() === 0;\n    }\n    /**\n     * True if on last column\n     */\n\n  }, {\n    key: \"isLastColumn\",\n    value: function isLastColumn() {\n      return this.getColumnIndex() === this.getWidth() - 1;\n    }\n  }, {\n    key: \"table\",\n    get: function get() {\n      if (!this.tableBlock) {\n        throw new Error('Not in a table');\n      }\n\n      return this.tableBlock;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      if (!this.rowBlock) {\n        throw new Error('Not in a row');\n      }\n\n      return this.rowBlock;\n    }\n  }, {\n    key: \"cell\",\n    get: function get() {\n      if (!this.cellBlock) {\n        throw new Error('Not in a cell');\n      }\n\n      return this.cellBlock;\n    }\n  }], [{\n    key: \"create\",\n    // Block container for the table\n\n    /*::tableBlock: ?Block;*/\n    // Block for current row\n\n    /*::rowBlock: ?Block;*/\n    // Block for current cell\n\n    /*::cellBlock: ?Block;*/\n    // Current content block in the cell\n\n    /*::contentBlock: ?Block;*/\n\n    /**\n     * Create a new instance of a TablePosition from a Slate document\n     * and a node key.\n     */\n    value: function create(opts, containerNode, key) {\n      var node = containerNode.getDescendant(key);\n      var ancestors = containerNode.getAncestors(key).push(node);\n      var tableBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeTable;\n      });\n      var rowBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeRow;\n      });\n      var cellBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeCell;\n      });\n      var contentBlock = ancestors.skipUntil(function (ancestor) {\n        return ancestor === cellBlock;\n      }).skip(1).first();\n      return new TablePosition({\n        tableBlock: tableBlock,\n        rowBlock: rowBlock,\n        cellBlock: cellBlock,\n        contentBlock: contentBlock,\n        node: node\n      });\n    }\n  }]);\n\n  return TablePosition;\n}(Record({\n  tableBlock: null,\n  rowBlock: null,\n  cellBlock: null,\n  contentBlock: null,\n  node: null\n}));\n/**\n * The position of the selection start block, in the current table\n */\n\n\nfunction getPosition(opts, editor) {\n  var value = editor.value;\n  if (!value.selection.start || !value.selection.start.key) return new TablePosition();\n  return TablePosition.create(opts, value.document, value.selection.start.key);\n}\n/*\n * The position of a particular node, in the current table\n */\n\n\nfunction getPositionByKey(opts, editor, containerNode, // Key of the node in desired position\nkey) {\n  return TablePosition.create(opts, containerNode, key);\n}\n/**\n * True if the given range is inside one table\n */\n\n\nfunction isRangeInTable(opts, node, range) {\n  var start = range.start,\n      end = range.end;\n  var startPosition = TablePosition.create(opts, node, start.key);\n  var endPosition = TablePosition.create(opts, node, end.key); // Only handle events in tables\n\n  if (!startPosition.isInTable() || !endPosition.isInTable()) {\n    return false;\n  } // Inside the same table\n\n\n  return startPosition.table === endPosition.table;\n}\n/**\n * Is the selection in a table\n */\n\n\nfunction isSelectionInTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  if (!selection.start.key) return false;\n  return isRangeInTable(opts, value.document, value.selection);\n}\n/**\n * Are the selection start and end outside a table.\n */\n\n\nfunction isSelectionOutOfTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  if (!selection.start.key) return false;\n  var startPosition = TablePosition.create(opts, value.document, selection.start.key);\n  var endPosition = TablePosition.create(opts, value.document, selection.end.key); // Only handle events in tables\n\n  return !startPosition.isInTable() && !endPosition.isInTable();\n}\n/**\n * Run the given function against each cells of the table\n */\n\n\nfunction forEachCells(opts, // The table\ntable, fn) {\n  return table.nodes.forEach(function (row, rowIndex) {\n    return row.nodes.forEach(function (cell, columnIndex) {\n      return fn(cell, rowIndex, columnIndex);\n    });\n  });\n}\n/**\n * Returns the list of cells at the given row index\n */\n\n\nfunction getCellsAtRow(opts, editor, table, rowIndex) {\n  return table.nodes.get(rowIndex).nodes;\n}\n/**\n * Returns the list of cells at the given column index\n */\n\n\nfunction getCellsAtColumn(opts, editor, table, columnIndex) {\n  return table.nodes.map(function (row) {\n    return row.nodes.get(columnIndex);\n  });\n}\n\nfunction getCopiedFragment(opts, value) {\n  var selection = value.selection,\n      document = value.document;\n  var startPosition = TablePosition.create(opts, document, selection.start.key);\n  var endPosition = TablePosition.create(opts, document, selection.end.key); // Fragment as it would be copied by Slate\n\n  var baseFragment = value.fragment;\n\n  if (endPosition.cell === startPosition.cell) {\n    // The selection is inside a single cell. Only copy the content of that cell\n    var copiedCell = baseFragment.getAncestors(baseFragment.getFirstText().key).findLast(function (n) {\n      return n.type === opts.typeCell;\n    });\n    return baseFragment.merge({\n      nodes: copiedCell.nodes\n    });\n  }\n}\n/**\n * Insert a new table\n */\n\n\nfunction insertTable(opts, change) {\n  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n  var getCellContent = arguments.length > 4 ? arguments[4] : undefined;\n  var value = change.value;\n  if (!value.selection.start.key) return change; // Create the table node\n\n  var table = createTable(opts, columns, rows, getCellContent);\n  return change.insertBlock(table);\n}\n/**\n * Insert a new row in current table\n */\n\n\nfunction insertRow(opts, change, at, // row index\ngetRow) // Generate the row yourself\n{\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var table = pos.table; // Create a new row with the right count of cells\n\n  var columns = table.nodes.get(0).nodes.size;\n  var newRow = getRow ? getRow(columns) : createRow(opts, columns);\n\n  if (typeof at === 'undefined') {\n    at = pos.getRowIndex() + 1;\n  }\n\n  return change.insertNodeByKey(table.key, at, newRow).moveToEndOfNode(newRow.nodes.get(pos.getColumnIndex()));\n}\n/**\n * Move selection to {x,y}\n */\n\n\nfunction moveSelection(opts, change, x, y) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelection can only be applied from within a cell');\n  }\n\n  var table = pos.table;\n  var row = table.nodes.get(y);\n  var cell = row.nodes.get(x);\n  return change.moveToStartOfNode(cell);\n}\n/**\n * Insert a new column in current table\n */\n\n\nfunction insertColumn(opts, change, at, // Column index\ngetCell) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var table = pos.table;\n  var columnIndex = typeof at === 'undefined' ? pos.getColumnIndex() + 1 : at; // Insert the new cell\n\n  change.withoutNormalizing(function () {\n    table.nodes.forEach(function (row, rowIndex) {\n      var newCell = getCell ? getCell(columnIndex, rowIndex) : createCell(opts);\n      change.insertNodeByKey(row.key, columnIndex, newCell);\n    });\n  }); // Update the selection (not doing can break the undo)\n\n  return moveSelection(opts, change, pos.getColumnIndex() + 1, pos.getRowIndex());\n}\n/**\n * Used when pasting a fragment of table into another one\n */\n\n\nfunction insertTableFragmentAtRange(opts, change, range, // This fragment should contain only one table,\nfragment) {\n  var insertedTable = fragment.nodes.first();\n\n  if (!(fragment.nodes.size === 1 && insertedTable && insertedTable.type === opts.typeTable)) {\n    throw new Error('Expected to insert a fragment containing one table');\n  }\n\n  var value = change.value;\n  var targetPosition = TablePosition.create(opts, value.document, value.selection.start.key);\n  var fragmentRows = insertedTable.nodes;\n  var fragmentHeight = fragmentRows.size;\n  var fragmentWidth = fragmentRows.first().nodes.size; // Insert columns and rows to accomodate the incoming pasted cells\n\n  var missingWidth = fragmentWidth + targetPosition.getColumnIndex() - targetPosition.getWidth();\n  var missingHeight = fragmentHeight + targetPosition.getRowIndex() - targetPosition.getHeight();\n\n  if (missingWidth > 0) {\n    // Add columns\n    Array(missingWidth).fill().forEach(function () {\n      insertColumn(opts, change, targetPosition.getWidth());\n    });\n  }\n\n  if (missingHeight > 0) {\n    // Add rows\n    Array(missingHeight).fill().forEach(function () {\n      insertRow(opts, change, targetPosition.getHeight());\n    });\n  } // Patch the inserted table over the target table, overwritting the cells\n\n\n  var existingTable = change.value.document.getDescendant(targetPosition.table.key);\n  change.withoutNormalizing(function () {\n    fragmentRows.forEach(function (fragmentRow, fragmentRowIndex) {\n      fragmentRow.nodes.forEach(function (newCell, fragmentColumnIndex) {\n        var existingCell = existingTable.nodes.get(targetPosition.getRowIndex() + fragmentRowIndex).nodes.get(targetPosition.getColumnIndex() + fragmentColumnIndex);\n        change.replaceNodeByKey(existingCell.key, newCell);\n      });\n    });\n  });\n  var lastPastedCell = fragmentRows.last().nodes.last();\n  return change.moveToEndOfNode(lastPastedCell);\n}\n/**\n * Clear the content of the given cell\n */\n\n\nfunction clearCell(opts, change, cell) {\n  var newBlock = Block.create({\n    type: opts.typeContent\n  });\n  var nodes = cell.nodes; // Insert a new empty node\n\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(cell.key, 0, newBlock);\n  }); // Remove all previous nodes\n\n  nodes.forEach(function (node) {\n    change.removeNodeByKey(node.key);\n  });\n  return change;\n}\n/**\n * Remove the row associated to a given key in a table.\n * Clear thw row if last remaining row\n */\n\n\nfunction removeRowByKey(opts, change, key) {\n  var value = change.value;\n  var pos = TablePosition.create(opts, value.document, key); // Update table by removing the row\n\n  if (pos.getHeight() > 1) {\n    change.removeNodeByKey(key);\n  } else {\n    // If last remaining row, clear it instead\n    pos.row.nodes.forEach(function (cell) {\n      cell.nodes.forEach(function () {\n        return clearCell(opts, change, cell);\n      });\n    });\n  } // this will also invalidate the selection - move it to the first cell\n  // change.moveToRangeOfNode(pos.row.nodes.first());\n\n\n  return change;\n}\n/**\n * Remove current row in a table. Clear it if last remaining row\n */\n\n\nfunction removeRow(opts, change, at) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var rowKey;\n\n  if (typeof at === 'undefined') {\n    rowKey = pos.row.key;\n  } else {\n    rowKey = pos.table.nodes.get(at).key;\n  }\n\n  return removeRowByKey(opts, change, rowKey);\n}\n/**\n * Delete the column associated with the given cell key in a table\n */\n\n\nfunction removeColumnByKey(opts, change, key) {\n  var value = change.value;\n  var pos = TablePosition.create(opts, value.document, key);\n  var table = pos.table;\n  var colIndex = pos.getColumnIndex();\n  var rows = table.nodes; // Remove the cell from every row\n\n  if (pos.getWidth() > 1) {\n    change.withoutNormalizing(function () {\n      rows.forEach(function (row) {\n        var cell = row.nodes.get(colIndex);\n        change.removeNodeByKey(cell.key);\n      });\n    });\n  } else {\n    // If last column, clear text in cells instead\n    rows.forEach(function (row) {\n      row.nodes.forEach(function (cell) {\n        cell.nodes.forEach(function () {\n          return clearCell(opts, change, cell);\n        });\n      });\n    });\n  } // this will also invalidate the selection - move it to the first cell\n  // change.moveToRangeOfNode(rows.first().nodes.first());\n  // Replace the table\n\n\n  return change;\n}\n/**\n * Delete current column in a table\n */\n\n\nfunction removeColumn(opts, change, at) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var columnKey;\n\n  if (typeof at === 'undefined') {\n    columnKey = pos.cell.key;\n  } else {\n    columnKey = pos.row.nodes.get(at).key;\n  }\n\n  return removeColumnByKey(opts, change, columnKey);\n}\n/**\n * Delete the whole table at the given node key\n */\n\n\nfunction removeTableByKey(opts, editor, key) {\n  var value = editor.value;\n  var pos = TablePosition.create(opts, value.document, key);\n  var table = pos.table;\n  var document = editor.value.document;\n  var nextFocusBlock = null;\n  var shouldCollapseToEnd = false;\n  var nextBlock = editor.value.document.getNextBlock(table.key);\n\n  if (nextBlock) {\n    nextFocusBlock = nextBlock;\n  } else {\n    var prevBlock = editor.value.document.getPreviousBlock(table.key);\n\n    if (prevBlock) {\n      nextFocusBlock = prevBlock;\n      shouldCollapseToEnd = true;\n    } else if (opts.exitBlockType) {\n      nextFocusBlock = Block.create({\n        type: opts.exitBlockType,\n        nodes: [Text.create('')]\n      });\n      var tableParent = document.getParent(table.key);\n      var insertionIndex = tableParent.nodes.indexOf(table) + 1;\n      editor.insertNodeByKey(tableParent.key, insertionIndex, nextFocusBlock);\n    }\n  }\n\n  editor.removeNodeByKey(table.key);\n\n  if (!nextFocusBlock) {\n    return editor;\n  }\n\n  if (shouldCollapseToEnd) {\n    editor.moveToEndOfNode(nextFocusBlock).focus();\n  } else {\n    editor.moveToStartOfNode(nextFocusBlock).focus();\n  }\n\n  return editor;\n}\n/**\n * Delete the whole table at position\n */\n\n\nfunction removeTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  return removeTableByKey(opts, editor, selection.start.key);\n}\n/**\n * Move selection by a {x,y} relative movement\n */\n\n\nfunction moveSelectionBy(opts, change, x, //  Move horizontally by x\ny // Move vertically by y\n) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelectionBy can only be applied in a cell');\n  }\n\n  var rowIndex = pos.getRowIndex();\n  var colIndex = pos.getColumnIndex();\n  var width = pos.getWidth();\n  var height = pos.getHeight();\n\n  var _normPos = normPos(x + colIndex, y + rowIndex, width, height),\n      _normPos2 = _slicedToArray(_normPos, 2),\n      absX = _normPos2[0],\n      absY = _normPos2[1];\n\n  var isGoingUp = y < 0;\n\n  if (absX === -1) {\n    // Out of table\n    return change;\n  }\n\n  var table = pos.table;\n  var row = table.nodes.get(absY);\n  var cell = row.nodes.get(absX);\n\n  if (isGoingUp) {\n    change.moveToEndOfNode(cell);\n  } else {\n    change.moveToStartOfNode(cell);\n  }\n\n  return change;\n}\n/**\n * Normalize position in a table. If x is out of the row, update y accordingly.\n * Returns [-1, -1] if the new selection is out of table\n */\n\n\nfunction normPos(x, y, width, height) {\n  if (x < 0) {\n    x = width - 1;\n    y -= 1;\n  }\n\n  if (y < 0) {\n    return [-1, -1];\n  }\n\n  if (x >= width) {\n    x = 0;\n    y += 1;\n  }\n\n  if (y >= height) {\n    return [-1, -1];\n  }\n\n  return [x, y];\n}\n/**\n * Move selection by a {x,y} relative movement\n */\n\n\nfunction moveSelectionOutOfTable(opts, editor) {\n  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var value = editor.value;\n  var selection = value.selection,\n      document = value.document;\n  var pos = TablePosition.create(opts, document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelectionOutOfTable can only be applied in a cell');\n  }\n\n  var table = pos.table;\n  var isGoingUp = direction < 0;\n\n  if (isGoingUp) {\n    var previousNode = document.getPreviousBlock(table.key);\n    previousNode && editor.moveToEndOfNode(previousNode);\n  } else {\n    var nextNode = document.getNextBlock(table.key);\n    nextNode && editor.moveToStartOfNode(nextNode);\n  }\n\n  return editor;\n}\n\nvar CHILD_OBJECT_INVALID = 'child_object_invalid';\nvar CHILD_TYPE_INVALID = 'child_type_invalid';\nvar PARENT_TYPE_INVALID = 'parent_type_invalid';\n/*\n * Returns a schema definition for the plugin\n */\n\nfunction schema(opts) {\n  var _blocks;\n\n  return {\n    blocks: (_blocks = {}, _defineProperty(_blocks, opts.typeTable, {\n      nodes: [{\n        match: {\n          type: opts.typeRow\n        }\n      }],\n      parent: [{\n        object: 'document'\n      }],\n      normalize: function normalize(editor, _ref) {\n        var code = _ref.code,\n            node = _ref.node;\n\n        if (code === 'parent_object_invalid') {\n          editor.insertText(node.text);\n          editor.removeNodeByKey(node.key);\n        }\n      }\n    }), _defineProperty(_blocks, opts.typeRow, {\n      nodes: [{\n        match: {\n          type: opts.typeCell\n        }\n      }],\n      parent: {\n        type: opts.typeTable\n      },\n      normalize: function normalize(change, error) {\n        switch (error.code) {\n          case CHILD_TYPE_INVALID:\n            return onlyCellsInRow(opts, change, error);\n\n          case PARENT_TYPE_INVALID:\n            return rowOnlyInTable(opts, change, error);\n        }\n      }\n    }), _defineProperty(_blocks, opts.typeCell, {\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }],\n      parent: {\n        type: opts.typeRow\n      },\n      normalize: function normalize(change, error) {\n        switch (error.code) {\n          case CHILD_OBJECT_INVALID:\n            return onlyBlocksInCell(opts, change, error.node);\n\n          case PARENT_TYPE_INVALID:\n            return cellOnlyInRow(opts, change, error);\n        }\n      }\n    }), _blocks)\n  };\n}\n/*\n * A row's children must be cells.\n * If they're not then we wrap them within a cell.\n */\n\n\nfunction onlyCellsInRow(opts, change, error) {\n  var cell = createCell(opts, []);\n  var index = error.node.nodes.findIndex(function (child) {\n    return child.key === error.child.key;\n  });\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(error.node.key, index, cell);\n    change.moveNodeByKey(error.child.key, cell.key, 0);\n  });\n}\n/*\n * Rows can't live outside a table, if one is found then we wrap it within a table.\n */\n\n\nfunction rowOnlyInTable(opts, change, error) {\n  return change.wrapBlockByKey(error.node.key, opts.typeTable);\n}\n/*\n * A cell's children must be \"block\"s.\n * If they're not then we wrap them within a block with a type of opts.typeContent\n */\n\n\nfunction onlyBlocksInCell(opts, change, node) {\n  change.wrapBlockByKey(node.nodes.first().key, opts.typeContent);\n  var wrapper = change.value.document.getDescendant(node.key).nodes.first(); // Add in the remaining items\n\n  node.nodes.rest().forEach(function (child, index) {\n    return change.moveNodeByKey(child.key, wrapper.key, index + 1);\n  });\n  return change;\n  /*     const block = Block.create({\n      type: opts.typeContent,\n  });\n  change.withoutNormalizing(() => {\n      change.insertNodeByKey(error.node.key, 0, block);\n      const inlines = error.node.nodes.filter(\n          node => node.object !== 'block',\n      );\n      inlines.forEach((inline, index) => {\n          change.moveNodeByKey(inline.key, block.key, index);\n      });\n  }); */\n}\n/*\n * Cells can't live outside a row, if one is found then we wrap it within a row.\n */\n\n\nfunction cellOnlyInRow(opts, change, error) {\n  return change.wrapBlockByKey(error.node.key, opts.typeRow);\n}\n/*\n * Ensure each row has the same number of columns.\n */\n\n\nfunction normalizeNode(opts) {\n  var isRow = function isRow(node) {\n    return node.type === opts.typeRow;\n  };\n\n  var countNodes = function countNodes(row) {\n    return row.nodes.size;\n  };\n\n  return function (node, editor, next) {\n    if (node.type !== opts.typeTable) {\n      return next();\n    }\n\n    var rows = node.nodes.filter(isRow);\n    var maxColumns = Math.max( // Minimum 1 column\n    1, rows.map(countNodes).max());\n    var rowsMissingColumns = rows.filter(function (row) {\n      return countNodes(row) < maxColumns;\n    });\n\n    if (rowsMissingColumns.isEmpty()) {\n      return next();\n    }\n\n    return function (change) {\n      change.withoutNormalizing(function () {\n        rowsMissingColumns.forEach(function (row) {\n          var numberOfCellsToAdd = maxColumns - row.nodes.size;\n          var cells = Array.from({\n            length: numberOfCellsToAdd\n          }).map(function () {\n            return createCell(opts);\n          });\n          cells.forEach(function (cell) {\n            return change.insertNodeByKey(row.key, row.nodes.size, cell);\n          });\n        });\n      });\n    };\n  };\n}\n/**\n * Returns the core of the plugin, limited to the validation and normalization\n * part of `slate-edit-table`, and utils.\n *\n * Import this directly: `import EditTable from 'slate-edit-table/lib/core'`\n * if you don't care about behavior/rendering and you\n * are only manipulating `Slate.Values` without rendering them.\n * That way you do not depend on `slate-react`.\n */\n\n\nfunction core(optionsParam) {\n  var opts = new Options(optionsParam);\n  return {\n    schema: schema(opts),\n    normalizeNode: normalizeNode(opts),\n    queries: {\n      isSelectionInTable: isSelectionInTable.bind(null, opts),\n      isSelectionOutOfTable: isSelectionOutOfTable.bind(null, opts),\n      getPosition: getPosition.bind(null, opts),\n      getPositionByKey: getPositionByKey.bind(null, opts),\n      createCell: createCell.bind(null, opts),\n      createRow: createRow.bind(null, opts),\n      createTable: createTable.bind(null, opts),\n      forEachCells: forEachCells.bind(null, opts),\n      getCellsAtRow: getCellsAtRow.bind(null, opts),\n      getCellsAtColumn: getCellsAtColumn.bind(null, opts),\n      getCopiedFragment: getCopiedFragment.bind(null, opts)\n    },\n    commands: {\n      insertTable: insertTable.bind(null, opts),\n      insertTableFragmentAtRange: insertTableFragmentAtRange.bind(null, opts),\n      clearCell: clearCell.bind(null, opts),\n      removeRowByKey: removeRowByKey.bind(null, opts),\n      removeColumnByKey: removeColumnByKey.bind(null, opts),\n      removeTableByKey: removeTableByKey.bind(null, opts),\n      insertRow: bindAndScopeChange(opts, insertRow),\n      removeRow: bindAndScopeChange(opts, removeRow),\n      insertColumn: bindAndScopeChange(opts, insertColumn),\n      removeColumn: bindAndScopeChange(opts, removeColumn),\n      removeTable: bindAndScopeChange(opts, removeTable),\n      moveSelection: bindAndScopeChange(opts, moveSelection),\n      moveSelectionBy: bindAndScopeChange(opts, moveSelectionBy),\n      moveSelectionOutOfTable: bindAndScopeChange(opts, moveSelectionOutOfTable)\n    }\n  };\n}\n/**\n * Bind a change to given options, and scope it to act only inside a table\n */\n\n\nfunction bindAndScopeChange(opts, fn) {\n  return function (editor) {\n    if (!editor.isSelectionInTable()) {\n      return editor;\n    } // $FlowFixMe\n\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return fn.apply(void 0, _toConsumableArray([opts, editor].concat(args)));\n  };\n}\n/**\n * Insert a new row when pressing \"Enter\"\n */\n\n\nfunction onEnter(event, editor, opts, next) {\n  event.preventDefault();\n  var _editor$value = editor.value,\n      selection = _editor$value.selection,\n      document = _editor$value.document;\n  var pos = TablePosition.create(opts, document, selection.start.key);\n  var isAtEdgeOfCell = selection.focus.isAtStartOfNode(pos.cell) || selection.focus.isAtEndOfNode(pos.cell);\n\n  if (!opts.insertRowOnEnter || !isAtEdgeOfCell) {\n    return next();\n  }\n\n  if (event.shiftKey) {\n    return editor.splitBlock().setBlocks({\n      type: opts.typeContent,\n      data: {}\n    });\n  }\n\n  return insertRow(opts, editor);\n}\n/**\n * Exit the current table, by inserting a default block after the table.\n */\n\n\nfunction onModEnter(event, editor, opts, next) {\n  var value = editor.value;\n\n  if (!value.selection.isCollapsed) {\n    return next();\n  }\n\n  event.preventDefault();\n  var exitBlock = Block.create({\n    type: opts.exitBlockType,\n    nodes: [Text.create('')]\n  });\n  var table = TablePosition.create(opts, value.document, value.selection.start.key).table;\n  var tableParent = value.document.getParent(table.key);\n  var insertionIndex = tableParent.nodes.indexOf(table) + 1;\n  return editor.insertNodeByKey(tableParent.key, insertionIndex, exitBlock).moveToStartOfNode(exitBlock);\n}\n/**\n * Select all text of current block.\n */\n\n\nfunction selectAllText(editor) {\n  var value = editor.value;\n  var startBlock = value.startBlock;\n  return editor.moveTo(0).moveFocusForward(startBlock.text.length);\n}\n/**\n * Pressing \"Tab\" moves the cursor to the next cell\n * and select the whole text\n */\n\n\nfunction onTab(event, editor, opts) {\n  event.preventDefault();\n  var value = editor.value;\n  var direction = event.shiftKey ? -1 : +1; // Create new row if needed\n\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (pos.isFirstCell() && direction === -1) {\n    insertRow(opts, editor, 0);\n  } else if (pos.isLastCell() && direction === 1) {\n    insertRow(opts, editor);\n  } // Move back to initial cell (insertRow moves selection automatically).\n\n\n  editor.select(selection); // Move\n\n  moveSelectionBy(opts, editor, direction, 0); // Select all cell.\n\n  return selectAllText(editor);\n}\n\nfunction onBackspace(event, editor, opts, next) {\n  var value = editor.value;\n  var startBlock = value.startBlock,\n      selection = value.selection,\n      endBlock = value.endBlock,\n      document = value.document;\n  var isCollapsed = selection.isCollapsed;\n  var startCell = document.getClosest(startBlock.key, opts.isCell);\n  var endCell = document.getClosest(endBlock.key, opts.isCell);\n  var startPath = startCell.getPath(selection.start.key); // If a cursor is collapsed at the start of the first block, do nothing\n\n  if (selection.start.offset === 0 && isCollapsed && startPath && startPath.every(function (index) {\n    return index === 0;\n  })) {\n    if (editor.isVoid(startBlock)) {\n      // Delete the block normally if it is a void block\n      return next();\n    }\n\n    event.preventDefault();\n    return editor;\n  } // If \"normal\" deletion, we continue\n\n\n  if (startCell === endCell) {\n    return next();\n  } // If cursor is between multiple blocks,\n  // we clear the content of the cells.\n\n\n  event.preventDefault();\n  var blocks = value.blocks; // Get all cells that contains the selection\n\n  var cells = blocks.map(function (node) {\n    return node.type === opts.typeCell ? node : document.getClosest(node.key, function (a) {\n      return a.type === opts.typeCell;\n    });\n  }).toSet(); // If the cursor is at the very end of the first cell, ignore it.\n  // If the cursor is at the very start of the last cell, ignore it.\n  // This behavior is to compensate hanging selection behaviors:\n  // https://github.com/ianstormtaylor/slate/pull/1605\n\n  var ignoreFirstCell = value.selection.moveToStart().anchor.isAtEndOfNode(cells.first());\n  var ignoreLastCell = value.selection.moveToEnd().anchor.isAtStartOfNode(cells.last());\n  var cellsToClear = cells;\n\n  if (ignoreFirstCell) {\n    cellsToClear = cellsToClear.rest();\n  }\n\n  if (ignoreLastCell) {\n    cellsToClear = cellsToClear.butLast();\n  } // Clear all the selection\n\n\n  cellsToClear.forEach(function (cell) {\n    return clearCell(opts, editor, cell);\n  }); // Update the selection properly, and avoid reset of selection\n\n  var updatedStartCell = editor.value.document.getDescendant(cellsToClear.first().key);\n  return editor.moveToStartOfNode(updatedStartCell);\n}\n\nfunction onUpDown(event, editor, opts, next) {\n  var value = editor.value;\n  var direction = event.key === 'ArrowUp' ? -1 : +1;\n  var pos = TablePosition.create(opts, value.document, value.selection.start.key);\n\n  if (pos.isFirstRow() && direction === -1 && pos.isTopOfCell() || pos.isLastRow() && direction === +1 && pos.isBottomOfCell()) {\n    if (opts.edgeRowExitOnDirection) {\n      event.preventDefault();\n      return moveSelectionOutOfTable(opts, editor, direction);\n    } else {\n      // Let the default behavior move out of the table\n      return next();\n    }\n  }\n\n  if (direction === -1 && !pos.isTopOfCell()) {\n    return next();\n  }\n\n  if (direction === +1 && !pos.isBottomOfCell()) {\n    return next();\n  }\n\n  event.preventDefault();\n  moveSelectionBy(opts, editor, 0, direction);\n  return editor;\n}\n\nfunction onUpDown$1(event, editor, opts) {\n  var direction = event.key === 'ArrowUp' ? -1 : +1;\n  event.preventDefault();\n  moveSelectionOutOfTable(opts, editor, direction);\n  return editor;\n}\n\nvar KEY_ENTER = 'Enter';\nvar KEY_TAB = 'Tab';\nvar KEY_BACKSPACE = 'Backspace';\nvar KEY_DOWN = 'ArrowDown';\nvar KEY_UP = 'ArrowUp';\n/**\n * User is pressing a key in the editor\n */\n\nfunction onKeyDown(opts, event, editor, next) {\n  // Only handle events in cells\n  if (!editor.isSelectionInTable()) {\n    return next();\n  } // Build arguments list\n\n\n  var args = [event, editor, opts, next];\n\n  switch (event.key) {\n    case KEY_ENTER:\n      if (event.metaKey && opts.exitBlockType) {\n        return onModEnter.apply(void 0, args);\n      }\n\n      return onEnter.apply(void 0, args);\n\n    case KEY_TAB:\n      return onTab.apply(void 0, args);\n\n    case KEY_BACKSPACE:\n      return onBackspace.apply(void 0, args);\n\n    case KEY_DOWN:\n    case KEY_UP:\n      if (event.metaKey) {\n        return onUpDown$1.apply(void 0, args);\n      }\n\n      return onUpDown.apply(void 0, args);\n\n    default:\n      return next();\n  }\n}\n\nfunction onCopy(opts, event, editor, next) {\n  if (!editor.isSelectionInTable()) {\n    return next();\n  }\n\n  var fragment = getCopiedFragment(opts, editor.value);\n  if (!fragment) return next();\n  var tempEditor = new Editor({\n    value: Value.fromJSON({\n      document: fragment\n    })\n  });\n  tempEditor.moveToRangeOfDocument();\n  cloneFragment(event, tempEditor);\n}\n/**\n *  Returns the full plugin object (behavior + rendering + schema)\n */\n\n\nfunction EditTable( // The plugin options\noptionsParam) {\n  var opts = new Options(optionsParam || {});\n  var corePlugin = core(opts);\n  return _objectSpread({}, corePlugin, {\n    onKeyDown: onKeyDown.bind(null, opts),\n    onCopy: onCopy.bind(null, opts)\n  });\n}\n\nexport default EditTable;","map":null,"metadata":{},"sourceType":"module"}