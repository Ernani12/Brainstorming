{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _utils = require('../utils');\n/**\n * Increase the depth of the current item by putting it in a sub-list\n * of previous item.\n * For first items in a list, does nothing.\n */\n\n\nfunction increaseItemDepth(opts, change) {\n  var previousItem = (0, _utils.getPreviousItem)(opts, change.value);\n  var currentItem = (0, _utils.getCurrentItem)(opts, change.value);\n  var maxDepth = opts.maxDepth * 2;\n\n  if (!previousItem) {\n    return change;\n  }\n\n  if (!currentItem) {\n    return change;\n  } // Get the depth of the focused list item.\n\n\n  var currentItemDepth = change.value.document.getDepth(currentItem.key); // Make sure the level of the focused item is below the defined maximum.\n\n  if (currentItemDepth >= maxDepth) {\n    return change;\n  } // Get the depth of the deepest `li` descendant of the focused item.\n\n\n  var deepestItemDepth = (0, _utils.getDeepestItemDepth)(currentItem, change.value.document); // This prevents from indenting parents of too deeply nested list items.\n\n  if (deepestItemDepth >= maxDepth) {\n    return change;\n  } // Move the item in the sublist of previous item\n\n\n  return moveAsSubItem(opts, change, currentItem, previousItem.key);\n}\n/**\n * Move the given item to the sublist at the end of destination item,\n * creating a sublist if needed.\n */\n\n\nfunction moveAsSubItem(opts, change, // The list item to add\nitem, // The key of the destination node\ndestKey) {\n  var destination = change.value.document.getDescendant(destKey);\n  var lastIndex = destination.nodes.size;\n  var lastChild = destination.nodes.last(); // The potential existing last child list\n\n  var existingList = (0, _utils.isList)(opts, lastChild) ? lastChild : null;\n\n  if (existingList) {\n    return change.moveNodeByKey(item.key, existingList.key, existingList.nodes.size // as last item\n    );\n  }\n\n  var currentList = (0, _utils.getListForItem)(opts, change.value, destination);\n\n  if (!currentList) {\n    throw new Error('Destination is not in a list');\n  } // Creating empty list creates also empty list item - placeholder item is meant to be easily deleted in the end\n\n\n  var tmpBlock = _slate.Block.create({\n    object: 'block',\n    type: opts.typeItem\n  }); // @TODO Why does empty list contain empty item?\n\n\n  var newSublist = _slate.Block.create({\n    object: 'block',\n    type: currentList.type,\n    data: currentList.data,\n    nodes: [tmpBlock]\n  });\n\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(destKey, lastIndex, newSublist);\n  });\n  change.moveNodeByKey(item.key, newSublist.key, 0);\n  change.removeNodeByKey(tmpBlock.key);\n  return change;\n}\n\nexports.default = increaseItemDepth;","map":null,"metadata":{},"sourceType":"script"}