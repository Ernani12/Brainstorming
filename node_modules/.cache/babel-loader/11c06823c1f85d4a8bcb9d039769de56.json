{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _prismjs = require('prismjs');\n\nvar _prismjs2 = _interopRequireDefault(_prismjs);\n\nrequire('slate');\n\nvar _options = require('./options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _TOKEN_MARK = require('./TOKEN_MARK');\n\nvar _TOKEN_MARK2 = _interopRequireDefault(_TOKEN_MARK);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A Slate plugin to highlight code syntax.\n */\n\n\nfunction PrismPlugin() {\n  var optsParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var opts = new _options2.default(optsParam);\n  return {\n    decorateNode: function decorateNode(node) {\n      if (!opts.onlyIn(node)) {\n        return undefined;\n      }\n\n      return _decorateNode(opts, node);\n    },\n    renderMark: opts.renderMark,\n    TOKEN_MARK: _TOKEN_MARK2.default\n  };\n}\n/**\n * Returns the decoration for a node\n */\n\n\nfunction _decorateNode(opts, block) {\n  var grammarName = opts.getSyntax(block);\n  var grammar = _prismjs2.default.languages[grammarName];\n\n  if (!grammar) {\n    // Grammar not loaded\n    return [];\n  } // Tokenize the whole block text\n\n\n  var texts = block.getTexts();\n  var blockText = texts.map(function (t) {\n    return t.text;\n  }).join('\\n');\n\n  var tokens = _prismjs2.default.tokenize(blockText, grammar); // The list of decorations to return\n\n\n  var decorations = [];\n  var textStart = 0;\n  var textEnd = 0;\n  texts.forEach(function (text) {\n    textEnd = textStart + text.text.length;\n    var offset = 0;\n\n    function processToken(token, accu) {\n      accu = accu || '';\n\n      if (typeof token === 'string') {\n        if (accu) {\n          var decoration = createDecoration({\n            text: text,\n            textStart: textStart,\n            textEnd: textEnd,\n            start: offset,\n            end: offset + token.length,\n            className: 'prism-token token ' + accu\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n        }\n\n        offset += token.length;\n      } else {\n        accu = accu + ' ' + token.type + ' ' + (token.alias || '');\n\n        if (typeof token.content === 'string') {\n          var _decoration = createDecoration({\n            text: text,\n            textStart: textStart,\n            textEnd: textEnd,\n            start: offset,\n            end: offset + token.content.length,\n            className: 'prism-token token ' + accu\n          });\n\n          if (_decoration) {\n            decorations.push(_decoration);\n          }\n\n          offset += token.content.length;\n        } else {\n          // When using token.content instead of token.matchedStr, token can be deep\n          for (var i = 0; i < token.content.length; i += 1) {\n            processToken(token.content[i], accu);\n          }\n        }\n      }\n    }\n\n    tokens.forEach(processToken);\n    textStart = textEnd + 1; // account for added `\\n`\n  });\n  return decorations;\n}\n/**\n * Return a decoration range for the given text.\n */\n\n\nfunction createDecoration(_ref) {\n  var text = _ref.text,\n      textStart = _ref.textStart,\n      textEnd = _ref.textEnd,\n      start = _ref.start,\n      end = _ref.end,\n      className = _ref.className;\n\n  if (start >= textEnd || end <= textStart) {\n    // Ignore, the token is not in the text\n    return null;\n  } // Shrink to this text boundaries\n\n\n  start = Math.max(start, textStart);\n  end = Math.min(end, textEnd); // Now shift offsets to be relative to this text\n\n  start -= textStart;\n  end -= textStart;\n  return {\n    anchor: {\n      key: text.key,\n      offset: start\n    },\n    focus: {\n      key: text.key,\n      offset: end\n    },\n    mark: {\n      type: 'prism-token',\n      data: {\n        className: className\n      }\n    }\n  };\n}\n\nexports.default = PrismPlugin;","map":null,"metadata":{},"sourceType":"script"}