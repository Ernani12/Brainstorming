{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MarkdownShortcuts;\n\nvar _slate = require(\"slate\");\n\nvar inlineShortcuts = [{\n  mark: \"bold\",\n  shortcut: \"**\"\n}, {\n  mark: \"bold\",\n  shortcut: \"__\"\n}, {\n  mark: \"italic\",\n  shortcut: \"*\"\n}, {\n  mark: \"italic\",\n  shortcut: \"_\"\n}, {\n  mark: \"code\",\n  shortcut: \"`\"\n}, {\n  mark: \"inserted\",\n  shortcut: \"++\"\n}, {\n  mark: \"deleted\",\n  shortcut: \"~~\"\n}];\n\nfunction MarkdownShortcuts() {\n  function onKeyDown(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock;\n    if (!startBlock) return next(); // markdown shortcuts should not be parsed in code\n\n    if (startBlock.type.match(/code/)) return next();\n\n    switch (ev.key) {\n      case \"-\":\n        return onDash(ev, editor, next);\n\n      case \"`\":\n        return onBacktick(ev, editor, next);\n\n      case \" \":\n        return onSpace(ev, editor, next);\n\n      default:\n        return next();\n    }\n  }\n  /**\n   * On space, if it was after an auto-markdown shortcut, convert the current\n   * node into the shortcut's corresponding type.\n   */\n\n\n  function onSpace(ev, editor, next) {\n    var value = editor.value;\n    var selection = value.selection,\n        startBlock = value.startBlock;\n    if (selection.isExpanded) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).trim();\n    var type = getType(chars);\n\n    if (type && !editor.isSelectionInTable()) {\n      // only shortcuts to change heading size should work in headings\n      if (startBlock.type.match(/heading/) && !type.match(/heading/)) {\n        return next();\n      } // don't allow doubling up a list item\n\n\n      if (type === \"list-item\" && startBlock.type === \"list-item\") {\n        return next();\n      }\n\n      ev.preventDefault();\n      var checked = void 0;\n      if (chars === \"[x]\") checked = true;\n      if (chars === \"[ ]\") checked = false;\n      editor.withoutNormalizing(function (c) {\n        c.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n          type: type,\n          data: {\n            checked: checked\n          }\n        });\n\n        if (type === \"list-item\") {\n          if (checked !== undefined) {\n            return c.wrapBlock(\"todo-list\");\n          } else if (chars === \"1.\") {\n            return c.wrapBlock(\"ordered-list\");\n          } else {\n            return c.wrapBlock(\"bulleted-list\");\n          }\n        }\n\n        return next();\n      });\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = inlineShortcuts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value; // find all inline characters\n\n        var mark = key.mark,\n            shortcut = key.shortcut;\n        var inlineTags = []; // only add tags if they have spaces around them or the tag is beginning\n        // or the end of the block\n\n        for (var i = 0; i < startBlock.text.length; i++) {\n          var text = startBlock.text;\n          var start = i;\n          var end = i + shortcut.length;\n          var beginningOfBlock = start === 0;\n          var endOfBlock = end === text.length;\n          var surroundedByWhitespaces = [text.slice(start - 1, start), text.slice(end, end + 1)].includes(\" \");\n\n          if (text.slice(start, end) === shortcut && (beginningOfBlock || endOfBlock || surroundedByWhitespaces)) {\n            inlineTags.push(i);\n          }\n        } // if we have multiple tags then mark the text between\n\n\n        if (inlineTags.length > 1) {\n          var firstText = startBlock.getFirstText();\n          var firstCodeTagIndex = inlineTags[0];\n          var lastCodeTagIndex = inlineTags[inlineTags.length - 1];\n          return editor.removeTextByKey(firstText.key, lastCodeTagIndex, shortcut.length).removeTextByKey(firstText.key, firstCodeTagIndex, shortcut.length).moveAnchorTo(firstCodeTagIndex, lastCodeTagIndex - shortcut.length).addMark(mark).moveToEnd().removeMark(mark);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return next();\n  }\n\n  function onDash(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n    if (selection.isExpanded) return next();\n    if (startBlock.type.match(/heading/)) return next();\n    if (editor.isSelectionInTable()) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"--\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n        type: \"horizontal-rule\",\n        isVoid: true\n      }, {\n        normalize: false\n      }).insertBlock(\"paragraph\").moveToStart();\n    }\n\n    return next();\n  }\n\n  function onBacktick(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n    if (selection.isExpanded) return next();\n    if (startBlock.type.match(/heading/)) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"``\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n        type: \"code\"\n      });\n    }\n\n    return next();\n  }\n  /**\n   * Get the block type for a series of auto-markdown shortcut `chars`.\n   */\n\n\n  function getType(chars) {\n    switch (chars) {\n      case \"*\":\n      case \"-\":\n      case \"+\":\n      case \"1.\":\n      case \"[ ]\":\n      case \"[x]\":\n        return \"list-item\";\n\n      case \">\":\n        return \"block-quote\";\n\n      case \"#\":\n        return \"heading1\";\n\n      case \"##\":\n        return \"heading2\";\n\n      case \"###\":\n        return \"heading3\";\n\n      case \"####\":\n        return \"heading4\";\n\n      case \"#####\":\n        return \"heading5\";\n\n      case \"######\":\n        return \"heading6\";\n\n      default:\n        return null;\n    }\n  }\n\n  return {\n    onKeyDown: onKeyDown\n  };\n}","map":null,"metadata":{},"sourceType":"script"}