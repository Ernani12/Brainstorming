{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // getWords: Get the word array from text. A single Chinese character is a word.\n\nfunction getWords(txt) {\n  var words = [];\n  var word = '';\n\n  for (var i = 0; i < txt.length; ++i) {\n    var ch = txt.charCodeAt(i);\n\n    if (ch < 33 || ch > 126) {\n      if (word) {\n        words.push(word);\n        word = '';\n      }\n\n      words.push(txt[i]);\n      continue;\n    } else {\n      word += txt[i];\n    }\n  }\n\n  if (word) {\n    words.push(word);\n  }\n\n  return words;\n}\n\nexports.getWords = getWords; // getLinesï¼šGet lines of drawing text.\n// words - the word array of text, to avoid spliting a word.\n// maxWidth - the max width of the rect.\n\nfunction getLines(ctx, words, maxWidth) {\n  var lines = [];\n  var currentLine = words[0] || '';\n\n  for (var i = 1; i < words.length; ++i) {\n    var word = words[i] || '';\n\n    if (ctx.measureText(currentLine + word).width < maxWidth) {\n      currentLine += word;\n    } else {\n      lines.push(currentLine);\n      currentLine = word;\n    }\n  }\n\n  lines.push(currentLine);\n  return lines;\n}\n\nexports.getLines = getLines;\n\nfunction textBk(ctx, str, x, y, height, color) {\n  if (!str || !color) {\n    return;\n  }\n\n  var w = ctx.measureText(str).width;\n  ctx.save();\n  ctx.fillStyle = color;\n  var l = x - w / 2;\n  var t = y - height / 2;\n\n  switch (ctx.textAlign) {\n    case 'left':\n      l = x;\n      break;\n\n    case 'right':\n      l = x - w;\n      break;\n  }\n\n  switch (ctx.textBaseline) {\n    case 'top':\n      t = y;\n      break;\n\n    case 'bottom':\n      t = y - height;\n      break;\n  }\n\n  ctx.fillRect(l, t, w, height);\n  ctx.restore();\n}\n\nfunction fillText(ctx, lines, x, y, width, height, lineHeight, maxLineLen, bk) {\n  if (!maxLineLen || maxLineLen > lines.length) {\n    maxLineLen = lines.length;\n  } else {\n    maxLineLen = Math.ceil(maxLineLen);\n  }\n\n  for (var i = 0; i < maxLineLen - 1; ++i) {\n    if (bk) {\n      textBk(ctx, lines[i], x, y + i * lineHeight, lineHeight, bk);\n    }\n\n    ctx.fillText(lines[i], x, y + i * lineHeight);\n  }\n\n  if (maxLineLen < lines.length) {\n    var str = (lines[maxLineLen - 1] || '') + '...';\n\n    if (lines[maxLineLen - 1] && ctx.measureText(str).width > width) {\n      str = lines[maxLineLen - 1].substr(0, lines[maxLineLen - 1].length - 2) + '...';\n    }\n\n    if (bk) {\n      textBk(ctx, str, x, y + (maxLineLen - 1) * lineHeight, lineHeight, bk);\n    }\n\n    ctx.fillText(str, x, y + (maxLineLen - 1) * lineHeight);\n  } else {\n    if (bk) {\n      textBk(ctx, lines[maxLineLen - 1], x, y + (maxLineLen - 1) * lineHeight, lineHeight, bk);\n    }\n\n    ctx.fillText(lines[maxLineLen - 1], x, y + (maxLineLen - 1) * lineHeight);\n  }\n}\n\nexports.fillText = fillText;\n\nfunction text(ctx, node) {\n  if (!node.text) {\n    return;\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.shadowColor = '';\n  ctx.shadowBlur = 0;\n  ctx.font = (node.font.fontStyle || 'normal') + \" normal \" + (node.font.fontWeight || 'normal') + \" \" + node.font.fontSize + \"px/\" + node.font.lineHeight + \" \" + node.font.fontFamily;\n\n  if (node.font.color) {\n    ctx.fillStyle = node.font.color;\n  } else {\n    ctx.fillStyle = '#222';\n  }\n\n  if (node.font.textAlign) {\n    ctx.textAlign = node.font.textAlign;\n  }\n\n  if (node.font.textBaseline) {\n    ctx.textBaseline = node.font.textBaseline;\n  }\n\n  var textRect = node.getTextRect();\n  var lines = [];\n  var paragraphs = node.text.split(/[\\n,]/g);\n\n  for (var i = 0; i < paragraphs.length; ++i) {\n    var l = getLines(ctx, getWords(paragraphs[i]), textRect.width);\n    lines.push.apply(lines, l);\n  }\n\n  var lineHeight = node.font.fontSize * node.font.lineHeight;\n  var maxLineLen = node.textMaxLine;\n  var rectLines = textRect.height / lineHeight;\n\n  if (!maxLineLen) {\n    maxLineLen = lines.length > rectLines ? rectLines : lines.length;\n  } // By default, the text is center aligned.\n\n\n  var x = textRect.x + textRect.width / 2;\n  var y = textRect.y + (textRect.height - lineHeight * maxLineLen) / 2 + lineHeight * 4 / 7;\n\n  switch (ctx.textAlign) {\n    case 'left':\n      x = textRect.x;\n      break;\n\n    case 'right':\n      x = textRect.x + textRect.width;\n      break;\n  }\n\n  switch (ctx.textBaseline) {\n    case 'top':\n      y = textRect.y + (lineHeight - node.font.fontSize) / 2;\n      break;\n\n    case 'bottom':\n      y = textRect.ey - lineHeight * lines.length + lineHeight;\n      break;\n  }\n\n  fillText(ctx, lines, x + node.textOffsetX, y + node.textOffsetY, textRect.width, textRect.height, lineHeight, maxLineLen, node.font.background);\n  ctx.restore();\n}\n\nexports.text = text;\n\nfunction iconfont(ctx, node) {\n  ctx.save();\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  var iconRect = node.getIconRect();\n  var x = iconRect.x + iconRect.width / 2;\n  var y = iconRect.y + iconRect.height / 2;\n\n  switch (node.imageAlign) {\n    case 'top':\n      y = iconRect.y;\n      ctx.textBaseline = 'top';\n      break;\n\n    case 'bottom':\n      y = iconRect.ey;\n      ctx.textBaseline = 'bottom';\n      break;\n\n    case 'left':\n      x = iconRect.x;\n      ctx.textAlign = 'left';\n      break;\n\n    case 'right':\n      x = iconRect.ex;\n      ctx.textAlign = 'right';\n      break;\n\n    case 'left-top':\n      x = iconRect.x;\n      y = iconRect.y;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'top';\n      break;\n\n    case 'right-top':\n      x = iconRect.ex;\n      y = iconRect.y;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'top';\n      break;\n\n    case 'left-bottom':\n      x = iconRect.x;\n      y = iconRect.ey;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'bottom';\n      break;\n\n    case 'right-bottom':\n      x = iconRect.ex;\n      y = iconRect.ey;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'bottom';\n      break;\n  }\n\n  if (node.iconSize > 0) {\n    ctx.font = node.iconSize + \"px \" + node.iconFamily;\n  } else if (iconRect.width > iconRect.height) {\n    ctx.font = iconRect.height + \"px \" + node.iconFamily;\n  } else {\n    ctx.font = iconRect.width + \"px \" + node.iconFamily;\n  }\n\n  if (!node.iconColor) {\n    node.iconColor = '#2f54eb';\n  }\n\n  ctx.fillStyle = node.iconColor;\n  ctx.beginPath();\n  ctx.fillText(node.icon, x, y);\n  ctx.restore();\n}\n\nexports.iconfont = iconfont;","map":null,"metadata":{},"sourceType":"script"}