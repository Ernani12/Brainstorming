{"ast":null,"code":"import { Record, List, Map as Map$1 } from 'immutable';\nimport debug from 'debug';\nimport isPlainObject from 'is-plain-object';\nimport memoizeOne from 'memoize-one';\nimport warning from 'tiny-warning';\nconst TopicDirection = {\n  LEFT: 'L',\n  RIGHT: 'R',\n  BOTTOM: 'B',\n  MAIN: 'M' // root\n\n};\nvar DiagramLayoutType;\n\n(function (DiagramLayoutType) {\n  DiagramLayoutType[DiagramLayoutType[\"LEFT_TO_RIGHT\"] = 0] = \"LEFT_TO_RIGHT\";\n  DiagramLayoutType[DiagramLayoutType[\"RIGHT_TO_LEFT\"] = 1] = \"RIGHT_TO_LEFT\";\n  DiagramLayoutType[DiagramLayoutType[\"LEFT_AND_RIGHT\"] = 2] = \"LEFT_AND_RIGHT\";\n  DiagramLayoutType[DiagramLayoutType[\"TOP_TO_BOTTOM\"] = 3] = \"TOP_TO_BOTTOM\";\n})(DiagramLayoutType || (DiagramLayoutType = {}));\n\nconst TopicVisualLevel = {\n  ROOT: 0,\n  PRIMARY: 1,\n  NORMAL: 2\n};\nconst BlockType = {\n  CONTENT: 'CONTENT',\n  DESC: 'DESC'\n};\nconst FocusMode = {\n  NORMAL: 'NORMAL',\n  EDITING_CONTENT: 'EDITING_CONTENT',\n  EDITING_DESC: 'EDITING_DESC',\n  SHOW_POPUP: 'SHOW_POPUP',\n  DRAGGING: 'DRAGGING'\n};\nconst TopicRelationship = {\n  ANCESTOR: 'ANCESTOR',\n  DESCENDANT: 'DESCENDANT',\n  SIBLING: 'SIBLING',\n  NONE: 'NONE'\n};\nconst OpType = {\n  TOGGLE_COLLAPSE: 'TOGGLE_COLLAPSE',\n  COLLAPSE_ALL: 'COLLAPSE_ALL',\n  EXPAND_ALL: 'EXPAND_ALL',\n  EXPAND_TO: 'EXPAND_TO',\n  ADD_CHILD: 'ADD_CHILD',\n  ADD_SIBLING: 'ADD_SIBLING',\n  DELETE_TOPIC: 'DELETE_TOPIC',\n  FOCUS_TOPIC: 'FOCUS_TOPIC',\n  SET_FOCUS_MODE: 'SET_FOCUS_MODE',\n  SET_STYLE: 'SET_STYLE',\n  CLEAR_ALL_CUSTOM_STYLE: 'CLEAR_ALL_CUSTOM_STYLE',\n  SET_THEME: 'SET_THEME',\n  SET_TOPIC_BLOCK: 'SET_TOPIC_BLOCK',\n  DELETE_TOPIC_BLOCK: 'DELETE_TOPIC_BLOCK',\n  // SET_TOPIC_CONTENT: 'SET_TOPIC_CONTENT',\n  // SET_TOPIC_DESC: 'SET_TOPIC_DESC',\n  START_EDITING_CONTENT: 'START_EDITING_CONTENT',\n  START_EDITING_DESC: 'START_EDITING_DESC',\n  DRAG_AND_DROP: 'DRAG_AND_DROP',\n  SET_EDITOR_ROOT: 'SET_EDITOR_ROOT',\n  SET_LAYOUT_DIR: 'SET_LAYOUT_DIR'\n};\nconst defaultBlockRecord = {\n  type: null,\n  key: null,\n  data: null\n};\n\nclass Block extends Record(defaultBlockRecord) {\n  get data() {\n    return this.get('data');\n  }\n\n  get type() {\n    return this.get('type');\n  }\n\n  static create(obj) {\n    return new Block(obj);\n  }\n\n  static createList(obj) {\n    if (List.isList(obj) || Array.isArray(obj)) {\n      // @ts-ignore\n      return List(obj.map(Block.create));\n    }\n\n    throw new Error(`Block.createList only accepts Array or List, but you passed it: ${obj}`);\n  }\n\n}\n\nfunction isThemeType(obj) {\n  return obj.name != null && obj.background != null && obj.highlightColor != null;\n}\n\nconst defaultTheme = {\n  name: 'default',\n  randomColor: true,\n  background: 'rgb(57,60,65)',\n  highlightColor: '#50C9CE',\n  marginH: 60,\n  marginV: 20,\n  contentStyle: {\n    lineHeight: '1.5'\n  },\n  linkStyle: {\n    lineRadius: 5,\n    lineType: 'curve',\n    lineWidth: '3px'\n  },\n  rootTopic: {\n    contentStyle: {\n      fontSize: '34px',\n      borderRadius: '35px',\n      padding: '16px 18px 16px 18px'\n    },\n    subLinkStyle: {\n      lineType: 'curve',\n      lineWidth: '3px',\n      lineColor: 'rgb(113, 203, 45)'\n    }\n  },\n  primaryTopic: {\n    contentStyle: {\n      borderWidth: '1px',\n      borderStyle: 'solid',\n      borderRadius: '20px',\n      fontSize: '17px',\n      padding: '10px 15px 10px 15px'\n    },\n    subLinkStyle: {\n      lineType: 'curve',\n      lineWidth: '3px',\n      lineColor: 'rgb(113, 203, 45)'\n    }\n  },\n  normalTopic: {\n    contentStyle: {\n      border: '1px solid #e8eaec',\n      borderRadius: '20px',\n      fontSize: '17px',\n      padding: '4px 10px'\n    },\n    subLinkStyle: {\n      lineType: 'curve',\n      lineWidth: '3px',\n      lineColor: 'white'\n    }\n  }\n};\nconst defaultConfigRecord = {\n  readOnly: false,\n  allowUndo: true,\n  layoutDir: DiagramLayoutType.LEFT_AND_RIGHT,\n  theme: defaultTheme\n};\n\nclass Config extends Record(defaultConfigRecord) {\n  get layoutDir() {\n    return this.get('layoutDir');\n  }\n\n  get readOnly() {\n    return this.get('readOnly');\n  }\n\n  get allowUndo() {\n    return this.get('allowUndo');\n  }\n\n  get theme() {\n    return this.get('theme');\n  }\n\n  static fromJSON(obj) {\n    return new Config(obj);\n  }\n\n}\n\nfunction createKey() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0,\n          v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nconst defaultTopicRecord = {\n  key: null,\n  parentKey: null,\n  collapse: false,\n  subKeys: null,\n  blocks: null,\n  relations: null,\n  style: null\n};\n\nclass Topic extends Record(defaultTopicRecord) {\n  get key() {\n    return this.get('key');\n  }\n\n  get parentKey() {\n    return this.get('parentKey');\n  }\n\n  get collapse() {\n    return this.get('collapse');\n  }\n\n  get subKeys() {\n    return this.get('subKeys');\n  }\n\n  get blocks() {\n    return this.get('blocks');\n  }\n\n  get relations() {\n    return this.get('relations');\n  }\n\n  get style() {\n    return this.get('style');\n  }\n\n  getBlock(type) {\n    const index = this.blocks.findIndex(b => b.type === type);\n    if (index === -1) return {\n      index,\n      block: null\n    };\n    return {\n      index,\n      block: this.blocks.get(index)\n    };\n  }\n\n  static fromJSON(obj) {\n    const {\n      key,\n      parentKey = null,\n      blocks,\n      subKeys = [],\n      collapse = false\n    } = obj;\n    return new Topic({\n      key,\n      parentKey,\n      collapse,\n      subKeys: List(subKeys),\n      blocks: Block.createList(blocks)\n    });\n  }\n\n  static create(_ref) {\n    let {\n      key,\n      parentKey = null,\n      content = '',\n      subKeys = [],\n      collapse = false\n    } = _ref;\n    const block = Block.create({\n      type: BlockType.CONTENT,\n      data: content,\n      key: null\n    });\n    const blocks = List([block]);\n    return new Topic({\n      key,\n      parentKey,\n      blocks,\n      subKeys: List(subKeys),\n      collapse\n    });\n  }\n\n}\n\nfunction getAllSubTopicKeys(model, topicKey) {\n  const item = model.getTopic(topicKey);\n  let res = [];\n\n  if (item.subKeys.size > 0) {\n    const subKeys = item.subKeys.toArray();\n    res.push(...subKeys);\n    res = subKeys.reduce((acc, key) => {\n      acc.push(...getAllSubTopicKeys(model, key));\n      return acc;\n    }, res);\n  }\n\n  return res;\n}\n\nfunction getKeyPath(model, topicKey) {\n  let reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const res = [topicKey];\n  let item = model.getTopic(topicKey);\n\n  while (item.parentKey) {\n    reverse ? res.push(item.parentKey) : res.unshift(item.parentKey);\n    item = model.getParentTopic(item.key);\n  }\n\n  return res;\n}\n\nfunction getRelationship(model, srcKey, dstKey) {\n  const srcTopic = model.getTopic(srcKey);\n  const dstTopic = model.getTopic(dstKey);\n\n  if (srcTopic && dstTopic) {\n    if (srcTopic.parentKey == dstTopic.parentKey) return TopicRelationship.SIBLING;\n    let pTopic = srcTopic;\n\n    while (pTopic.parentKey) {\n      if (pTopic.parentKey === dstTopic.key) return TopicRelationship.DESCENDANT;\n      pTopic = model.getParentTopic(pTopic.key);\n    }\n\n    pTopic = dstTopic;\n\n    while (pTopic.parentKey) {\n      if (pTopic.parentKey === srcTopic.key) return TopicRelationship.ANCESTOR;\n      pTopic = model.getParentTopic(pTopic.key);\n    }\n  }\n\n  return TopicRelationship.NONE;\n}\n\nconst log = debug('modifier');\n\nfunction toggleCollapse(_ref2) {\n  let {\n    model,\n    topicKey\n  } = _ref2;\n  let topic = model.getTopic(topicKey);\n\n  if (topic && topic.subKeys.size !== 0) {\n    topic = topic.merge({\n      collapse: !topic.collapse\n    });\n    model = model.updateIn(['topics', topic.key, 'collapse'], collapse => !collapse);\n  }\n\n  model = focusTopic({\n    model,\n    topicKey,\n    focusMode: FocusMode.NORMAL\n  });\n  return model;\n}\n\nfunction collapseAll(_ref3) {\n  let {\n    model\n  } = _ref3;\n  const topicKeys = getAllSubTopicKeys(model, model.editorRootTopicKey);\n  log(model);\n  model = model.withMutations(m => {\n    topicKeys.forEach(topicKey => {\n      m.setIn(['topics', topicKey, 'collapse'], true);\n    });\n  });\n  model = focusTopic({\n    model,\n    topicKey: model.editorRootTopicKey,\n    focusMode: FocusMode.NORMAL\n  });\n  return model;\n}\n\nfunction expandAll(_ref4) {\n  let {\n    model\n  } = _ref4;\n  const topicKeys = getAllSubTopicKeys(model, model.editorRootTopicKey);\n  log(model);\n  model = model.withMutations(m => {\n    topicKeys.forEach(topicKey => {\n      m.setIn(['topics', topicKey, 'collapse'], false);\n    });\n  });\n  log(model);\n  return model;\n}\n\nfunction expandTo(_ref5) {\n  let {\n    model,\n    topicKey\n  } = _ref5;\n  const keys = getKeyPath(model, topicKey).filter(t => t !== topicKey);\n  model = model.withMutations(m => {\n    keys.forEach(topicKey => {\n      m.setIn(['topics', topicKey, 'collapse'], false);\n    });\n  }); // 要让这个节点在视口中可见\n\n  if (getRelationship(model, topicKey, model.editorRootTopicKey) !== TopicRelationship.DESCENDANT) {\n    model = model.set('editorRootTopicKey', model.rootTopicKey);\n  }\n\n  return model;\n}\n\nfunction focusTopic(_ref6) {\n  let {\n    model,\n    topicKey,\n    focusMode\n  } = _ref6;\n  log('focus topic');\n  if (topicKey !== model.focusKey) model = model.set('focusKey', topicKey);\n  if (focusMode !== model.focusMode) model = model.set('focusMode', focusMode);\n  return model;\n}\n\nfunction setFocusMode(_ref7) {\n  let {\n    model,\n    focusMode\n  } = _ref7;\n  log('setFocusMode');\n  if (focusMode !== model.focusMode) model = model.set('focusMode', focusMode);\n  return model;\n}\n\nfunction addChild(_ref8) {\n  let {\n    model,\n    topicKey\n  } = _ref8;\n  log('addChild:', topicKey);\n  let topic = model.getTopic(topicKey);\n\n  if (topic) {\n    const child = Topic.create({\n      key: createKey(),\n      parentKey: topic.key\n    });\n    topic = topic.set('collapse', false).update('subKeys', subKeys => subKeys.push(child.key));\n    model = model.update('topics', topics => topics.set(topicKey, topic).set(child.key, child));\n    return focusTopic({\n      model,\n      topicKey: child.key,\n      focusMode: FocusMode.EDITING_CONTENT\n    });\n  }\n\n  return model;\n}\n\nfunction addSibling(_ref9) {\n  let {\n    model,\n    topicKey\n  } = _ref9;\n  if (topicKey === model.rootTopicKey) return model;\n  const topic = model.getTopic(topicKey);\n\n  if (topic) {\n    const pItem = model.getTopic(topic.parentKey);\n    const idx = pItem.subKeys.indexOf(topicKey);\n    const sibling = Topic.create({\n      key: createKey(),\n      parentKey: pItem.key\n    });\n    model = model.update('topics', topics => topics.set(sibling.key, sibling)).updateIn(['topics', pItem.key, 'subKeys'], subKeys => subKeys.insert(idx + 1, sibling.key));\n    return focusTopic({\n      model,\n      topicKey: sibling.key,\n      focusMode: FocusMode.EDITING_CONTENT\n    });\n  }\n\n  return model;\n}\n\nfunction deleteTopic(_ref10) {\n  let {\n    model,\n    topicKey\n  } = _ref10;\n  if (topicKey === model.editorRootTopicKey) return model;\n  const item = model.getTopic(topicKey);\n\n  if (item) {\n    model = model.withMutations(m => {\n      m.update('topics', topics => {\n        topics = topics.delete(topicKey);\n        const deleteKeys = getAllSubTopicKeys(model, topicKey);\n        topics = topics.withMutations(t => {\n          deleteKeys.forEach(dKey => {\n            t.delete(dKey);\n          });\n        });\n        return topics;\n      });\n      m.updateIn(['topics', item.parentKey, 'subKeys'], subKeys => subKeys.delete(subKeys.indexOf(topicKey)));\n      if (m.focusKey === topicKey) m.set('focusKey', null).set('focusMode', null);\n    });\n  }\n\n  return model;\n}\n/**\r\n * setBlockData of one topic\r\n * @param model\r\n * @param topicKey\r\n * @param blockType\r\n * @param focusMode\r\n * @param data\r\n */\n\n\nfunction setBlockData(_ref11) {\n  let {\n    model,\n    topicKey,\n    blockType,\n    focusMode,\n    data\n  } = _ref11;\n  const topic = model.getTopic(topicKey);\n\n  if (topic) {\n    const {\n      index,\n      block\n    } = topic.getBlock(blockType);\n\n    if (index === -1) {\n      model = model.updateIn(['topics', topicKey, 'blocks'], blocks => blocks.push(Block.create({\n        type: blockType,\n        data: data\n      })));\n    } else {\n      if (block.data !== data) {\n        model = model.updateIn(['topics', topicKey, 'blocks', index, 'data'], dt => data);\n      }\n    }\n\n    if (focusMode) {\n      model = focusTopic({\n        model,\n        topicKey,\n        focusMode\n      });\n    }\n  }\n\n  return model;\n}\n\nfunction deleteBlock(_ref12) {\n  let {\n    model,\n    topicKey,\n    blockType\n  } = _ref12;\n  const topic = model.getTopic(topicKey);\n\n  if (topic) {\n    const {\n      index\n    } = topic.getBlock(blockType);\n\n    if (index !== -1) {\n      model = model.updateIn(['topics', topicKey, 'blocks'], blocks => blocks.delete(index));\n    }\n\n    model = focusTopic({\n      model,\n      topicKey: null,\n      focusMode: null\n    });\n  }\n\n  return model;\n}\n\nfunction setStyle(_ref13) {\n  let {\n    model,\n    topicKey,\n    style\n  } = _ref13;\n  const topic = model.getTopic(topicKey);\n\n  if (topic) {\n    if (style !== topic.style) {\n      model = model.updateIn(['topics', topicKey, 'style'], s => style);\n    }\n  }\n\n  return model;\n}\n\nfunction clearAllCustomStyle(_ref14) {\n  let {\n    model\n  } = _ref14;\n  model = model.withMutations(model => {\n    model.topics.keySeq().forEach(key => {\n      model.setIn(['topics', key, 'style'], null);\n    });\n  });\n  return model;\n}\n\nfunction setTheme(_ref15) {\n  let {\n    model,\n    theme\n  } = _ref15;\n  model = model.setIn(['config', 'theme'], theme);\n  return model;\n}\n\nfunction setLayoutDir(_ref16) {\n  let {\n    model,\n    layoutDir\n  } = _ref16;\n  if (model.config.layoutDir === layoutDir) return model;\n  model = model.setIn(['config', 'layoutDir'], layoutDir);\n  return model;\n}\n\nfunction setEditorRootTopicKey(_ref17) {\n  let {\n    model,\n    topicKey\n  } = _ref17;\n  if (model.editorRootTopicKey !== topicKey) model = model.set('editorRootTopicKey', topicKey);\n  if (model.getTopic(topicKey).collapse) model = model.setIn(['topics', topicKey, 'collapse'], false);\n  return model;\n}\n\nfunction setZoomFactor(_ref18) {\n  let {\n    model,\n    zoomFactor\n  } = _ref18;\n  if (model.zoomFactor !== zoomFactor) model = model.set('zoomFactor', zoomFactor);\n  return model;\n}\n\nvar modifiers = {\n  addChild,\n  addSibling,\n  toggleCollapse,\n  collapseAll,\n  expandAll,\n  expandTo,\n  focusTopic,\n  setFocusMode,\n  deleteTopic,\n  setBlockData,\n  deleteBlock,\n  setStyle,\n  clearAllCustomStyle,\n  setTheme,\n  setLayoutDir,\n  setEditorRootTopicKey,\n  setZoomFactor\n};\nconst defaultModelRecord = {\n  topics: Map$1(),\n  extData: Map$1(),\n  config: new Config(),\n  rootTopicKey: null,\n  editorRootTopicKey: null,\n  focusKey: null,\n  focusMode: null,\n  formatVersion: null,\n  zoomFactor: 1\n};\n\nclass Model extends Record(defaultModelRecord) {\n  static isModel(obj) {\n    return obj instanceof Model;\n  }\n\n  static create() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (attrs == null) return Model.createEmpty();\n    let res;\n\n    if (Model.isModel(attrs)) {\n      res = attrs;\n    }\n\n    if (isPlainObject(attrs)) {\n      res = Model.fromJSON(attrs);\n    }\n\n    if (res) {\n      if (res.focusKey == null) {\n        res = res.set('focusKey', res.rootTopicKey);\n      }\n\n      if (res.focusMode == null) {\n        res = res.set('focusMode', FocusMode.NORMAL);\n      }\n\n      return res;\n    }\n\n    throw new Error(`\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`);\n  }\n\n  static createEmpty() {\n    const model = new Model();\n    const rootTopic = Topic.create({\n      key: createKey(),\n      content: 'RootTopic'\n    });\n    return model.update('topics', topics => topics.set(rootTopic.key, rootTopic)).set('rootTopicKey', rootTopic.key).set('editorRootTopicKey', rootTopic.key).set('focusKey', rootTopic.key).set('focusMode', FocusMode.NORMAL);\n  }\n\n  static fromJSON(object) {\n    let model = new Model();\n    const {\n      topics = [],\n      config = {},\n      rootTopicKey\n    } = object;\n    let {\n      editorRootTopicKey\n    } = object;\n    if (editorRootTopicKey === undefined) editorRootTopicKey = rootTopicKey;\n    model = model.merge({\n      rootTopicKey,\n      editorRootTopicKey\n    });\n    model = model.withMutations(model => {\n      topics.forEach(topic => {\n        model.update('topics', topics => topics.set(topic.key, Topic.fromJSON(topic)));\n      });\n      model.set('config', Config.fromJSON(config));\n    });\n    return model;\n  }\n\n  toJS() {\n    const obj = {\n      rootTopicKey: this.rootTopicKey,\n      topics: Object.values(this.topics.toJS()),\n      config: this.config,\n      extData: this.extData,\n      zoomFactor: this.zoomFactor\n    };\n    return obj;\n  }\n\n  get extData() {\n    return this.get('extData');\n  }\n\n  get topics() {\n    return this.get('topics');\n  }\n\n  get config() {\n    return this.get('config');\n  }\n\n  get formatVersion() {\n    return this.get('formatVersion');\n  }\n\n  get rootTopicKey() {\n    return this.get('rootTopicKey');\n  }\n\n  get editorRootTopicKey() {\n    return this.get('editorRootTopicKey');\n  }\n\n  get focusKey() {\n    return this.get('focusKey');\n  }\n\n  get focusMode() {\n    return this.get('focusMode');\n  }\n\n  get editingContentKey() {\n    return this.focusMode === FocusMode.EDITING_CONTENT ? this.focusKey : null;\n  }\n\n  get editingDescKey() {\n    return this.focusMode === FocusMode.EDITING_DESC ? this.focusKey : null;\n  }\n\n  getTopic(key) {\n    return this.topics.get(key);\n  }\n\n  getExtDataItem(key, c) {\n    return this.extData.get(key) || new c();\n  }\n\n  getParentTopic(key) {\n    const topic = this.getTopic(key);\n    return topic.parentKey ? this.getTopic(topic.parentKey) : null;\n  }\n\n  getTopicVisualLevel(key) {\n    let topic = this.getTopic(key);\n    let level = 0;\n\n    while (topic && topic.key !== this.editorRootTopicKey) {\n      level++;\n      topic = this.getParentTopic(topic.key);\n    }\n\n    return level;\n  }\n\n  get rootTopic() {\n    return this.getTopic(this.rootTopicKey);\n  }\n\n  get zoomFactor() {\n    return this.get('zoomFactor');\n  }\n\n}\n\nfunction CorePlugin() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    plugins = []\n  } = options;\n  return [...plugins];\n}\n\nconst log$1 = debug('core:controller');\n\nfunction registerPlugin(controller, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(p => registerPlugin(controller, p));\n    return;\n  }\n\n  if (plugin == null) {\n    return;\n  }\n\n  for (const key in plugin) {\n    const fn = plugin[key];\n    controller.middleware[key] = controller.middleware[key] || [];\n    controller.middleware[key].push(fn);\n  }\n} // modified from koa-compose\n\n\nfunction compose(middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!');\n\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!');\n  }\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1;\n    return dispatch(0);\n\n    function dispatch(i) {\n      if (i <= index) throw new Error('next() called multiple times');\n      index = i;\n      let fn = middleware[i];\n      if (i === middleware.length) fn = next;\n      if (!fn) return null;\n\n      try {\n        return fn(context, dispatch.bind(null, i + 1));\n      } catch (err) {\n        throw err;\n      }\n    }\n  };\n}\n\nclass Controller {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      plugins = [],\n      onChange,\n      readOnly\n    } = options;\n    this.readOnly = readOnly;\n    this.onChange = onChange;\n    this.middleware = new Map();\n    const corePlugin = CorePlugin({\n      plugins\n    });\n    registerPlugin(this, corePlugin);\n  }\n\n  run(key) {\n    const {\n      middleware\n    } = this;\n    const fns = middleware[key] || [];\n    warning(fns.length !== 0, `the middleware function ${key} is not found!`);\n    const composedFn = memoizeOne(compose)(fns); // @ts-ignore\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return composedFn(...args);\n  }\n\n  getValue(propKey, arg) {\n    return this.run('getValue', { ...arg,\n      propKey\n    });\n  }\n\n  change(model, callback) {\n    this.onChange(model, callback);\n    this.currentModel = model;\n  }\n\n}\n\nexport { Block, BlockType, Config, Controller, DiagramLayoutType, FocusMode, Model, modifiers as ModelModifier, OpType, Topic, TopicDirection, TopicRelationship, TopicVisualLevel, createKey, defaultTheme, getAllSubTopicKeys, getKeyPath, getRelationship, isThemeType };","map":null,"metadata":{},"sourceType":"module"}