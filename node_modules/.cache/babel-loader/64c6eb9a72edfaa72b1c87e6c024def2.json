{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _options = require('./options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _validation = require('./validation');\n\nvar _changes = require('./changes');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Returns the core of the plugin, limited to the validation and normalization\n * part of `slate-edit-list`, and utils.\n *\n * Import this directly: `import EditListCore from 'slate-edit-table/lib/core'`\n * if you don't care about behavior/rendering and you\n * are only manipulating `Slate.Values` without rendering them.\n * That way you do not depend on importing `slate-react`.\n */\n\n\nfunction core() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  opts = new _options2.default(opts);\n  return {\n    schema: (0, _validation.schema)(opts),\n    normalizeNode: (0, _validation.normalizeNode)(opts),\n    utils: {\n      getCurrentItem: _utils.getCurrentItem.bind(null, opts),\n      getCurrentList: _utils.getCurrentList.bind(null, opts),\n      getItemDepth: _utils.getItemDepth.bind(null, opts),\n      getItemsAtRange: _utils.getItemsAtRange.bind(null, opts),\n      getPreviousItem: _utils.getPreviousItem.bind(null, opts),\n      isList: _utils.isList.bind(null, opts),\n      isSelectionInList: _utils.isSelectionInList.bind(null, opts)\n    },\n    changes: {\n      decreaseItemDepth: bindAndScopeChange(opts, _changes.decreaseItemDepth),\n      increaseItemDepth: bindAndScopeChange(opts, _changes.increaseItemDepth),\n      splitListItem: bindAndScopeChange(opts, _changes.splitListItem),\n      unwrapList: bindAndScopeChange(opts, _changes.unwrapList),\n      wrapInList: _changes.wrapInList.bind(null, opts),\n      toggleList: _changes.toggleList.bind(null, opts)\n    }\n  };\n}\n/**\n * Bind a change to given options, and scope it to act only inside a list\n */\n\n\nfunction bindAndScopeChange(opts, fn) {\n  return function (change) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var value = change.value;\n\n    if (!(0, _utils.isSelectionInList)(opts, value)) {\n      return change;\n    } // $FlowFixMe\n\n\n    return fn.apply(undefined, _toConsumableArray([opts, change].concat(args)));\n  };\n}\n\nexports.default = core;","map":null,"metadata":{},"sourceType":"script"}