{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _slateSchemaViolations = require('slate-schema-violations');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Create a schema definition with rules to normalize code blocks\n */\n\n\nfunction schema(opts) {\n  var _blocks;\n\n  var baseSchema = {\n    blocks: (_blocks = {}, _defineProperty(_blocks, opts.containerType, {\n      nodes: [{\n        match: {\n          type: opts.lineType\n        }\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code;\n\n        switch (code) {\n          case _slateSchemaViolations.CHILD_INVALID:\n          case _slateSchemaViolations.CHILD_TYPE_INVALID:\n            return onlyLine(opts, editor, error);\n\n          default:\n            return undefined;\n        }\n      }\n    }), _defineProperty(_blocks, opts.lineType, {\n      nodes: [{\n        match: {\n          object: 'text',\n          min: 1\n        }\n      }],\n      parent: {\n        type: opts.containerType\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code;\n\n        switch (code) {\n          // This constant does not exist yet in\n          // official Slate, but exists in GitBook's\n          // fork. Until the PR is merged, we accept both\n          // https://github.com/ianstormtaylor/slate/pull/1842\n          case _slateSchemaViolations.PARENT_INVALID:\n          case _slateSchemaViolations.PARENT_TYPE_INVALID:\n            return noOrphanLine(opts, editor, error);\n\n          case _slateSchemaViolations.CHILD_INVALID:\n          case _slateSchemaViolations.CHILD_OBJECT_INVALID:\n            return onlyTextInCode(opts, editor, error);\n\n          default:\n            return undefined;\n        }\n      }\n    }), _blocks)\n  };\n\n  if (!opts.allowMarks) {\n    baseSchema.blocks[opts.lineType].marks = [];\n  }\n\n  return baseSchema;\n}\n/**\n * Return a list of group of nodes matching the given filter.\n */\n\n\nfunction getSuccessiveNodes(nodes, match) {\n  var nonLines = nodes.takeUntil(match);\n  var afterNonLines = nodes.skip(nonLines.size);\n\n  if (afterNonLines.isEmpty()) {\n    return (0, _immutable.List)();\n  }\n\n  var firstGroup = afterNonLines.takeWhile(match);\n  var restOfNodes = afterNonLines.skip(firstGroup.size);\n  return (0, _immutable.List)([firstGroup]).concat(getSuccessiveNodes(restOfNodes, match));\n}\n/**\n * A rule that ensure code blocks only contain lines of code, and no marks\n */\n\n\nfunction onlyLine(opts, editor, error) {\n  var isNotLine = function isNotLine(n) {\n    return n.type !== opts.lineType;\n  };\n\n  var nonLineGroups = getSuccessiveNodes(error.node.nodes, isNotLine);\n  nonLineGroups.filter(function (group) {\n    return !group.isEmpty();\n  }).forEach(function (nonLineGroup) {\n    // Convert text to code lines\n    var text = nonLineGroup.map(function (n) {\n      return n.text;\n    }).join('');\n    var codeLines = (0, _utils.deserializeCode)(opts, text).nodes; // Insert them in place of the invalid node\n\n    var first = nonLineGroup.first();\n    var parent = editor.value.document.getParent(first.key);\n    var invalidNodeIndex = parent.nodes.indexOf(first);\n    editor.withoutNormalizing(function () {\n      codeLines.forEach(function (codeLine, index) {\n        editor.insertNodeByKey(parent.key, invalidNodeIndex + index, codeLine);\n      });\n    }); // Remove the block\n\n    editor.withoutNormalizing(function () {\n      nonLineGroup.forEach(function (n) {\n        return editor.removeNodeByKey(n.key);\n      });\n    });\n  });\n  return editor;\n}\n/**\n * A rule that ensure code lines only contain text\n */\n\n\nfunction onlyTextInCode(opts, editor, error) {\n  var node = error.node;\n\n  if (node.object === 'inline' || node.object === 'block') {\n    editor.withoutNormalizing(function () {\n      node.nodes.forEach(function (child) {\n        editor.unwrapNodeByKey(child.key);\n      });\n    });\n    return editor;\n  }\n\n  return undefined;\n}\n/**\n * A rule that ensure code lines are always children\n * of a code block.\n */\n\n\nfunction noOrphanLine(opts, editor, error) {\n  var parent = error.parent;\n\n  var isLine = function isLine(n) {\n    return n.type === opts.lineType;\n  };\n\n  var linesGroup = getSuccessiveNodes(parent.nodes, isLine);\n  linesGroup.forEach(function (group) {\n    var container = _slate.Block.create({\n      type: opts.containerType,\n      nodes: []\n    });\n\n    var firstLineIndex = parent.nodes.indexOf(group.first());\n    editor.withoutNormalizing(function () {\n      editor.insertNodeByKey(parent.key, firstLineIndex, container);\n      group.forEach(function (line, index) {\n        return editor.moveNodeByKey(line.key, container.key, index);\n      });\n    });\n  });\n}\n\nexports.default = schema;","map":null,"metadata":{},"sourceType":"script"}