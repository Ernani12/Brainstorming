{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _parser = require(\"./parser\");\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _slate = require(\"slate\");\n\nvar _immutable = require(\"immutable\");\n\nvar _urls = require(\"./urls\");\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar String = new _immutable.Record({\n  object: \"string\",\n  text: \"\"\n});\n/**\n * Rules to (de)serialize nodes.\n *\n * @type {Object}\n */\n\nvar tableHeader = \"\";\nvar firstRow = true;\nvar version = void 0;\nvar previousBlock = void 0;\nvar currentBlock = void 0;\nvar RULES = [{\n  serialize: function serialize(obj, children) {\n    if (obj.object === \"string\") {\n      return children;\n    }\n  }\n}, {\n  serialize: function serialize(obj, children, document) {\n    if (obj.object !== \"block\") return;\n    var parent = document.getParent(obj.key);\n\n    if (currentBlock) {\n      previousBlock = currentBlock;\n    }\n\n    currentBlock = {\n      obj: obj,\n      children: children\n    };\n\n    switch (obj.type) {\n      case \"table\":\n        tableHeader = \"\";\n        firstRow = true; // trim removes trailing newline\n\n        return children.trim();\n\n      case \"table-cell\":\n        {\n          switch (obj.getIn([\"data\", \"align\"])) {\n            case \"left\":\n              tableHeader += \"|:--- \";\n              break;\n\n            case \"center\":\n              tableHeader += \"|:---:\";\n              break;\n\n            case \"right\":\n              tableHeader += \"| ---:\";\n              break;\n\n            default:\n              tableHeader += \"| --- \";\n          }\n\n          return \"| \" + children + \" \";\n        }\n\n      case \"table-row\":\n        var output = \"\";\n\n        if (firstRow) {\n          output = tableHeader + \"|\\n\";\n          tableHeader = \"\";\n          firstRow = false;\n        }\n\n        return children + \"|\\n\" + output;\n\n      case \"paragraph\":\n        {\n          // version 2 outputs markdown compatible with rich-markdown-editor\n          // v10+ – it can be used to migrate documents between v9 -> v10\n          if (version === 2) {\n            if (children === \"\") {\n              if (!previousBlock || previousBlock.obj.type.startsWith(\"table\")) {\n                return \"\";\n              }\n\n              if (previousBlock && previousBlock.children === \"\" && previousBlock.obj.type === \"paragraph\") {\n                return \"\\\\\";\n              }\n\n              return \"\\n\\\\\";\n            }\n\n            return children;\n          }\n\n          return children;\n        }\n\n      case \"code\":\n        {\n          var language = obj.getIn([\"data\", \"language\"]) || \"\";\n          return \"```\" + language + \"\\n\" + children + \"\\n```\";\n        }\n\n      case \"code-line\":\n        return children + \"\\n\";\n\n      case \"block-quote\":\n        // Handle multi-line blockquotes\n        return children.split(\"\\n\").map(function (text) {\n          return \"> \" + text;\n        }).join(\"\\n\");\n\n      case \"todo-list\":\n      case \"bulleted-list\":\n      case \"ordered-list\":\n        {\n          // root list\n          if (parent === document) {\n            return children;\n          } // nested list\n\n\n          return \"\\n\" + children.replace(/\\n+$/gm, \"\").replace(/^/gm, \"   \");\n        }\n\n      case \"list-item\":\n        {\n          switch (parent.type) {\n            case \"ordered-list\":\n              return \"1. \" + children + \"\\n\";\n\n            case \"todo-list\":\n              var checked = obj.getIn([\"data\", \"checked\"]);\n              var box = checked ? \"[x]\" : \"[ ]\"; // version 2 outputs markdown compatible with rich-markdown-editor\n              // v10+ – it can be used to migrate documents between v9 -> v10\n\n              var prepend = version === 2 ? \"- \" : \"\";\n              return \"\" + prepend + box + \" \" + children + \"\\n\";\n\n            default:\n            case \"bulleted-list\":\n              return \"* \" + children + \"\\n\";\n          }\n        }\n\n      case \"heading1\":\n        return \"# \" + children + \"\\n\";\n\n      case \"heading2\":\n        return \"\\n## \" + children + \"\\n\";\n\n      case \"heading3\":\n        return \"\\n### \" + children + \"\\n\";\n\n      case \"heading4\":\n        return \"\\n#### \" + children + \"\\n\";\n\n      case \"heading5\":\n        return \"\\n##### \" + children + \"\\n\";\n\n      case \"heading6\":\n        return \"\\n###### \" + children + \"\\n\";\n\n      case \"horizontal-rule\":\n        return \"---\";\n\n      case \"image\":\n        var alt = obj.getIn([\"data\", \"alt\"]) || \"\";\n        var src = (0, _urls.encode)(obj.getIn([\"data\", \"src\"]) || \"\");\n        return \"![\" + alt + \"](\" + src + \")\";\n    }\n  }\n}, {\n  serialize: function serialize(obj, children) {\n    if (obj.type === \"hashtag\") return children;\n  }\n}, {\n  serialize: function serialize(obj, children) {\n    if (obj.type === \"link\") {\n      var href = (0, _urls.encode)(obj.getIn([\"data\", \"href\"]) || \"\");\n      var text = children.trim() || href;\n      return href ? \"[\" + text + \"](\" + href + \")\" : text;\n    }\n  }\n}, {\n  serialize: function serialize(obj, children) {\n    if (obj.object !== \"mark\") return;\n    if (!children) return; // version 2 outputs markdown compatible with rich-markdown-editor\n    // v10+ – it can be used to migrate documents between v9 -> v10\n    // trailing spaces must be stripped from marks\n\n    if (version === 2) {\n      var match = children.match(/\\s+$/);\n      var spacesBefore = children.search(/\\S|$/);\n      var spacesAfter = match ? match[0].length : 0;\n      var sB = Array(spacesBefore + 1).join(\" \");\n      var sA = Array(spacesAfter + 1).join(\" \");\n      var content = children.trim();\n\n      switch (obj.type) {\n        case \"bold\":\n          return sB + \"**\" + content + \"**\" + sA;\n\n        case \"italic\":\n          return sB + \"_\" + content + \"_\" + sA;\n\n        case \"code\":\n          return sB + \"`\" + content + \"`\" + sA;\n\n        case \"inserted\":\n          return sB + \"++\" + content + \"++\" + sA;\n\n        case \"deleted\":\n          return sB + \"~~\" + content + \"~~\" + sA;\n\n        case \"underlined\":\n          return sB + \"__\" + content + \"__\" + sA;\n      }\n\n      return;\n    }\n\n    switch (obj.type) {\n      case \"bold\":\n        return \"**\" + children + \"**\";\n\n      case \"italic\":\n        return \"_\" + children + \"_\";\n\n      case \"code\":\n        return \"`\" + children + \"`\";\n\n      case \"inserted\":\n        return \"++\" + children + \"++\";\n\n      case \"deleted\":\n        return \"~~\" + children + \"~~\";\n\n      case \"underlined\":\n        return \"__\" + children + \"__\";\n    }\n  }\n}];\n/**\n * Markdown serializer.\n *\n * @type {Markdown}\n */\n\nvar Markdown = function () {\n  /**\n   * Create a new serializer with `rules`.\n   *\n   * @param {Object} options\n   * @property {Array} rules\n   * @return {Markdown} serializer\n   */\n  function Markdown() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Markdown);\n\n    this.rules = [].concat(_toConsumableArray(options.rules || []), RULES);\n    this.serializeNode = this.serializeNode.bind(this);\n    this.serializeLeaves = this.serializeLeaves.bind(this);\n    this.serializeString = this.serializeString.bind(this);\n  }\n  /**\n   * Serialize a `state` object into an HTML string.\n   *\n   * @param {State} state\n   * @param {Object} options\n   * @return {String} markdown\n   */\n\n\n  _createClass(Markdown, [{\n    key: \"serialize\",\n    value: function serialize(state) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // reset state in module context\n\n      version = options.version || 1;\n      currentBlock = undefined;\n      previousBlock = undefined;\n      var document = state.document;\n      var elements = document.nodes.map(function (node) {\n        return _this.serializeNode(node, document);\n      });\n      var output = elements.join(\"\\n\"); // trim beginning whitespace\n\n      output = output.replace(/^\\s+/g, \"\"); // fix marks adjacent to marks. This is a quirk in the old editor where a\n      // mark crossing \\ character boundaries would be stopped and started\n      // again. The v2 editor respects Markdown standard and does not interpret\n      // these as a mark followed by another mark, and so they must be stripped.\n\n      if (version === 2) {\n        return output.replace(/\\*\\*\\*\\*/g, \"\").replace(/\\+\\+\\+\\+/g, \"\").replace(/~~~~/g, \"\").replace(/____/g, \"\").replace(/``\\\\/g, \"\\\\\").replace(/__\\\\/g, \"\\\\\");\n      }\n\n      return output;\n    }\n    /**\n     * Serialize a `node`.\n     *\n     * @param {Node} node\n     * @return {String}\n     */\n\n  }, {\n    key: \"serializeNode\",\n    value: function serializeNode(node, document) {\n      var _this2 = this;\n\n      if (node.object == \"text\") {\n        var leaves = node.getLeaves();\n        var inCodeBlock = !!document.getClosest(node.key, function (n) {\n          return n.type === \"code\";\n        });\n        return leaves.map(function (leave) {\n          var inCodeMark = !!leave.marks.filter(function (mark) {\n            return mark.type === \"code\";\n          }).size;\n          return _this2.serializeLeaves(leave, !inCodeBlock && !inCodeMark);\n        });\n      }\n\n      var children = node.nodes.map(function (childNode) {\n        var serialized = _this2.serializeNode(childNode, document);\n\n        return (serialized && serialized.join ? serialized.join(\"\") : serialized) || \"\";\n      }).join( // Special case for blockquotes, children in blockquotes are separated by new lines\n      node.type === \"block-quote\" ? \"\\n\" : \"\");\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var rule = _step.value;\n          if (!rule.serialize) continue;\n          var ret = rule.serialize(node, children, document);\n          if (ret) return ret;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Serialize `leaves`.\n     *\n     * @param {Leave[]} leaves\n     * @return {String}\n     */\n\n  }, {\n    key: \"serializeLeaves\",\n    value: function serializeLeaves(leaves) {\n      var _this3 = this;\n\n      var escape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var leavesText = leaves.text;\n\n      if (escape) {\n        // escape markdown characters\n        leavesText = (0, _utils.escapeMarkdownChars)(leavesText);\n      }\n\n      var string = new String({\n        text: leavesText\n      });\n      var text = this.serializeString(string);\n      return leaves.marks.reduce(function (children, mark) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = _this3.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var rule = _step2.value;\n            if (!rule.serialize) continue;\n            var ret = rule.serialize(mark, children);\n            if (ret) return ret;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }, text);\n    }\n    /**\n     * Serialize a `string`.\n     *\n     * @param {String} string\n     * @return {String}\n     */\n\n  }, {\n    key: \"serializeString\",\n    value: function serializeString(string) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var rule = _step3.value;\n          if (!rule.serialize) continue;\n          var ret = rule.serialize(string, string.text);\n          if (ret) return ret;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Deserialize a markdown `string`.\n     *\n     * @param {String} markdown\n     * @return {State} state\n     */\n\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(markdown) {\n      var document = _parser2.default.parse(markdown);\n\n      return _slate.Value.fromJSON({\n        document: document\n      });\n    }\n  }]);\n\n  return Markdown;\n}();\n\nexports.default = Markdown;","map":null,"metadata":{},"sourceType":"script"}