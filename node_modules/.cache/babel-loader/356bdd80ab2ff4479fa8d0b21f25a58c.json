{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar le5le_store_1 = require(\"le5le-store\");\n\nvar options_1 = require(\"./options\");\n\nvar node_1 = require(\"./models/node\");\n\nvar point_1 = require(\"./models/point\");\n\nvar line_1 = require(\"./models/line\");\n\nvar data_1 = require(\"./models/data\");\n\nvar status_1 = require(\"./models/status\");\n\nvar index_1 = require(\"./middles/index\");\n\nvar offscreen_1 = require(\"./offscreen\");\n\nvar renderLayer_1 = require(\"./renderLayer\");\n\nvar hoverLayer_1 = require(\"./hoverLayer\");\n\nvar activeLayer_1 = require(\"./activeLayer\");\n\nvar animateLayer_1 = require(\"./animateLayer\");\n\nvar divLayer_1 = require(\"./divLayer\");\n\nvar rect_1 = require(\"./models/rect\");\n\nvar uuid_1 = require(\"./uuid/uuid\");\n\nvar curve_1 = require(\"./middles/lines/curve\");\n\nvar utils_1 = require(\"./utils\");\n\nvar resizeCursors = ['nw-resize', 'ne-resize', 'se-resize', 'sw-resize'];\nvar MoveInType;\n\n(function (MoveInType) {\n  MoveInType[MoveInType[\"None\"] = 0] = \"None\";\n  MoveInType[MoveInType[\"Line\"] = 1] = \"Line\";\n  MoveInType[MoveInType[\"LineMove\"] = 2] = \"LineMove\";\n  MoveInType[MoveInType[\"LineFrom\"] = 3] = \"LineFrom\";\n  MoveInType[MoveInType[\"LineTo\"] = 4] = \"LineTo\";\n  MoveInType[MoveInType[\"LineControlPoint\"] = 5] = \"LineControlPoint\";\n  MoveInType[MoveInType[\"Nodes\"] = 6] = \"Nodes\";\n  MoveInType[MoveInType[\"ResizeCP\"] = 7] = \"ResizeCP\";\n  MoveInType[MoveInType[\"HoverAnchors\"] = 8] = \"HoverAnchors\";\n  MoveInType[MoveInType[\"Rotate\"] = 9] = \"Rotate\";\n})(MoveInType || (MoveInType = {}));\n\nvar dockOffset = 10;\n\nvar Topology =\n/** @class */\nfunction () {\n  function Topology(parent, options) {\n    var _this = this;\n\n    this.data = new data_1.TopologyData();\n    this.caches = {\n      index: 0,\n      list: []\n    };\n    this.input = document.createElement('textarea');\n    this.lastTranlated = {\n      x: 0,\n      y: 0\n    };\n    this.moveIn = {\n      type: MoveInType.None,\n      activeAnchorIndex: 0,\n      hoverAnchorIndex: 0,\n      hoverNode: null,\n      hoverLine: null,\n      lineControlPoint: null\n    };\n    this.needCache = false;\n    this.tip = '';\n    this.scheduledAnimationFrame = false;\n    this.scrolling = false;\n\n    this.onMouseMove = function (e) {\n      if (_this.scheduledAnimationFrame || _this.data.locked === status_1.Lock.NoEvent) {\n        return;\n      }\n\n      if (_this.mouseDown && _this.moveIn.type === MoveInType.None) {\n        var b = false;\n\n        switch (_this.options.translateKey) {\n          case options_1.KeyType.None:\n            b = true;\n            break;\n\n          case options_1.KeyType.Ctrl:\n            if (e.ctrlKey) {\n              b = true;\n            }\n\n            break;\n\n          case options_1.KeyType.Shift:\n            if (e.shiftKey) {\n              b = true;\n            }\n\n            break;\n\n          case options_1.KeyType.Alt:\n            if (e.altKey) {\n              b = true;\n            }\n\n            break;\n\n          default:\n            if (e.ctrlKey || e.altKey) {\n              b = true;\n            }\n\n        }\n\n        if (b) {\n          _this.translate(e.offsetX - _this.mouseDown.x, e.offsetY - _this.mouseDown.y, true);\n\n          return false;\n        }\n      }\n\n      if (_this.data.locked && _this.mouseDown && _this.moveIn.type !== MoveInType.None) {\n        return;\n      }\n\n      _this.scheduledAnimationFrame = true;\n      var pos = new point_1.Point(e.offsetX, e.offsetY);\n      requestAnimationFrame(function () {\n        _this.scheduledAnimationFrame = false;\n\n        if (!_this.mouseDown) {\n          _this.getMoveIn(pos); // Render hover anchors.\n\n\n          if (_this.moveIn.hoverNode !== _this.lastHoverNode) {\n            if (_this.lastHoverNode) {\n              // Send a move event.\n              if (_this.options.on) {\n                _this.options.on('moveOutNode', _this.lastHoverNode);\n              }\n\n              _this.hideTip(); // Clear hover anchors.\n\n\n              _this.hoverLayer.node = null;\n            }\n\n            if (_this.moveIn.hoverNode) {\n              _this.hoverLayer.node = _this.moveIn.hoverNode; // Send a move event.\n\n              if (_this.options.on) {\n                _this.options.on('moveInNode', _this.moveIn.hoverNode);\n              }\n\n              _this.showTip(_this.moveIn.hoverNode, pos);\n            }\n          }\n\n          if (_this.moveIn.hoverLine !== _this.lastHoverLine) {\n            if (_this.lastHoverLine) {\n              if (_this.options.on) {\n                _this.options.on('moveOutLine', _this.lastHoverLine);\n              }\n\n              _this.hideTip();\n            }\n\n            if (_this.moveIn.hoverLine) {\n              if (_this.options.on) {\n                _this.options.on('moveInLine', _this.moveIn.hoverLine);\n              }\n\n              _this.showTip(_this.moveIn.hoverLine, pos);\n            }\n          }\n\n          if (_this.moveIn.type === MoveInType.LineControlPoint) {\n            _this.hoverLayer.hoverLineCP = _this.moveIn.lineControlPoint;\n          } else if (_this.hoverLayer.hoverLineCP) {\n            _this.hoverLayer.hoverLineCP = null;\n          }\n\n          if (_this.moveIn.hoverNode !== _this.lastHoverNode || _this.moveIn.type === MoveInType.HoverAnchors || _this.hoverLayer.lasthoverLineCP !== _this.hoverLayer.hoverLineCP) {\n            _this.hoverLayer.lasthoverLineCP = _this.hoverLayer.hoverLineCP;\n\n            _this.render();\n          }\n\n          return;\n        } // Move out parent element.\n\n\n        var moveOutX = pos.x + 50 > _this.parentElem.clientWidth + _this.parentElem.scrollLeft;\n        var moveOutY = pos.y + 50 > _this.parentElem.clientHeight + _this.parentElem.scrollTop;\n\n        if (moveOutX || moveOutY) {\n          if (_this.options.on) {\n            _this.options.on('moveOutParent', pos);\n          }\n\n          var resize = false;\n\n          if (pos.x + 50 > _this.divLayer.canvas.clientWidth) {\n            _this.canvas.width += 200;\n            resize = true;\n          }\n\n          if (pos.y + 50 > _this.divLayer.canvas.clientHeight) {\n            _this.canvas.height += 200;\n            resize = true;\n          }\n\n          if (resize) {\n            _this.resize({\n              width: _this.canvas.width,\n              height: _this.canvas.height\n            });\n          }\n\n          _this.scroll(moveOutX ? 100 : 0, moveOutY ? 100 : 0);\n        }\n\n        var moveLeft = pos.x - 100 < _this.parentElem.scrollLeft;\n        var moveTop = pos.y - 100 < _this.parentElem.scrollTop;\n\n        if (moveLeft || moveTop) {\n          _this.scroll(moveLeft ? -100 : 0, moveTop ? -100 : 0);\n        }\n\n        switch (_this.moveIn.type) {\n          case MoveInType.None:\n            _this.hoverLayer.dragRect = new rect_1.Rect(_this.mouseDown.x, _this.mouseDown.y, pos.x - _this.mouseDown.x, pos.y - _this.mouseDown.y);\n            break;\n\n          case MoveInType.Nodes:\n            if (_this.activeLayer.locked()) {\n              break;\n            }\n\n            var x = pos.x - _this.mouseDown.x;\n            var y = pos.y - _this.mouseDown.y;\n\n            if (x || y) {\n              var offset = _this.getDockPos(x, y);\n\n              _this.activeLayer.moveNodes(offset.x ? offset.x : x, offset.y ? offset.y : y);\n\n              _this.animateLayer.start(true);\n\n              _this.needCache = true;\n            }\n\n            break;\n\n          case MoveInType.ResizeCP:\n            _this.activeLayer.resizeNodes(_this.moveIn.activeAnchorIndex, _this.mouseDown, pos);\n\n            _this.animateLayer.start(true);\n\n            if (_this.options.on) {\n              _this.options.on('resizeNodes', _this.activeLayer.nodes);\n            }\n\n            _this.needCache = true;\n            break;\n\n          case MoveInType.LineTo:\n          case MoveInType.HoverAnchors:\n            var arrow = _this.data.toArrowType;\n\n            if (_this.moveIn.hoverLine) {\n              arrow = _this.moveIn.hoverLine.toArrow;\n            }\n\n            if (!_this.activeLayer.lines.length && _this.hoverLayer.line) {\n              _this.activeLayer.lines = [_this.hoverLayer.line];\n            }\n\n            _this.hoverLayer.lineTo(_this.getLineDock(pos), arrow);\n\n            _this.animateLayer.start(true);\n\n            _this.needCache = true;\n            break;\n\n          case MoveInType.LineFrom:\n            _this.hoverLayer.lineFrom(_this.getLineDock(pos));\n\n            _this.needCache = true;\n            break;\n\n          case MoveInType.LineMove:\n            _this.hoverLayer.lineMove(pos, _this.mouseDown);\n\n            _this.animateLayer.start(true);\n\n            _this.needCache = true;\n            break;\n\n          case MoveInType.LineControlPoint:\n            _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].x = pos.x;\n            _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].y = pos.y;\n            _this.moveIn.hoverLine.textRect = null;\n\n            if (index_1.drawLineFns[_this.moveIn.hoverLine.name] && index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn) {\n              index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn(_this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id], _this.moveIn.hoverLine);\n            }\n\n            _this.animateLayer.start(true);\n\n            _this.needCache = true;\n            break;\n\n          case MoveInType.Rotate:\n            if (_this.activeLayer.nodes.length) {\n              _this.activeLayer.offsetRotate(_this.getAngle(pos));\n\n              _this.activeLayer.updateLines();\n            }\n\n            _this.animateLayer.start(true);\n\n            _this.needCache = true;\n            break;\n        }\n\n        _this.render();\n      });\n    };\n\n    this.onmousedown = function (e) {\n      if (e.button) {\n        return;\n      }\n\n      _this.mouseDown = {\n        x: e.offsetX,\n        y: e.offsetY\n      };\n\n      if (e.altKey) {\n        _this.divLayer.canvas.style.cursor = 'move';\n      }\n\n      if (_this.inputObj) {\n        _this.setNodeText();\n      }\n\n      switch (_this.moveIn.type) {\n        // Click the space.\n        case MoveInType.None:\n          _this.activeLayer.clear();\n\n          _this.hoverLayer.clear();\n\n          if (_this.options.on) {\n            _this.options.on('space', null);\n          }\n\n          break;\n        // Click a line.\n\n        case MoveInType.Line:\n        case MoveInType.LineControlPoint:\n          if (e.ctrlKey) {\n            _this.activeLayer.addLine(_this.moveIn.hoverLine);\n\n            if (_this.options.on) {\n              if (_this.data.lines.length > 1 || _this.data.nodes.length) {\n                _this.options.on('multi', {\n                  nodes: _this.activeLayer.nodes,\n                  lines: _this.activeLayer.lines\n                });\n              } else {\n                _this.options.on('line', _this.moveIn.hoverLine);\n              }\n            }\n          } else {\n            _this.activeLayer.nodes = [];\n            _this.activeLayer.lines = [_this.moveIn.hoverLine];\n\n            if (_this.options.on) {\n              _this.options.on('line', _this.moveIn.hoverLine);\n            }\n\n            _this.link(_this.moveIn.hoverLine);\n          }\n\n          break;\n\n        case MoveInType.LineMove:\n          _this.hoverLayer.initLine = new line_1.Line(_this.moveIn.hoverLine);\n        // tslint:disable-next-line:no-switch-case-fall-through\n\n        case MoveInType.LineFrom:\n        case MoveInType.LineTo:\n          _this.activeLayer.nodes = [];\n          _this.activeLayer.lines = [_this.moveIn.hoverLine];\n\n          if (_this.options.on) {\n            _this.options.on('line', _this.moveIn.hoverLine);\n          }\n\n          _this.hoverLayer.line = _this.moveIn.hoverLine;\n          break;\n\n        case MoveInType.HoverAnchors:\n          _this.hoverLayer.setLine(new point_1.Point(_this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].x, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].y, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].direction, _this.moveIn.hoverAnchorIndex, _this.moveIn.hoverNode.id), _this.data.fromArrowType, _this.data.lineName);\n\n        // tslint:disable-next-line:no-switch-case-fall-through\n\n        case MoveInType.Nodes:\n          if (!e.ctrlKey) {\n            _this.link(_this.moveIn.hoverNode);\n          }\n\n          if (!_this.moveIn.hoverNode) {\n            break;\n          }\n\n          if (e.ctrlKey) {\n            if (_this.activeLayer.hasNode(_this.moveIn.hoverNode)) {\n              break;\n            }\n\n            _this.activeLayer.addNode(_this.moveIn.hoverNode);\n\n            if (_this.options.on) {\n              if (_this.activeLayer.nodes.length > 1 || _this.activeLayer.lines.length) {\n                _this.options.on('multi', {\n                  nodes: _this.activeLayer.nodes,\n                  lines: _this.activeLayer.lines\n                });\n              } else {\n                _this.options.on('node', _this.moveIn.hoverNode);\n              }\n            }\n          } else {\n            _this.activeLayer.setNodes([_this.moveIn.hoverNode]);\n\n            if (_this.options.on) {\n              _this.options.on('node', _this.moveIn.hoverNode);\n            }\n          }\n\n          break;\n      } // Save node rects to move.\n\n\n      if (_this.activeLayer.nodes.length) {\n        _this.activeLayer.saveNodeRects();\n      }\n\n      _this.render();\n    };\n\n    this.onmouseup = function (e) {\n      _this.mouseDown = null;\n      _this.lastTranlated.x = 0;\n      _this.lastTranlated.y = 0;\n      _this.hoverLayer.dockAnchor = null;\n      _this.hoverLayer.dockLineX = 0;\n      _this.hoverLayer.dockLineY = 0;\n      _this.divLayer.canvas.style.cursor = 'default';\n\n      if (_this.hoverLayer.dragRect) {\n        _this.getRectNodes(_this.data.nodes, _this.hoverLayer.dragRect);\n\n        _this.getRectLines(_this.data.lines, _this.hoverLayer.dragRect);\n\n        if (_this.options.on && _this.activeLayer.nodes && _this.activeLayer.nodes.length) {\n          _this.options.on('multi', {\n            nodes: _this.activeLayer.nodes,\n            lines: _this.activeLayer.lines\n          });\n        }\n      } else {\n        switch (_this.moveIn.type) {\n          // Add the line.\n          case MoveInType.HoverAnchors:\n            // New active.\n            if (_this.hoverLayer.line && _this.hoverLayer.line.to) {\n              _this.data.lines.push(_this.hoverLayer.line); // Deactive nodes.\n\n\n              _this.activeLayer.nodes = [];\n\n              if (_this.hoverLayer.line.to.id || !_this.options.disableEmptyLine) {\n                _this.activeLayer.lines = [_this.hoverLayer.line];\n\n                if (_this.options.on) {\n                  _this.options.on('addLine', _this.hoverLayer.line);\n                }\n              } else {\n                _this.data.lines.pop();\n              }\n            }\n\n            _this.offscreen.render();\n\n            _this.hoverLayer.line = null;\n            break;\n\n          case MoveInType.Rotate:\n            _this.activeLayer.updateRotate();\n\n            break;\n\n          case MoveInType.LineControlPoint:\n            le5le_store_1.Store.set('pts-' + _this.moveIn.hoverLine.id, null);\n            break;\n        }\n      }\n\n      _this.hoverLayer.dragRect = null;\n\n      _this.render();\n\n      if (_this.needCache) {\n        _this.cache();\n      }\n\n      _this.needCache = false;\n    };\n\n    this.ondblclick = function (e) {\n      if (_this.moveIn.hoverNode) {\n        if (_this.options.on) {\n          _this.options.on('dblclick', {\n            node: _this.moveIn.hoverNode\n          });\n        }\n\n        if (_this.moveIn.hoverNode.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {\n          _this.showInput(_this.moveIn.hoverNode);\n        }\n      } else if (_this.moveIn.hoverLine) {\n        if (_this.options.on) {\n          _this.options.on('dblclick', {\n            line: _this.moveIn.hoverLine\n          });\n        }\n\n        if (!_this.moveIn.hoverLine.text || _this.moveIn.hoverLine.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {\n          _this.showInput(_this.moveIn.hoverLine);\n        }\n      }\n    };\n\n    this.onkeydown = function (key) {\n      if (_this.data.locked) {\n        return;\n      }\n\n      key.preventDefault();\n      var done = false;\n      var moveX = 0;\n      var moveY = 0;\n\n      switch (key.keyCode) {\n        // Delete\n        case 8:\n        case 46:\n          if (!_this.activeLayer.nodes.length && !_this.activeLayer.lines.length) {\n            return;\n          }\n\n          _this.delete();\n\n          break;\n        // Left\n\n        case 37:\n          moveX = -5;\n\n          if (key.ctrlKey) {\n            moveX = -1;\n          }\n\n          done = true;\n          break;\n        // Top\n\n        case 38:\n          moveY = -5;\n\n          if (key.ctrlKey) {\n            moveY = -1;\n          }\n\n          done = true;\n          break;\n        // Right\n\n        case 39:\n          moveX = 5;\n\n          if (key.ctrlKey) {\n            moveX = 1;\n          }\n\n          done = true;\n          break;\n        // Down\n\n        case 40:\n          moveY = 5;\n\n          if (key.ctrlKey) {\n            moveY = 1;\n          }\n\n          done = true;\n          break;\n      }\n\n      if (!done) {\n        return;\n      }\n\n      if (moveX || moveY) {\n        _this.activeLayer.saveNodeRects();\n\n        _this.activeLayer.moveNodes(moveX, moveY);\n\n        _this.overflow();\n\n        _this.animateLayer.start(true);\n      }\n\n      _this.render();\n\n      _this.cache();\n    };\n\n    le5le_store_1.Store.set('topology-data', this.data);\n    this.options = options || {};\n\n    if (!this.options.font) {\n      this.options.font = {\n        color: '#222',\n        fontFamily: '\"Hiragino Sans GB\", \"Microsoft YaHei\", \"Helvetica Neue\", Helvetica, Arial',\n        fontSize: 12,\n        lineHeight: 1.5,\n        textAlign: 'center',\n        textBaseline: 'middle'\n      };\n    }\n\n    if (!this.options.color) {\n      this.options.color = '#222';\n    }\n\n    if (!this.options.rotateCursor) {\n      this.options.rotateCursor = '/assets/img/rotate.cur';\n    }\n\n    if (!this.options.font.fontFamily) {\n      this.options.font.fontFamily = '\"Hiragino Sans GB\", \"Microsoft YaHei\", \"Helvetica Neue\", Helvetica, Arial';\n    }\n\n    if (!this.options.font.color) {\n      this.options.font.color = '#222';\n    }\n\n    if (!this.options.font.fontSize) {\n      // px\n      this.options.font.fontSize = 12;\n    }\n\n    if (!this.options.font.lineHeight) {\n      // number\n      this.options.font.lineHeight = 1.5;\n    }\n\n    if (!this.options.font.textAlign) {\n      this.options.font.textAlign = 'center';\n    }\n\n    if (!this.options.font.textBaseline) {\n      this.options.font.textBaseline = 'middle';\n    }\n\n    if (typeof parent === 'string') {\n      this.parentElem = document.getElementById(parent);\n    } else {\n      this.parentElem = parent;\n    }\n\n    this.parentElem.style.position = 'relative';\n    this.activeLayer = new activeLayer_1.ActiveLayer(this.options);\n    this.hoverLayer = new hoverLayer_1.HoverLayer(this.options);\n    this.animateLayer = new animateLayer_1.AnimateLayer(this.options);\n    this.offscreen = new offscreen_1.Offscreen(this.parentElem, this.options);\n    this.canvas = new renderLayer_1.RenderLayer(this.parentElem, this.options);\n    this.divLayer = new divLayer_1.DivLayer(this.parentElem, this.options);\n    this.resize();\n\n    this.divLayer.canvas.ondragover = function (event) {\n      return event.preventDefault();\n    };\n\n    this.divLayer.canvas.ondrop = function (event) {\n      _this.ondrop(event);\n    };\n\n    this.subcribe = le5le_store_1.Store.subscribe('LT:render', function () {\n      _this.render();\n    });\n    this.subcribeImage = le5le_store_1.Store.subscribe('LT:imageLoaded', function () {\n      if (_this.imageTimer) {\n        clearTimeout(_this.imageTimer);\n      }\n\n      _this.imageTimer = setTimeout(function () {\n        _this.render();\n      }, 100);\n    });\n    this.subcribeAnimateMoved = le5le_store_1.Store.subscribe('nodeRectChanged', function (e) {\n      _this.activeLayer.updateLines(_this.data.nodes);\n\n      _this.animateLayer.updateLines(_this.data.nodes);\n    });\n    this.subcribeMediaEnd = le5le_store_1.Store.subscribe('mediaEnd', function (node) {\n      if (node.nextPlay) {\n        _this.animateLayer.getNodes(_this.data.nodes, node.nextPlay);\n\n        _this.animateLayer.getLines(node.nextPlay);\n\n        _this.animateLayer.animate();\n      }\n\n      if (_this.options.on) {\n        _this.options.on('mediaEnd', node);\n      }\n    });\n    this.subcribeAnimateEnd = le5le_store_1.Store.subscribe('animateEnd', function (e) {\n      if (!e) {\n        return;\n      }\n\n      switch (e.type) {\n        case 'node':\n          _this.offscreen.render();\n\n          break;\n      }\n\n      _this.divLayer.playNext(e.data.nextAnimate);\n\n      if (_this.options.on) {\n        _this.options.on('animateEnd', e);\n      }\n    });\n    this.divLayer.canvas.onmousemove = this.onMouseMove;\n    this.divLayer.canvas.onmousedown = this.onmousedown;\n    this.divLayer.canvas.onmouseup = this.onmouseup;\n    this.divLayer.canvas.ondblclick = this.ondblclick;\n    this.divLayer.canvas.tabIndex = 0;\n    this.divLayer.canvas.onkeydown = this.onkeydown;\n\n    this.divLayer.canvas.onblur = function () {\n      _this.mouseDown = null;\n    };\n\n    this.divLayer.canvas.onwheel = function (event) {\n      if (_this.options.disableScale) {\n        return;\n      }\n\n      switch (_this.options.scaleKey) {\n        case options_1.KeyType.None:\n          break;\n\n        case options_1.KeyType.Ctrl:\n          if (!event.ctrlKey) {\n            return;\n          }\n\n          break;\n\n        case options_1.KeyType.Shift:\n          if (!event.shiftKey) {\n            return;\n          }\n\n          break;\n\n        case options_1.KeyType.Alt:\n          if (!event.altKey) {\n            return;\n          }\n\n          break;\n\n        default:\n          if (!event.ctrlKey && !event.altKey) {\n            return;\n          }\n\n      }\n\n      event.preventDefault();\n\n      if (event.deltaY < 0) {\n        _this.scale(1.1);\n      } else {\n        _this.scale(0.9);\n      }\n\n      _this.divLayer.canvas.focus();\n\n      return false;\n    };\n\n    this.divLayer.canvas.ontouchend = function (event) {\n      _this.ontouched(event);\n    };\n\n    this.input.style.position = 'absolute';\n    this.input.style.zIndex = '-1';\n    this.input.style.left = '-1000px';\n    this.input.style.width = '0';\n    this.input.style.height = '0';\n    this.input.style.outline = 'none';\n    this.input.style.border = '1px solid #cdcdcd';\n    this.input.style.resize = 'none';\n    this.parentElem.appendChild(this.input);\n    this.createMarkdownTip();\n    this.cache();\n  }\n\n  Topology.prototype.resize = function (size) {\n    this.canvas.resize(size);\n    this.offscreen.resize(size);\n    this.divLayer.resize(size);\n    this.render();\n\n    if (this.options.on) {\n      this.options.on('resize', size);\n    }\n  };\n\n  Topology.prototype.ondrop = function (event) {\n    event.preventDefault();\n    var json = JSON.parse(event.dataTransfer.getData('Text'));\n    json.rect.x = event.offsetX - json.rect.width / 2 << 0;\n    json.rect.y = event.offsetY - json.rect.height / 2 << 0;\n    var node = new node_1.Node(json);\n    this.addNode(node, true);\n\n    if (node.name === 'div') {\n      if (this.options.on) {\n        this.options.on('LT:addDiv', node);\n      }\n    }\n\n    this.divLayer.canvas.focus();\n  };\n\n  Topology.prototype.getTouchOffset = function (touch) {\n    var currentTarget = this.parentElem;\n    var x = 0;\n    var y = 0;\n\n    while (currentTarget) {\n      x += currentTarget.offsetLeft;\n      y += currentTarget.offsetTop;\n      currentTarget = currentTarget.offsetParent;\n    }\n\n    return {\n      offsetX: touch.pageX - x,\n      offsetY: touch.pageY - y\n    };\n  };\n\n  Topology.prototype.ontouched = function (event) {\n    if (!this.touchedNode) {\n      return;\n    }\n\n    var pos = this.getTouchOffset(event.changedTouches[0]);\n    this.touchedNode.rect.x = pos.offsetX - this.touchedNode.rect.width / 2;\n    this.touchedNode.rect.y = pos.offsetY - this.touchedNode.rect.height / 2;\n    this.addNode(new node_1.Node(this.touchedNode), true);\n    this.touchedNode = undefined;\n  };\n\n  Topology.prototype.addNode = function (node, focus) {\n    if (focus === void 0) {\n      focus = false;\n    }\n\n    if (this.data.locked || !index_1.drawNodeFns[node.name]) {\n      return false;\n    } // if it's not a Node\n\n\n    if (!node.init) {\n      node = new node_1.Node(node);\n    }\n\n    if (!node.strokeStyle && this.options.color) {\n      node.strokeStyle = this.options.color;\n    }\n\n    if (!node.font.color) {\n      node.font = Object.assign(node.font, this.options.font);\n    }\n\n    if (this.data.scale !== 1) {\n      node.scale(this.data.scale);\n    }\n\n    this.data.nodes.push(node); // New active.\n\n    if (focus) {\n      this.activeLayer.setNodes([node]);\n    }\n\n    this.render();\n    this.cache();\n\n    if (this.options.on) {\n      this.options.on('addNode', node);\n    }\n\n    return true;\n  };\n\n  Topology.prototype.addLine = function (line, focus) {\n    if (focus === void 0) {\n      focus = false;\n    }\n\n    if (this.data.locked) {\n      return false;\n    } // New active.\n\n\n    if (focus) {\n      this.activeLayer.setLines([line]);\n    }\n\n    this.data.lines.push(line);\n    this.offscreen.render();\n    this.cache();\n\n    if (this.options.on) {\n      this.options.on('addLine', line);\n    }\n  };\n\n  Topology.prototype.addLineByPt = function (name, from, fromArrow, to, toArrow, focus) {\n    if (focus === void 0) {\n      focus = false;\n    }\n\n    var line = new line_1.Line({\n      name: name,\n      from: from,\n      fromArrow: fromArrow,\n      to: to,\n      toArrow: toArrow\n    });\n    this.addLine(line, focus);\n  }; // Render or redraw\n\n\n  Topology.prototype.render = function (noFocus) {\n    if (noFocus === void 0) {\n      noFocus = false;\n    }\n\n    if (noFocus) {\n      this.activeLayer.nodes = [];\n      this.activeLayer.lines = [];\n      this.hoverLayer.node = null;\n      this.hoverLayer.line = null;\n    }\n\n    this.offscreen.render();\n    this.canvas.render();\n  }; // open - redraw by the data\n\n\n  Topology.prototype.open = function (data) {\n    this.divLayer.clear(); // tslint:disable-next-line:forin\n\n    for (var key in node_1.images) {\n      delete node_1.images[key];\n    }\n\n    this.animateLayer.nodes = [];\n    this.animateLayer.lines = [];\n    this.lock(data.locked || status_1.Lock.None);\n\n    if (data.lineName) {\n      this.data.lineName = data.lineName;\n    }\n\n    this.data.scale = data.scale || 1;\n    le5le_store_1.Store.set('LT:scale', this.data.scale);\n\n    if (this.options.on) {\n      this.options.on('scale', this.data.scale);\n    }\n\n    this.data.bkColor = data.bkColor;\n    this.data.bkImage = data.bkImage;\n    this.data.nodes = [];\n    this.data.lines = [];\n\n    for (var _i = 0, _a = data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.data.nodes.push(new node_1.Node(item));\n    }\n\n    for (var _b = 0, _c = data.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      this.data.lines.push(new line_1.Line(item));\n    }\n\n    this.caches.list = [];\n    this.cache();\n    this.overflow();\n    this.render(true);\n    this.animate();\n  };\n\n  Topology.prototype.overflow = function () {\n    var rect = this.getRect();\n\n    if (rect.ex > this.canvas.width || rect.ey > this.canvas.height) {\n      this.resize({\n        width: rect.ex + 200,\n        height: rect.ey + 200\n      });\n    }\n  };\n\n  Topology.prototype.setNodeText = function () {\n    this.inputObj.text = this.input.value;\n    this.input.style.zIndex = '-1';\n    this.input.style.left = '-1000px';\n    this.input.style.width = '0';\n    this.cache();\n    this.offscreen.render();\n\n    if (this.options.on) {\n      this.options.on('setText', this.inputObj);\n    }\n\n    this.inputObj = null;\n  };\n\n  Topology.prototype.getMoveIn = function (pt) {\n    this.lastHoverNode = this.moveIn.hoverNode;\n    this.lastHoverLine = this.moveIn.hoverLine;\n    this.moveIn.type = MoveInType.None;\n    this.moveIn.hoverNode = null;\n    this.moveIn.lineControlPoint = null;\n    this.moveIn.hoverLine = null;\n    this.hoverLayer.hoverAnchorIndex = -1;\n\n    if (!this.data.locked && !this.activeLayer.locked() && this.activeLayer.rotateCPs[0] && this.activeLayer.rotateCPs[0].hit(pt, 15)) {\n      this.moveIn.type = MoveInType.Rotate;\n      this.divLayer.canvas.style.cursor = \"url(\\\"\" + this.options.rotateCursor + \"\\\"), auto\";\n      return;\n    }\n\n    if (this.activeLayer.nodes.length && utils_1.pointInRect(pt, this.activeLayer.sizeCPs)) {\n      this.moveIn.type = MoveInType.Nodes;\n    }\n\n    if (!this.data.locked && !this.options.hideSizeCP) {\n      for (var i = 0; i < this.activeLayer.sizeCPs.length; ++i) {\n        if (this.activeLayer.sizeCPs[i].hit(pt, 10)) {\n          this.moveIn.type = MoveInType.ResizeCP;\n          this.moveIn.activeAnchorIndex = i;\n          this.divLayer.canvas.style.cursor = resizeCursors[i];\n          return;\n        }\n      }\n    } // In active line.\n\n\n    for (var _i = 0, _a = this.activeLayer.lines; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      for (var i = 0; i < item.controlPoints.length; ++i) {\n        if (!item.locked && item.controlPoints[i].hit(pt, 10)) {\n          item.controlPoints[i].id = i;\n          this.moveIn.type = MoveInType.LineControlPoint;\n          this.moveIn.lineControlPoint = item.controlPoints[i];\n          this.moveIn.hoverLine = item;\n          this.divLayer.canvas.style.cursor = 'pointer';\n          return;\n        }\n      }\n\n      if (this.inLine(pt, item)) {\n        return;\n      }\n    }\n\n    this.divLayer.canvas.style.cursor = 'default';\n    var node = this.inNodes(pt, this.activeLayer.nodes);\n\n    if (node && !node.childStand) {\n      return;\n    }\n\n    node = this.inNodes(pt, this.data.nodes);\n\n    if (node && !node.childStand) {\n      return;\n    }\n\n    var index = 0;\n\n    for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      ++index;\n\n      if (!item.to) {\n        this.data.lines.splice(index - 1, 1);\n        continue;\n      }\n\n      if (this.inLine(pt, item)) {\n        return;\n      }\n    }\n  };\n\n  Topology.prototype.inNodes = function (pt, nodes) {\n    for (var i = nodes.length - 1; i > -1; --i) {\n      var node = this.inNode(pt, nodes[i]);\n\n      if (node) {\n        return node;\n      }\n    }\n  };\n\n  Topology.prototype.inNode = function (pt, node) {\n    if (node.childStand && node.children && node.children.length) {\n      var n = this.inNodes(pt, node.children);\n\n      if (n) {\n        return n;\n      }\n    }\n\n    if (node.hit(pt)) {\n      this.moveIn.hoverNode = node;\n      this.moveIn.type = MoveInType.Nodes;\n\n      if (this.data.locked || node.locked) {\n        this.divLayer.canvas.style.cursor = 'pointer';\n        return node;\n      }\n\n      this.divLayer.canvas.style.cursor = 'move'; // Too small\n\n      if (node.rect.width < 20 || node.rect.height < 20) {\n        return node;\n      }\n\n      for (var j = 0; j < node.rotatedAnchors.length; ++j) {\n        if (node.rotatedAnchors[j].hit(pt, 5)) {\n          if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {\n            continue;\n          }\n\n          this.moveIn.hoverNode = node;\n          this.moveIn.type = MoveInType.HoverAnchors;\n          this.moveIn.hoverAnchorIndex = j;\n          this.hoverLayer.hoverAnchorIndex = j;\n          this.divLayer.canvas.style.cursor = 'crosshair';\n          return node;\n        }\n      }\n\n      return node;\n    }\n\n    if (node.hit(pt, 5)) {\n      if (this.data.locked || node.locked) {\n        return node;\n      }\n\n      for (var j = 0; j < node.rotatedAnchors.length; ++j) {\n        if (node.rotatedAnchors[j].hit(pt, 5)) {\n          if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {\n            continue;\n          }\n\n          this.moveIn.hoverNode = node;\n          this.moveIn.type = MoveInType.HoverAnchors;\n          this.moveIn.hoverAnchorIndex = j;\n          this.hoverLayer.hoverAnchorIndex = j;\n          this.divLayer.canvas.style.cursor = 'crosshair';\n          return node;\n        }\n      }\n    }\n  };\n\n  Topology.prototype.inLine = function (point, line) {\n    if (line.from.hit(point, 10)) {\n      this.moveIn.type = MoveInType.LineFrom;\n      this.moveIn.hoverLine = line;\n\n      if (this.data.locked || line.locked) {\n        this.divLayer.canvas.style.cursor = 'pointer';\n      } else {\n        this.divLayer.canvas.style.cursor = 'move';\n      }\n\n      return true;\n    }\n\n    if (line.to.hit(point, 10)) {\n      this.moveIn.type = MoveInType.LineTo;\n      this.moveIn.hoverLine = line;\n\n      if (this.data.locked || line.locked) {\n        this.divLayer.canvas.style.cursor = 'pointer';\n      } else {\n        this.divLayer.canvas.style.cursor = 'move';\n      }\n\n      return true;\n    }\n\n    if (line.pointIn(point)) {\n      this.moveIn.type = MoveInType.LineMove;\n      this.moveIn.hoverLine = line;\n      this.divLayer.canvas.style.cursor = 'pointer';\n\n      if (line.from.id || line.to.id) {\n        this.moveIn.type = MoveInType.Line;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  Topology.prototype.getLineDock = function (point) {\n    this.hoverLayer.dockAnchor = null;\n\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.rect.hit(point, 10)) {\n        this.hoverLayer.node = item;\n      }\n\n      for (var i = 0; i < item.rotatedAnchors.length; ++i) {\n        if (item.rotatedAnchors[i].mode && item.rotatedAnchors[i].mode !== status_1.AnchorMode.In) {\n          continue;\n        }\n\n        if (item.rotatedAnchors[i].hit(point, 10)) {\n          point.id = item.id;\n          point.anchorIndex = i;\n          point.direction = item.rotatedAnchors[point.anchorIndex].direction;\n          point.x = item.rotatedAnchors[point.anchorIndex].x;\n          point.y = item.rotatedAnchors[point.anchorIndex].y;\n          this.hoverLayer.dockAnchor = item.rotatedAnchors[i];\n          break;\n        }\n      }\n\n      if (point.id) {\n        break;\n      }\n    }\n\n    return point;\n  };\n\n  Topology.prototype.getRectNodes = function (nodes, rect) {\n    if (rect.width < 0) {\n      rect.width = -rect.width;\n      rect.x = rect.ex;\n      rect.ex = rect.x + rect.width;\n    }\n\n    if (rect.height < 0) {\n      rect.height = -rect.height;\n      rect.y = rect.ey;\n      rect.ey = rect.y + rect.height;\n    }\n\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n      var item = nodes_1[_i];\n\n      if (rect.hitRect(item.rect)) {\n        this.activeLayer.addNode(item);\n      }\n    }\n  };\n\n  Topology.prototype.getRectLines = function (lines, rect) {\n    if (rect.width < 0) {\n      rect.width = -rect.width;\n      rect.x = rect.ex;\n      rect.ex = rect.x + rect.width;\n    }\n\n    if (rect.height < 0) {\n      rect.height = -rect.height;\n      rect.y = rect.ey;\n      rect.ey = rect.y + rect.height;\n    }\n\n    this.activeLayer.lines = [];\n\n    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n      var item = lines_1[_i];\n\n      if (rect.hit(item.from) && rect.hit(item.to)) {\n        this.activeLayer.addLine(item);\n      }\n    }\n  };\n\n  Topology.prototype.getAngle = function (pt) {\n    if (pt.x === this.activeLayer.rect.center.x) {\n      return pt.y <= this.activeLayer.rect.center.y ? 0 : 180;\n    }\n\n    if (pt.y === this.activeLayer.rect.center.y) {\n      return pt.x < this.activeLayer.rect.center.x ? 270 : 90;\n    }\n\n    var x = pt.x - this.activeLayer.rect.center.x;\n    var y = pt.y - this.activeLayer.rect.center.y;\n    var angle = Math.atan(Math.abs(x / y)) / (2 * Math.PI) * 360;\n\n    if (x > 0 && y > 0) {\n      angle = 180 - angle;\n    } else if (x < 0 && y > 0) {\n      angle += 180;\n    } else if (x < 0 && y < 0) {\n      angle = 360 - angle;\n    }\n\n    if (this.activeLayer.nodes.length === 1) {\n      return angle - this.activeLayer.nodes[0].rotate;\n    }\n\n    return angle;\n  };\n\n  Topology.prototype.showInput = function (item) {\n    if (this.data.locked || item.locked || this.options.hideInput) {\n      return;\n    }\n\n    this.inputObj = item;\n    var textRect = item.getTextRect();\n    this.input.value = item.text || '';\n    this.input.style.left = textRect.x + 'px';\n    this.input.style.top = textRect.y + 'px';\n    this.input.style.width = textRect.width + 'px';\n    this.input.style.height = textRect.height + 'px';\n    this.input.style.zIndex = '1000';\n    this.input.focus();\n  };\n\n  Topology.prototype.getRect = function () {\n    var x1 = 99999;\n    var y1 = 99999;\n    var x2 = -99999;\n    var y2 = -99999;\n    var points = [];\n\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var pts = item.rect.toPoints();\n\n      if (item.rotate) {\n        for (var _b = 0, pts_1 = pts; _b < pts_1.length; _b++) {\n          var pt = pts_1[_b];\n          pt.rotate(item.rotate, item.rect.center);\n        }\n      }\n\n      points.push.apply(points, pts);\n    }\n\n    for (var _c = 0, _d = this.data.lines; _c < _d.length; _c++) {\n      var l = _d[_c];\n      points.push(l.from);\n      points.push(l.to);\n\n      if (l.name === 'curve') {\n        for (var i = 0.01; i < 1; i += 0.02) {\n          points.push(curve_1.getBezierPoint(i, l.from, l.controlPoints[0], l.controlPoints[1], l.to));\n        }\n      }\n    }\n\n    for (var _e = 0, points_1 = points; _e < points_1.length; _e++) {\n      var item = points_1[_e];\n\n      if (x1 > item.x) {\n        x1 = item.x;\n      }\n\n      if (y1 > item.y) {\n        y1 = item.y;\n      }\n\n      if (x2 < item.x) {\n        x2 = item.x;\n      }\n\n      if (y2 < item.y) {\n        y2 = item.y;\n      }\n    }\n\n    return new rect_1.Rect(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  Topology.prototype.getNodesRect = function (nodes) {\n    var x1 = 99999;\n    var y1 = 99999;\n    var x2 = -99999;\n    var y2 = -99999;\n    var points = [];\n\n    for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n      var item = nodes_2[_i];\n      var pts = item.rect.toPoints();\n\n      if (item.rotate) {\n        for (var _a = 0, pts_2 = pts; _a < pts_2.length; _a++) {\n          var pt = pts_2[_a];\n          pt.rotate(item.rotate, item.rect.center);\n        }\n      }\n\n      points.push.apply(points, pts);\n    }\n\n    for (var _b = 0, points_2 = points; _b < points_2.length; _b++) {\n      var item = points_2[_b];\n\n      if (x1 > item.x) {\n        x1 = item.x;\n      }\n\n      if (y1 > item.y) {\n        y1 = item.y;\n      }\n\n      if (x2 < item.x) {\n        x2 = item.x;\n      }\n\n      if (y2 < item.y) {\n        y2 = item.y;\n      }\n    }\n\n    return new rect_1.Rect(x1, y1, x2 - x1, y2 - y1);\n  }; // Get a dock rect for moving nodes.\n\n\n  Topology.prototype.getDockPos = function (offsetX, offsetY) {\n    this.hoverLayer.dockLineX = 0;\n    this.hoverLayer.dockLineY = 0;\n    var offset = {\n      x: 0,\n      y: 0\n    };\n    var x = 0;\n    var y = 0;\n    var disX = dockOffset;\n    var disY = dockOffset;\n\n    for (var _i = 0, _a = this.activeLayer.dockWatchers; _i < _a.length; _i++) {\n      var activePt = _a[_i];\n\n      for (var _b = 0, _c = this.data.nodes; _b < _c.length; _b++) {\n        var item = _c[_b];\n\n        if (this.activeLayer.hasNode(item) || item.name === 'text') {\n          continue;\n        }\n\n        if (!item.dockWatchers) {\n          item.getDockWatchers();\n        }\n\n        for (var _d = 0, _e = item.dockWatchers; _d < _e.length; _d++) {\n          var p = _e[_d];\n          x = Math.abs(p.x - activePt.x - offsetX);\n\n          if (x < disX) {\n            disX = -99999;\n            offset.x = p.x - activePt.x;\n            this.hoverLayer.dockLineX = p.x | 0;\n          }\n\n          y = Math.abs(p.y - activePt.y - offsetY);\n\n          if (y < disY) {\n            disY = -99999;\n            offset.y = p.y - activePt.y;\n            this.hoverLayer.dockLineY = p.y | 0;\n          }\n        }\n      }\n    }\n\n    return offset;\n  };\n\n  Topology.prototype.cache = function () {\n    if (this.caches.index < this.caches.list.length - 1) {\n      this.caches.list.splice(this.caches.index + 1, this.caches.list.length - this.caches.index - 1);\n    }\n\n    var data = new data_1.TopologyData(this.data);\n    this.caches.list.push(data);\n    this.caches.index = this.caches.list.length - 1;\n  };\n\n  Topology.prototype.undo = function () {\n    if (this.data.locked || this.caches.index < 1) {\n      return;\n    }\n\n    this.divLayer.clear();\n    var data = new data_1.TopologyData(this.caches.list[--this.caches.index]);\n    this.data.nodes.splice(0, this.data.nodes.length);\n    this.data.lines.splice(0, this.data.lines.length);\n    this.data.nodes.push.apply(this.data.nodes, data.nodes);\n    this.data.lines.push.apply(this.data.lines, data.lines);\n    this.render(true);\n    this.divLayer.render();\n    this.options.on('undo', this.data);\n  };\n\n  Topology.prototype.redo = function () {\n    if (this.data.locked || this.caches.index > this.caches.list.length - 2) {\n      return;\n    }\n\n    this.divLayer.clear();\n    var data = new data_1.TopologyData(this.caches.list[++this.caches.index]);\n    this.data.nodes.splice(0, this.data.nodes.length);\n    this.data.lines.splice(0, this.data.lines.length);\n    this.data.nodes.push.apply(this.data.nodes, data.nodes);\n    this.data.lines.push.apply(this.data.lines, data.lines);\n    this.render(true);\n    this.divLayer.render();\n    this.options.on('redo', this.data);\n  };\n\n  Topology.prototype.toImage = function (type, quality, callback) {\n    var rect = this.getRect();\n    rect.x -= 10;\n    rect.y -= 10;\n    rect.width += 20;\n    rect.height += 20;\n    rect.round();\n    var srcRect = rect.clone();\n    srcRect.scale(this.offscreen.getDpiRatio(), new point_1.Point(0, 0));\n    srcRect.round();\n    var canvas = document.createElement('canvas');\n    canvas.width = srcRect.width;\n    canvas.height = srcRect.height;\n    canvas.style.width = rect.width + 'px';\n    canvas.style.height = rect.height + 'px';\n    var ctx = canvas.getContext('2d');\n\n    if (type && type !== 'image/png') {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    ctx.drawImage(this.offscreen.canvas, srcRect.x, srcRect.y, srcRect.width, srcRect.height, 0, 0, srcRect.width, srcRect.height);\n\n    if (callback) {\n      canvas.toBlob(callback);\n      return '';\n    }\n\n    return canvas.toDataURL(type, quality);\n  };\n\n  Topology.prototype.saveAsImage = function (name, type, quality) {\n    var a = document.createElement('a');\n    a.setAttribute('download', name || 'le5le.topology.png');\n    a.setAttribute('href', this.toImage(type, quality));\n    var evt = document.createEvent('MouseEvents');\n    evt.initEvent('click', true, true);\n    a.dispatchEvent(evt);\n  };\n\n  Topology.prototype.delete = function () {\n    var nodes = [];\n    var lines = [];\n    var i = 0;\n\n    for (var _i = 0, _a = this.activeLayer.lines; _i < _a.length; _i++) {\n      var line = _a[_i];\n      i = this.findLine(line);\n\n      if (i > -1) {\n        lines.push.apply(lines, this.data.lines.splice(i, 1));\n      }\n    }\n\n    for (var _b = 0, _c = this.activeLayer.nodes; _b < _c.length; _b++) {\n      var node = _c[_b];\n      i = this.findNode(node);\n\n      if (i > -1) {\n        this.divLayer.removeDiv(this.data.nodes[i]);\n        nodes.push.apply(nodes, this.data.nodes.splice(i, 1));\n      }\n    }\n\n    this.animate(false);\n    this.render(true);\n    this.cache();\n\n    if (this.options.on) {\n      this.options.on('delete', {\n        nodes: nodes,\n        lines: lines\n      });\n    }\n  };\n\n  Topology.prototype.removeNode = function (node) {\n    var i = this.findNode(node);\n\n    if (i > -1) {\n      this.divLayer.removeDiv(this.data.nodes[i]);\n      var nodes = this.data.nodes.splice(i, 1);\n\n      if (this.options.on) {\n        this.options.on('delete', {\n          nodes: nodes\n        });\n      }\n    }\n\n    this.render(true);\n    this.cache();\n  };\n\n  Topology.prototype.removeLine = function (line) {\n    var i = this.findLine(line);\n\n    if (i > -1) {\n      var lines = this.data.lines.splice(i, 1);\n\n      if (this.options.on) {\n        this.options.on('delete', {\n          lines: lines\n        });\n      }\n    }\n\n    this.render(true);\n    this.cache();\n  };\n\n  Topology.prototype.cut = function () {\n    if (this.data.locked) {\n      return;\n    }\n\n    this.clipboard = new data_1.TopologyData({\n      nodes: [],\n      lines: []\n    });\n\n    for (var _i = 0, _a = this.activeLayer.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.clipboard.nodes.push(new node_1.Node(item));\n      var i = this.findNode(item);\n\n      if (i > -1) {\n        this.divLayer.removeDiv(this.data.nodes[i]);\n        this.data.nodes.splice(i, 1);\n      }\n    }\n\n    for (var _b = 0, _c = this.activeLayer.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      this.clipboard.lines.push(new line_1.Line(item));\n      var i = 0;\n\n      for (var _d = 0, _e = this.data.lines; _d < _e.length; _d++) {\n        var line = _e[_d];\n\n        if (item.id === line.id) {\n          this.data.lines.splice(i, 1);\n        }\n\n        ++i;\n      }\n    }\n\n    this.cache();\n    this.activeLayer.clear();\n    this.hoverLayer.node = null;\n    this.moveIn.hoverLine = null;\n    this.moveIn.hoverNode = null;\n    this.render();\n\n    if (this.options.on) {\n      this.options.on('delete', {\n        nodes: this.clipboard.nodes,\n        lines: this.clipboard.lines\n      });\n    }\n  };\n\n  Topology.prototype.copy = function () {\n    this.clipboard = new data_1.TopologyData({\n      nodes: [],\n      lines: []\n    });\n\n    for (var _i = 0, _a = this.activeLayer.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.clipboard.nodes.push(new node_1.Node(item));\n    }\n\n    for (var _b = 0, _c = this.activeLayer.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      this.clipboard.lines.push(new line_1.Line(item));\n    }\n  };\n\n  Topology.prototype.parse = function () {\n    if (!this.clipboard || this.data.locked) {\n      return;\n    }\n\n    this.hoverLayer.node = null;\n    this.hoverLayer.line = null;\n    this.activeLayer.nodes = [];\n    this.activeLayer.lines = [];\n    var idMaps = {};\n\n    for (var _i = 0, _a = this.clipboard.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.newId(item, idMaps);\n      item.rect.x += 20;\n      item.rect.ex += 20;\n      item.rect.y += 20;\n      item.rect.ey += 20;\n      var node = new node_1.Node(item);\n      this.data.nodes.push(node);\n      this.activeLayer.nodes.push(node);\n    }\n\n    for (var _b = 0, _c = this.clipboard.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      item.id = uuid_1.s8();\n      item.from = new point_1.Point(item.from.x + 20, item.from.y + 20, item.from.direction, item.from.anchorIndex, idMaps[item.from.id]);\n      item.to = new point_1.Point(item.to.x + 20, item.to.y + 20, item.to.direction, item.to.anchorIndex, idMaps[item.to.id]);\n      var controlPoints = [];\n\n      for (var _d = 0, _e = item.controlPoints; _d < _e.length; _d++) {\n        var pt = _e[_d];\n        controlPoints.push(new point_1.Point(pt.x + 20, pt.y + 20));\n      }\n\n      var line = new line_1.Line(item);\n      line.controlPoints = controlPoints;\n      this.data.lines.push(line);\n      this.activeLayer.addLine(line);\n    }\n\n    this.render();\n    this.cache();\n\n    if (this.options.on) {\n      if (this.clipboard.nodes.length > 1 || this.clipboard.lines.length > 1 || this.clipboard.nodes.length && this.clipboard.lines.length) {\n        this.options.on('multi', {\n          nodes: this.clipboard.nodes,\n          lines: this.clipboard.lines\n        });\n      } else if (this.clipboard.nodes.length) {\n        this.options.on('addNode', this.activeLayer.nodes[0]);\n      } else if (this.clipboard.lines.length) {\n        this.options.on('addLine', this.activeLayer.lines[0]);\n      }\n    }\n  };\n\n  Topology.prototype.newId = function (node, idMaps) {\n    var old = node.id;\n    node.id = uuid_1.s8();\n    idMaps[old] = node.id;\n\n    if (node.children) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var item = _a[_i];\n        this.newId(item, idMaps);\n      }\n    }\n  };\n\n  Topology.prototype.animate = function (autoplay) {\n    if (autoplay === void 0) {\n      autoplay = true;\n    }\n\n    var n = Date.now();\n\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.animatePlay) {\n        item.animateStart = autoplay ? n : 0;\n      }\n    }\n\n    for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n\n      if (item.animatePlay) {\n        item.animateStart = autoplay ? n : 0;\n      }\n    }\n\n    this.animateLayer.start(!autoplay);\n  };\n\n  Topology.prototype.updateProps = function (node) {\n    if (node) {\n      node.round();\n      node.init();\n      this.activeLayer.updateChildren(node);\n      this.activeLayer.updateLines([node]);\n    }\n\n    this.activeLayer.calcControlPoints();\n    this.activeLayer.saveNodeRects();\n    this.activeLayer.changeLineType();\n    this.render();\n    this.cache();\n  };\n\n  Topology.prototype.lock = function (lock) {\n    this.data.locked = lock;\n\n    if (this.options.on) {\n      this.options.on('locked', this.data.locked);\n    }\n  };\n\n  Topology.prototype.lockNodes = function (nodes, lock) {\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      for (var _b = 0, nodes_3 = nodes; _b < nodes_3.length; _b++) {\n        var node = nodes_3[_b];\n\n        if (item.id === node.id) {\n          item.locked = lock;\n          break;\n        }\n      }\n    }\n\n    if (this.options.on) {\n      this.options.on('lockNodes', {\n        nodes: nodes,\n        lock: lock\n      });\n    }\n  };\n\n  Topology.prototype.lockLines = function (lines, lock) {\n    for (var _i = 0, _a = this.data.lines; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      for (var _b = 0, lines_2 = lines; _b < lines_2.length; _b++) {\n        var line = lines_2[_b];\n\n        if (item.id === line.id) {\n          item.locked = lock;\n          break;\n        }\n      }\n    }\n\n    if (this.options.on) {\n      this.options.on('lockLines', {\n        lines: lines,\n        lock: lock\n      });\n    }\n  };\n\n  Topology.prototype.top = function (node) {\n    var i = this.findNode(node);\n\n    if (i > -1) {\n      this.data.nodes.push(this.data.nodes[i]);\n      this.data.nodes.splice(i, 1);\n    }\n  };\n\n  Topology.prototype.bottom = function (node) {\n    var i = this.findNode(node);\n\n    if (i > -1) {\n      this.data.nodes.unshift(this.data.nodes[i]);\n      this.data.nodes.splice(i + 1, 1);\n    }\n  };\n\n  Topology.prototype.combine = function (nodes, stand) {\n    if (!nodes) {\n      nodes = this.activeLayer.nodes;\n    }\n\n    var rect = this.getNodesRect(nodes);\n\n    for (var _i = 0, nodes_4 = nodes; _i < nodes_4.length; _i++) {\n      var item = nodes_4[_i];\n      var i = this.findNode(item);\n\n      if (i > -1) {\n        this.data.nodes.splice(i, 1);\n      }\n    }\n\n    var node = new node_1.Node({\n      name: 'combine',\n      rect: new rect_1.Rect(rect.x, rect.y, rect.width, rect.height),\n      text: '',\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      childStand: stand,\n      strokeStyle: 'transparent'\n    });\n    node.children = [];\n\n    for (var _a = 0, nodes_5 = nodes; _a < nodes_5.length; _a++) {\n      var item = nodes_5[_a];\n      item.stand = stand;\n      item.parentId = node.id;\n      item.calcRectInParent(node);\n      node.children.push(item);\n    }\n\n    this.data.nodes.push(node);\n    this.activeLayer.setNodes([node]);\n\n    if (this.options.on) {\n      this.options.on('node', node);\n    }\n\n    this.cache();\n  };\n\n  Topology.prototype.uncombine = function (node) {\n    if (!node) {\n      node = this.activeLayer.nodes[0];\n    }\n\n    if (node.name !== 'combine') {\n      return;\n    }\n\n    var i = this.findNode(node);\n\n    if (i > -1) {\n      this.data.nodes.splice(i, 1);\n    }\n\n    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.parentId = undefined;\n      item.rectInParent = undefined;\n      item.stand = undefined;\n      this.data.nodes.push(item);\n    }\n\n    this.cache();\n    this.activeLayer.clear();\n    this.hoverLayer.clear();\n  };\n\n  Topology.prototype.findNode = function (node) {\n    for (var i = 0; i < this.data.nodes.length; ++i) {\n      if (node.id === this.data.nodes[i].id) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  Topology.prototype.findLine = function (line) {\n    for (var i = 0; i < this.data.lines.length; ++i) {\n      if (line.id === this.data.lines[i].id) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  Topology.prototype.translate = function (x, y, process) {\n    if (!process) {\n      this.lastTranlated.x = 0;\n      this.lastTranlated.y = 0;\n    }\n\n    var offsetX = x - this.lastTranlated.x;\n    var offsetY = y - this.lastTranlated.y;\n\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.translate(offsetX, offsetY);\n    }\n\n    for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      item.translate(offsetX, offsetY);\n    }\n\n    this.lastTranlated.x = x;\n    this.lastTranlated.y = y;\n    this.overflow();\n    this.render();\n    this.animateLayer.start();\n    this.cache();\n\n    if (this.options.on) {\n      this.options.on('translate', {\n        x: x,\n        y: y\n      });\n    }\n  }; // scale for scaled canvas:\n  //   > 1, expand\n  //   < 1, reduce\n\n\n  Topology.prototype.scale = function (scale) {\n    if (this.data.scale * scale < 0.25) {\n      return;\n    }\n\n    this.data.scale *= scale;\n    var center = this.getRect().center;\n\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.scale(scale, center);\n    }\n\n    for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {\n      var item = _c[_b];\n      item.scale(scale, center);\n    }\n\n    le5le_store_1.Store.set('LT:scale', this.data.scale);\n    this.overflow();\n    this.render();\n    this.animateLayer.start();\n    this.cache();\n\n    if (this.options.on) {\n      this.options.on('scale', this.data.scale);\n    }\n  }; // scale for origin canvas:\n\n\n  Topology.prototype.scaleTo = function (scale) {\n    this.scale(scale / this.data.scale);\n  };\n\n  Topology.prototype.round = function () {\n    for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.round();\n    }\n  };\n\n  Topology.prototype.alignNodes = function (align) {\n    this.activeLayer.alignNodes(align);\n    this.render();\n  };\n\n  Topology.prototype.link = function (data) {\n    var _this = this;\n\n    if (!data || !data.link || !this.data.locked) {\n      return;\n    }\n\n    window.open(data.link, '_blank');\n    this.mouseDown = null;\n    setTimeout(function () {\n      _this.divLayer.canvas.focus();\n    }, 1000);\n  };\n\n  Topology.prototype.createMarkdownTip = function () {\n    this.tipMarkdown = document.createElement('div');\n    this.tipMarkdown.style.position = 'absolute';\n    this.tipMarkdown.style.zIndex = '-1';\n    this.tipMarkdown.style.left = '-9999px';\n    this.tipMarkdown.style.width = '500px';\n    this.tipMarkdown.style.outline = 'none';\n    this.tipMarkdown.style.border = '1px solid #d0d0d0';\n    this.tipMarkdown.style.backgroundColor = '#fff';\n    this.tipMarkdown.style.padding = '10px 15px';\n    this.tipMarkdown.style.overflowY = 'auto';\n    document.body.appendChild(this.tipMarkdown);\n  };\n\n  Topology.prototype.showTip = function (data, pos) {\n    if (!this.data.locked || !data || !data.markdown && !data.tipId && !data.title || data.id === this.tip) {\n      return;\n    }\n\n    if (data.title) {\n      this.divLayer.canvas.title = data.title;\n      this.tip = data.id;\n      return;\n    }\n\n    if (data.tipId) {\n      this.tipElem = document.getElementById(data.tipId);\n    }\n\n    var parentRect = this.parentElem.getBoundingClientRect();\n    var w = data.markdown ? 500 : this.tipElem ? this.tipElem.getBoundingClientRect().width : 500;\n    var x = pos.x + parentRect.left - w / 2;\n    var y = pos.y + parentRect.top;\n\n    if (data instanceof node_1.Node) {\n      x = parentRect.left + data.rect.center.x - w / 2;\n      y = parentRect.top + data.rect.ey;\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    if (x + w > document.body.clientWidth) {\n      x = document.body.clientWidth - w;\n    }\n\n    if (y + 260 > document.body.clientHeight) {\n      y = document.body.clientHeight - 260;\n    }\n\n    if (data.markdown) {\n      this.tipMarkdown.style.height = '30px';\n      var marked = window.marked;\n\n      if (marked) {\n        this.tipMarkdown.innerHTML = marked(data.markdown);\n      } else {\n        this.tipMarkdown.innerHTML = data.markdown;\n      }\n\n      if (this.tipMarkdown.scrollHeight < 260) {\n        this.tipMarkdown.style.height = this.tipMarkdown.scrollHeight + 10 + 'px';\n      } else {\n        this.tipMarkdown.style.height = '260px';\n      }\n\n      var a = this.tipMarkdown.getElementsByTagName('A');\n\n      for (var i = 0; i < a.length; ++i) {\n        a[i].setAttribute('target', '_blank');\n      }\n\n      this.tipMarkdown.style.left = x + 'px';\n      this.tipMarkdown.style.top = y + 'px';\n      this.tipMarkdown.style.zIndex = '100';\n    } else if (this.tipElem) {\n      this.tipElem.style.left = x + 'px';\n      this.tipElem.style.top = y + 'px';\n      this.tipElem.style.zIndex = '100';\n    }\n\n    this.tip = data.id;\n  };\n\n  Topology.prototype.hideTip = function () {\n    if (!this.tip) {\n      return;\n    }\n\n    this.tipMarkdown.style.left = '-9999px';\n    this.tipMarkdown.style.zIndex = '-1';\n\n    if (this.tipElem) {\n      this.tipElem.style.left = '-9999px';\n      this.tipElem.style.zIndex = '-1';\n      this.tipElem = null;\n    }\n\n    this.divLayer.canvas.title = '';\n    this.tip = '';\n  };\n\n  Topology.prototype.scroll = function (x, y) {\n    var _this = this;\n\n    if (this.scrolling) {\n      return;\n    }\n\n    this.scrolling = true;\n    this.parentElem.scrollLeft += x;\n    this.parentElem.scrollTop += y;\n    setTimeout(function () {\n      _this.scrolling = false;\n    }, 700);\n  };\n\n  Topology.prototype.destroy = function () {\n    this.subcribe.unsubscribe();\n    this.subcribeImage.unsubscribe();\n    this.subcribeAnimateEnd.unsubscribe();\n    this.subcribeAnimateMoved.unsubscribe();\n    this.subcribeMediaEnd.unsubscribe();\n    this.animateLayer.destroy();\n    this.divLayer.destroy();\n    document.body.removeChild(this.tipMarkdown);\n  };\n\n  return Topology;\n}();\n\nexports.Topology = Topology;","map":null,"metadata":{},"sourceType":"script"}