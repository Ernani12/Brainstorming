{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n/**\n * Wrap the blocks in the current selection in a new list. Selected\n * lists are merged together.\n */\n\n\nfunction wrapInList(opts, change, type, data, itemType) {\n  var selectedBlocks = getHighestSelectedBlocks(change.value);\n  type = type || opts.types[0];\n  change.withoutNormalizing(function () {\n    // Wrap in container\n    change.wrapBlock({\n      type: type,\n      data: _slate.Data.create(data)\n    }); // Wrap in list items\n\n    selectedBlocks.forEach(function (node) {\n      if ((0, _utils.isList)(opts, node)) {\n        // Merge its items with the created list\n        node.nodes.forEach(function (_ref) {\n          var key = _ref.key;\n          return change.unwrapNodeByKey(key);\n        });\n      } else {\n        change.wrapBlockByKey(node.key, itemType || opts.typeItem);\n      }\n    });\n  });\n  return change.normalize();\n}\n/**\n * Returns the highest list of blocks that cover the current selection\n */\n\n\nfunction getHighestSelectedBlocks(value) {\n  var range = value.selection;\n  var document = value.document;\n  var startBlock = document.getClosestBlock(range.start.key);\n  var endBlock = document.getClosestBlock(range.end.key);\n\n  if (startBlock === endBlock) {\n    return (0, _immutable.List)([startBlock]);\n  }\n\n  var ancestor = document.getCommonAncestor(startBlock.key, endBlock.key);\n  var startPath = ancestor.getPath(startBlock.key);\n  var endPath = ancestor.getPath(endBlock.key);\n  return ancestor.nodes.slice(startPath[0], endPath[0] + 1);\n}\n\nexports.default = wrapInList;","map":null,"metadata":{},"sourceType":"script"}