{"version":3,"file":"index.js","sources":["../src/options.js","../src/utils/createCell.js","../src/utils/createRow.js","../src/utils/createTable.js","../src/utils/TablePosition.js","../src/utils/getPosition.js","../src/utils/getPositionByKey.js","../src/utils/isRangeInTable.js","../src/utils/isSelectionInTable.js","../src/utils/isSelectionOutOfTable.js","../src/utils/forEachCells.js","../src/utils/getCellsAtRow.js","../src/utils/getCellsAtColumn.js","../src/utils/getCopiedFragment.js","../src/changes/insertTable.js","../src/changes/insertRow.js","../src/changes/moveSelection.js","../src/changes/insertColumn.js","../src/changes/insertTableFragmentAtRange.js","../src/changes/clearCell.js","../src/changes/removeRowByKey.js","../src/changes/removeRow.js","../src/changes/removeColumnByKey.js","../src/changes/removeColumn.js","../src/changes/removeTableByKey.js","../src/changes/removeTable.js","../src/changes/moveSelectionBy.js","../src/changes/moveSelectionOutOfTable.js","../src/validation/slate-schema-violations.js","../src/validation/schema.js","../src/validation/normalizeNode.js","../src/core.js","../src/handlers/onEnter.js","../src/handlers/onModEnter.js","../src/handlers/onTab.js","../src/handlers/onBackspace.js","../src/handlers/onUpDown.js","../src/handlers/onModUpDown.js","../src/handlers/onKeyDown.js","../src/handlers/onCopy.js","../src/index.js"],"sourcesContent":["// @flow\n\nimport { Record } from 'immutable';\nimport type { Node } from 'slate';\n\nexport type OptionsFormat = {\n    typeTable?: string,\n    typeRow?: string,\n    typeCell?: string,\n    typeContent?: string,\n    exitBlockType?: string\n};\n\n/**\n * The plugin options\n */\nclass Options extends Record({\n    typeTable: 'table',\n    typeRow: 'table_row',\n    typeCell: 'table_cell',\n    typeContent: 'paragraph',\n    exitBlockType: 'paragraph',\n    insertRowOnEnter: true,\n    edgeRowExitOnDirection: false,\n}) {\n    // Done as comments to prevent defining properties\n    // https://github.com/babel/babel/issues/8417\n    /*:: typeTable: string; */\n    /*:: typeRow: string; */\n    /*:: typeCell: string; */\n    /*:: typeContent: string; */\n    /*:: exitBlockType: string; */\n\n    /*\n     * Return a node filter to find a cell.\n     */\n    isCell = (node: Node): boolean =>\n        node.object == 'block' && node.type == this.typeCell;\n}\n\nexport default Options;\n","// @flow\nimport { Block, Text, type Node } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Create a new cell\n */\nfunction createCell(opts: Options, nodes?: Node[]): Block {\n    return Block.create({\n        type: opts.typeCell,\n        nodes: nodes || [createEmptyContent(opts)],\n    });\n}\n\n/**\n * Create a new default content block\n */\nfunction createEmptyContent(opts: Options): Block {\n    return Block.create({\n        type: opts.typeContent,\n        nodes: [Text.create()],\n    });\n}\n\nexport default createCell;\n","// @flow\nimport { Range } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\nimport createCell from './createCell';\n\n/**\n * Create a new row block\n */\nfunction createRow(\n    opts: Options,\n    columns: number,\n    getCellContent?: (column: number) => Node[],\n): Block {\n    const cellNodes = Range(0, columns)\n        .map(i =>\n            createCell(opts, getCellContent ? getCellContent(i) : undefined),\n        )\n        .toJS();\n\n    return Block.create({\n        type: opts.typeRow,\n        nodes: Block.createList(cellNodes),\n    });\n}\n\nexport default createRow;\n","// @flow\nimport { Range } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\nimport createRow from './createRow';\n\n/**\n * Create a table\n */\nfunction createTable(\n    opts: Options,\n    columns: number,\n    rows: number,\n    getCellContent?: (row: number, column: number) => Node[]\n): Block {\n    const rowNodes = Range(0, rows)\n        .map(i =>\n            createRow(\n                opts,\n                columns,\n                getCellContent ? getCellContent.bind(null, i) : undefined\n            )\n        )\n        .toJS();\n\n    return Block.create({\n        type: opts.typeTable,\n        nodes: Block.createList(rowNodes)\n    });\n}\n\nexport default createTable;\n","// @flow\nimport { Record } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\n\nclass TablePosition extends Record({\n    tableBlock: null,\n    rowBlock: null,\n    cellBlock: null,\n    contentBlock: null,\n    node: null,\n}) {\n    // Block container for the table\n    /*::tableBlock: ?Block;*/\n\n    // Block for current row\n    /*::rowBlock: ?Block;*/\n\n    // Block for current cell\n    /*::cellBlock: ?Block;*/\n\n    // Current content block in the cell\n    /*::contentBlock: ?Block;*/\n\n    /**\n     * Create a new instance of a TablePosition from a Slate document\n     * and a node key.\n     */\n    static create(\n        opts: Options,\n        containerNode: Node,\n        key: string,\n    ): TablePosition {\n        const node = containerNode.getDescendant(key);\n        const ancestors = containerNode.getAncestors(key).push(node);\n        const tableBlock = ancestors.findLast(p => p.type === opts.typeTable);\n        const rowBlock = ancestors.findLast(p => p.type === opts.typeRow);\n\n        const cellBlock = ancestors.findLast(p => p.type === opts.typeCell);\n        const contentBlock = ancestors\n            .skipUntil(ancestor => ancestor === cellBlock)\n            .skip(1)\n            .first();\n\n        return new TablePosition({\n            tableBlock,\n            rowBlock,\n            cellBlock,\n            contentBlock,\n            node,\n        });\n    }\n\n    get table(): Block {\n        if (!this.tableBlock) {\n            throw new Error('Not in a table');\n        }\n        return this.tableBlock;\n    }\n\n    get row(): Block {\n        if (!this.rowBlock) {\n            throw new Error('Not in a row');\n        }\n        return this.rowBlock;\n    }\n\n    get cell(): Block {\n        if (!this.cellBlock) {\n            throw new Error('Not in a cell');\n        }\n        return this.cellBlock;\n    }\n\n    /**\n     * Check to see if this position is within a cell\n     */\n    isInCell(): boolean {\n        return Boolean(this.cellBlock);\n    }\n\n    /**\n     * Check to see if this position is within a row\n     */\n    isInRow(): boolean {\n        return Boolean(this.rowBlock);\n    }\n\n    /**\n     * Check to see if this position is within a table\n     */\n    isInTable(): boolean {\n        return Boolean(this.tableBlock);\n    }\n\n    /**\n     * Check to see if this position is at the top of the cell.\n     */\n    isTopOfCell(): boolean {\n        const { cellBlock, node} = this;\n\n        if (!cellBlock || !node) {\n            return false;\n        }\n        \n        return cellBlock.getPath(node.key).every(index => index === 0);\n    }\n\n    /**\n     * Check to see if this position is at the bottom of the cell.\n     */\n    isBottomOfCell(): boolean {\n        const { node, cellBlock } = this;\n\n        if (!node || !cellBlock) {\n            return false;\n        }\n\n        const ancestors = cellBlock.getAncestors(node.key);\n\n\n        return ancestors.every((node, index) => {\n          const next = ancestors.get(index + 1);\n          if(!next) return true;\n          return node.nodes.indexOf(next) === (node.nodes.size - 1);\n        });\n    }\n\n    /**\n     * Get count of columns\n     */\n    getWidth(): number {\n        const { table } = this;\n        const rows = table.nodes;\n        const cells = rows.first().nodes;\n\n        return cells.size;\n    }\n\n    /**\n     * Get count of rows\n     */\n    getHeight(): number {\n        const { table } = this;\n        const rows = table.nodes;\n\n        return rows.size;\n    }\n\n    /**\n     * Get index of current row in the table.\n     */\n    getRowIndex(): number {\n        const { table, row } = this;\n        const rows = table.nodes;\n\n        return rows.findIndex(x => x === row);\n    }\n\n    /**\n     * Get index of current column in the row.\n     */\n    getColumnIndex(): number {\n        const { row, cell } = this;\n        const cells = row.nodes;\n\n        return cells.findIndex(x => x === cell);\n    }\n\n    /**\n     * True if on first cell of the table\n     */\n    isFirstCell(): boolean {\n        return this.isFirstRow() && this.isFirstColumn();\n    }\n\n    /**\n     * True if on last cell of the table\n     */\n    isLastCell(): boolean {\n        return this.isLastRow() && this.isLastColumn();\n    }\n\n    /**\n     * True if on first row\n     */\n    isFirstRow(): boolean {\n        return this.getRowIndex() === 0;\n    }\n\n    /**\n     * True if on last row\n     */\n    isLastRow(): boolean {\n        return this.getRowIndex() === this.getHeight() - 1;\n    }\n\n    /**\n     * True if on first column\n     */\n    isFirstColumn(): boolean {\n        return this.getColumnIndex() === 0;\n    }\n\n    /**\n     * True if on last column\n     */\n    isLastColumn(): boolean {\n        return this.getColumnIndex() === this.getWidth() - 1;\n    }\n}\n\nexport default TablePosition;\n","// @flow\nimport type Options from '../options';\n\nimport TablePosition from './TablePosition';\n\n/**\n * The position of the selection start block, in the current table\n */\nfunction getPosition(\n    opts: Options,\n    editor,\n): TablePosition {\n    const {value} = editor;\n    if (!value.selection.start || !value.selection.start.key) return new TablePosition();\n    return TablePosition.create(opts, value.document, value.selection.start.key);\n}\n\nexport default getPosition;\n","// @flow\nimport { type Node } from 'slate';\n\nimport type Options from '../options';\n\nimport TablePosition from './TablePosition';\n\n/*\n * The position of a particular node, in the current table\n */\nfunction getPositionByKey(\n    opts: Options,\n    editor,\n    containerNode: Node,\n    // Key of the node in desired position\n    key: string\n): TablePosition {\n    return TablePosition.create(opts, containerNode, key);\n}\n\nexport default getPositionByKey;\n","// @flow\n\nimport type { Node, Range } from 'slate';\n\nimport TablePosition from './TablePosition';\nimport type Options from '../options';\n\n/**\n * True if the given range is inside one table\n */\nfunction isRangeInTable(opts: Options, node: Node, range: Range): boolean {\n    const { start, end } = range;\n    const startPosition = TablePosition.create(opts, node, start.key);\n    const endPosition = TablePosition.create(opts, node, end.key);\n\n    // Only handle events in tables\n    if (!startPosition.isInTable() || !endPosition.isInTable()) {\n        return false;\n    }\n\n    // Inside the same table\n    return startPosition.table === endPosition.table;\n}\n\nexport default isRangeInTable;\n","// @flow\n\nimport type Options from '../options';\nimport isRangeInTable from './isRangeInTable';\n\n/**\n * Is the selection in a table\n */\nfunction isSelectionInTable(opts: Options, editor): boolean {\n    const {value} = editor;\n    const {selection} = value;\n\n    if (!selection.start.key) return false;\n    return isRangeInTable(opts, value.document, value.selection);\n}\n\nexport default isSelectionInTable;\n","// @flow\n\nimport TablePosition from './TablePosition';\nimport type Options from '../options';\n\n/**\n * Are the selection start and end outside a table.\n */\nfunction isSelectionOutOfTable(opts: Options, editor): boolean {\n    const {value} = editor;\n    const {selection} = value;\n\n    if (!selection.start.key) return false;\n\n    const startPosition = TablePosition.create(opts, value.document, selection.start.key);\n    const endPosition = TablePosition.create(opts, value.document, selection.end.key);\n\n    // Only handle events in tables\n    return !startPosition.isInTable() && !endPosition.isInTable();\n}\n\nexport default isSelectionOutOfTable;\n","// @flow\nimport { type Block } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Run the given function against each cells of the table\n */\nfunction forEachCells(\n    opts: Options,\n    // The table\n    table: Block,\n    fn: (cell: Block, row: number, column: number) => any\n): void {\n    return table.nodes.forEach((row, rowIndex) =>\n        row.nodes.forEach((cell, columnIndex) =>\n            fn(cell, rowIndex, columnIndex)\n        )\n    );\n}\n\nexport default forEachCells;\n","// @flow\nimport { type Block } from 'slate';\nimport { type List } from 'immutable';\n\nimport type Options from '../options';\n\n/**\n * Returns the list of cells at the given row index\n */\nfunction getCellsAtRow(\n    opts: Options,\n    editor,\n    table: Block,\n    rowIndex: number\n): List<Block> {\n    return table.nodes.get(rowIndex).nodes;\n}\n\nexport default getCellsAtRow;\n","// @flow\nimport { type Block } from 'slate';\nimport { type List } from 'immutable';\n\nimport type Options from '../options';\n\n/**\n * Returns the list of cells at the given column index\n */\nfunction getCellsAtColumn(\n    opts: Options,\n    editor,\n    table: Block,\n    columnIndex: number\n): List<Block> {\n    return table.nodes.map(row => row.nodes.get(columnIndex));\n}\n\nexport default getCellsAtColumn;\n","/* @flow */\nimport {type Value, type Document} from 'slate';\n\nimport type Options from '../options';\nimport TablePosition from './TablePosition';\n\nfunction getCopiedFragment(opts: Options, value: Value): ?Document {\n  const {selection, document} = value;\n  const startPosition = TablePosition.create(\n    opts,\n    document,\n    selection.start.key\n  );\n  const endPosition = TablePosition.create(opts, document, selection.end.key);\n\n  // Fragment as it would be copied by Slate\n  const baseFragment = value.fragment;\n\n  if (endPosition.cell === startPosition.cell) {\n    // The selection is inside a single cell. Only copy the content of that cell\n    const copiedCell = baseFragment\n      .getAncestors(baseFragment.getFirstText().key)\n      .findLast(n => n.type === opts.typeCell);\n\n    return baseFragment.merge({\n      nodes: copiedCell.nodes,\n    });\n  }\n}\n\nexport default getCopiedFragment;\n","// @flow\nimport { type Change, type Node } from 'slate';\n\nimport { createTable } from '../utils';\nimport type Options from '../options';\n\n/**\n * Insert a new table\n */\nfunction insertTable(\n    opts: Options,\n    change: Change,\n    columns?: number = 2,\n    rows?: number = 2,\n    getCellContent?: (column: number, row: number) => Node[]\n): Change {\n    const { value } = change;\n\n    if (!value.selection.start.key) return change;\n\n    // Create the table node\n    const table = createTable(opts, columns, rows, getCellContent);\n\n    return change.insertBlock(table);\n}\n\nexport default insertTable;\n","// @flow\nimport { type Change, type Block } from 'slate';\n\nimport { TablePosition, createRow } from '../utils';\nimport type Options from '../options';\n\n/**\n * Insert a new row in current table\n */\nfunction insertRow(\n    opts: Options,\n    change: Change,\n    at?: number, // row index\n    getRow?: (columns: number) => Block, // Generate the row yourself\n) {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    const { table } = pos;\n\n    // Create a new row with the right count of cells\n    const columns = table.nodes.get(0).nodes.size;\n    const newRow = getRow ? getRow(columns) : createRow(opts, columns);\n\n    if (typeof at === 'undefined') {\n        at = pos.getRowIndex() + 1;\n    }\n\n    return change\n        .insertNodeByKey(table.key, at, newRow)\n        .moveToEndOfNode(newRow.nodes.get(pos.getColumnIndex()));\n}\n\nexport default insertRow;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection to {x,y}\n */\nfunction moveSelection(\n    opts: Options,\n    change: Change,\n    x: number,\n    y: number\n): Change {\n    const { value } = change;\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    if (!pos.isInCell()) {\n        throw new Error('moveSelection can only be applied from within a cell');\n    }\n\n    const { table } = pos;\n    const row = table.nodes.get(y);\n    const cell = row.nodes.get(x);\n\n    return change.moveToStartOfNode(cell);\n}\n\nexport default moveSelection;\n","// @flow\nimport { type Change, type Block } from 'slate';\n\nimport { TablePosition, createCell } from '../utils';\nimport moveSelection from './moveSelection';\n\nimport type Options from '../options';\n\n/**\n * Insert a new column in current table\n */\nfunction insertColumn(\n    opts: Options,\n    change: Change,\n    at?: number, // Column index\n    getCell?: (column: number, row: number) => Block,\n): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    const { table } = pos;\n\n    const columnIndex =\n        typeof at === 'undefined' ? pos.getColumnIndex() + 1 : at;\n\n    // Insert the new cell\n    change.withoutNormalizing(() => {\n        table.nodes.forEach((row, rowIndex) => {\n            const newCell = getCell\n                ? getCell(columnIndex, rowIndex)\n                : createCell(opts);\n            change.insertNodeByKey(row.key, columnIndex, newCell);\n        });\n    });\n\n    // Update the selection (not doing can break the undo)\n    return moveSelection(\n        opts,\n        change,\n        pos.getColumnIndex() + 1,\n        pos.getRowIndex(),\n    );\n}\n\nexport default insertColumn;\n","// @flow\nimport { type Change, type Range, type Document } from 'slate';\n\nimport insertRow from './insertRow';\nimport insertColumn from './insertColumn';\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Used when pasting a fragment of table into another one\n */\nfunction insertTableFragmentAtRange(\n    opts: Options,\n    change: Change,\n    range: Range,\n    // This fragment should contain only one table,\n    // with a valid number of cells\n    fragment: Document\n): Change {\n    const insertedTable = fragment.nodes.first();\n    if (\n        !(\n            fragment.nodes.size === 1 &&\n            insertedTable &&\n            insertedTable.type === opts.typeTable\n        )\n    ) {\n        throw new Error('Expected to insert a fragment containing one table');\n    }\n\n    const { value } = change;\n    const targetPosition = TablePosition.create(\n        opts,\n        value.document,\n        value.selection.start.key\n    );\n\n    const fragmentRows = insertedTable.nodes;\n    const fragmentHeight = fragmentRows.size;\n    const fragmentWidth = fragmentRows.first().nodes.size;\n\n    // Insert columns and rows to accomodate the incoming pasted cells\n    const missingWidth =\n        fragmentWidth +\n        targetPosition.getColumnIndex() -\n        targetPosition.getWidth();\n    const missingHeight =\n        fragmentHeight +\n        targetPosition.getRowIndex() -\n        targetPosition.getHeight();\n\n    if (missingWidth > 0) {\n        // Add columns\n        Array(missingWidth)\n            .fill()\n            .forEach(() => {\n                insertColumn(opts, change, targetPosition.getWidth());\n            });\n    }\n    if (missingHeight > 0) {\n        // Add rows\n        Array(missingHeight)\n            .fill()\n            .forEach(() => {\n                insertRow(opts, change, targetPosition.getHeight());\n            });\n    }\n\n    // Patch the inserted table over the target table, overwritting the cells\n    const existingTable = change.value.document.getDescendant(\n        targetPosition.table.key\n    );\n\n    change.withoutNormalizing(() => {\n    fragmentRows.forEach((fragmentRow, fragmentRowIndex) => {\n        fragmentRow.nodes.forEach((newCell, fragmentColumnIndex) => {\n            const existingCell = existingTable.nodes\n                .get(targetPosition.getRowIndex() + fragmentRowIndex)\n                .nodes.get(\n                    targetPosition.getColumnIndex() + fragmentColumnIndex\n                );\n            change.replaceNodeByKey(existingCell.key, newCell);\n                });\n        });\n    });\n\n    const lastPastedCell = fragmentRows.last().nodes.last();\n    return change.moveToEndOfNode(lastPastedCell);\n}\n\nexport default insertTableFragmentAtRange;\n","// @flow\nimport { Block, type Change } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Clear the content of the given cell\n */\nfunction clearCell(opts: Options, change: Change, cell: Block): Change {\n    const newBlock = Block.create({ type: opts.typeContent });\n    const { nodes } = cell;\n\n    // Insert a new empty node\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(cell.key, 0, newBlock);\n    });\n\n    // Remove all previous nodes\n    nodes.forEach(node => {\n        change.removeNodeByKey(node.key);\n    });\n\n    return change;\n}\n\nexport default clearCell;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport clearCell from './clearCell';\nimport type Options from '../options';\n\n/**\n * Remove the row associated to a given key in a table.\n * Clear thw row if last remaining row\n */\nfunction removeRowByKey(opts: Options, change: Change, key: string): Change {\n    const { value } = change;\n\n    const pos = TablePosition.create(opts, value.document, key);\n\n    // Update table by removing the row\n    if (pos.getHeight() > 1) {\n        change.removeNodeByKey(key);\n    } else {\n        // If last remaining row, clear it instead\n        pos.row.nodes.forEach(cell => {\n            cell.nodes.forEach(() => clearCell(opts, change, cell));\n        });\n    }\n    // this will also invalidate the selection - move it to the first cell\n    // change.moveToRangeOfNode(pos.row.nodes.first());\n    \n    return change;\n}\n\nexport default removeRowByKey;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\nimport removeRowByKey from './removeRowByKey';\n\n/**\n * Remove current row in a table. Clear it if last remaining row\n */\nfunction removeRow(opts: Options, change: Change, at: number): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    let rowKey;\n    if (typeof at === 'undefined') {\n        rowKey = pos.row.key;\n    } else {\n        rowKey = pos.table.nodes.get(at).key;\n    }\n\n    return removeRowByKey(opts, change, rowKey);\n}\n\nexport default removeRow;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport clearCell from './clearCell';\nimport type Options from '../options';\n\n/**\n * Delete the column associated with the given cell key in a table\n */\nfunction removeColumnByKey(opts: Options, change: Change, key: string): Change {\n    const { value } = change;\n\n    const pos = TablePosition.create(opts, value.document, key);\n    const { table } = pos;\n\n    const colIndex = pos.getColumnIndex();\n    \n    const rows = table.nodes;\n\n    // Remove the cell from every row\n    if (pos.getWidth() > 1) {\n        change.withoutNormalizing(() => {\n        rows.forEach(row => {\n            const cell = row.nodes.get(colIndex);\n                change.removeNodeByKey(cell.key);\n            });\n        });\n    } else {\n        // If last column, clear text in cells instead\n        rows.forEach(row => {\n            row.nodes.forEach(cell => {\n                cell.nodes.forEach(() => clearCell(opts, change, cell));\n            });\n        });\n    }\n\n    // this will also invalidate the selection - move it to the first cell\n    // change.moveToRangeOfNode(rows.first().nodes.first());\n\n    // Replace the table\n    return change;\n}\n\nexport default removeColumnByKey;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport removeColumnByKey from './removeColumnByKey';\n\nimport type Options from '../options';\n\n/**\n * Delete current column in a table\n */\nfunction removeColumn(opts: Options, change: Change, at: number): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    let columnKey;\n    if (typeof at === 'undefined') {\n        columnKey = pos.cell.key;\n    } else {\n        columnKey = pos.row.nodes.get(at).key;\n    }\n\n    return removeColumnByKey(opts, change, columnKey);\n}\n\nexport default removeColumn;\n","// @flow\nimport { Block, Text } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Delete the whole table at the given node key\n */\nfunction removeTableByKey(opts: Options, editor, key: string): * {\n    const { value } = editor;\n\n    const pos = TablePosition.create(opts, value.document, key);\n    const { table } = pos;\n    const { document } = editor.value;\n    let nextFocusBlock = null;\n    let shouldCollapseToEnd = false;\n\n    const nextBlock = editor.value.document.getNextBlock(table.key);\n    if (nextBlock) {\n        nextFocusBlock = nextBlock;\n    } else {\n        const prevBlock = editor.value.document.getPreviousBlock(table.key);\n        if (prevBlock) {\n            nextFocusBlock = prevBlock;\n            shouldCollapseToEnd = true;\n        } else if (opts.exitBlockType) {\n            nextFocusBlock = Block.create({\n                type: opts.exitBlockType,\n                nodes: [Text.create('')],\n            });\n            const tableParent = document.getParent(table.key);\n            const insertionIndex = tableParent.nodes.indexOf(table) + 1;\n            editor.insertNodeByKey(\n                tableParent.key,\n                insertionIndex,\n                nextFocusBlock,\n            );\n        }\n    }\n\n    editor.removeNodeByKey(table.key);\n    if (!nextFocusBlock) {\n        return editor;\n    }\n    if (shouldCollapseToEnd) {\n        editor.moveToEndOfNode(nextFocusBlock).focus();\n    } else {\n        editor.moveToStartOfNode(nextFocusBlock).focus();\n    }\n    return editor;\n}\n\nexport default removeTableByKey;\n","// @flow\n\nimport type Options from '../options';\nimport removeTableByKey from './removeTableByKey';\n\n/**\n * Delete the whole table at position\n */\nfunction removeTable(opts: Options, editor) {\n    const { value } = editor;\n    const { selection } = value;\n\n    return removeTableByKey(opts, editor, selection.start.key);\n}\n\nexport default removeTable;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection by a {x,y} relative movement\n */\nfunction moveSelectionBy(\n    opts: Options,\n    change: Change,\n    x: number, //  Move horizontally by x\n    y: number // Move vertically by y\n): Change {\n    const { value } = change;\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    if (!pos.isInCell()) {\n        throw new Error('moveSelectionBy can only be applied in a cell');\n    }\n\n    const rowIndex = pos.getRowIndex();\n    const colIndex = pos.getColumnIndex();\n    const width = pos.getWidth();\n    const height = pos.getHeight();\n\n    const [absX, absY] = normPos(x + colIndex, y + rowIndex, width, height);\n    const isGoingUp = y < 0;\n\n    if (absX === -1) {\n        // Out of table\n        return change;\n    }\n\n    const { table } = pos;\n    const row = table.nodes.get(absY);\n    const cell = row.nodes.get(absX);\n\n    if (isGoingUp) {\n        change.moveToEndOfNode(cell);\n    } else {\n        change.moveToStartOfNode(cell);\n    }\n\n    return change;\n}\n\n/**\n * Normalize position in a table. If x is out of the row, update y accordingly.\n * Returns [-1, -1] if the new selection is out of table\n */\nfunction normPos(\n    x: number,\n    y: number,\n    width: number,\n    height: number\n): number[] {\n    if (x < 0) {\n        x = width - 1;\n        y -= 1;\n    }\n\n    if (y < 0) {\n        return [-1, -1];\n    }\n\n    if (x >= width) {\n        x = 0;\n        y += 1;\n    }\n\n    if (y >= height) {\n        return [-1, -1];\n    }\n\n    return [x, y];\n}\n\nexport default moveSelectionBy;\n","// @flow\nimport { type Editor } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection by a {x,y} relative movement\n */\nfunction moveSelectionOutOfTable(\n    opts: Options,\n    editor: Editor,\n    direction: number = 1 // Move down: +1, up: -1\n): Editor {\n    const { value } = editor;\n    const { selection, document } = value;\n    const pos = TablePosition.create(opts, document, selection.start.key);\n    \n    if (!pos.isInCell()) {\n        throw new Error('moveSelectionOutOfTable can only be applied in a cell');\n    }\n\n    const table = pos.table;\n\n    const isGoingUp = direction < 0;\n\n    if (isGoingUp) {\n        const previousNode = document.getPreviousBlock(table.key);\n        previousNode && editor.moveToEndOfNode(previousNode);\n    } else {\n        const nextNode = document.getNextBlock(table.key);\n        nextNode && editor.moveToStartOfNode(nextNode);\n    }\n\n    return editor;\n}\n\nexport default moveSelectionOutOfTable;\n","const CHILD_OBJECT_INVALID = 'child_object_invalid';\nconst CHILD_REQUIRED = 'child_required';\nconst CHILD_TYPE_INVALID = 'child_type_invalid';\nconst CHILD_UNKNOWN = 'child_unknown';\nconst FIRST_CHILD_OBJECT_INVALID = 'first_child_object_invalid';\nconst FIRST_CHILD_TYPE_INVALID = 'first_child_type_invalid';\nconst LAST_CHILD_OBJECT_INVALID = 'last_child_object_invalid';\nconst LAST_CHILD_TYPE_INVALID = 'last_child_type_invalid';\nconst NODE_DATA_INVALID = 'node_data_invalid';\nconst NODE_IS_VOID_INVALID = 'node_is_void_invalid';\nconst NODE_MARK_INVALID = 'node_mark_invalid';\nconst NODE_TEXT_INVALID = 'node_text_invalid';\nconst PARENT_INVALID = 'parent_invalid';\nconst PARENT_TYPE_INVALID = 'parent_type_invalid';\n\nexport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_TEXT_INVALID,\n  PARENT_INVALID,\n  PARENT_TYPE_INVALID,\n};\n","// @flow\n\nimport { type Change } from 'slate';\nimport {\n    CHILD_OBJECT_INVALID,\n    CHILD_TYPE_INVALID,\n    PARENT_TYPE_INVALID,\n} from './slate-schema-violations';\nimport { createCell } from '../utils';\nimport type Options from '../options';\n\n/*\n * Returns a schema definition for the plugin\n */\nfunction schema(opts: Options): Object {\n    return {\n        blocks: {\n            [opts.typeTable]: {\n                nodes: [{ match: { type: opts.typeRow } }],\n                parent: [{object: 'document'}],\n                normalize: (editor, {code, node}) => {\n                  if (code === 'parent_object_invalid') {\n                    editor.insertText(node.text);\n                    editor.removeNodeByKey(node.key);\n                  }\n                }\n            },\n            [opts.typeRow]: {\n                nodes: [{ match: { type: opts.typeCell } }],\n                parent: { type: opts.typeTable },\n                normalize(change: Change, error) {\n                    switch (error.code) {\n                        case CHILD_TYPE_INVALID:\n                            return onlyCellsInRow(opts, change, error);\n                        case PARENT_TYPE_INVALID:\n                            return rowOnlyInTable(opts, change, error);\n                    }\n                },\n            },\n            [opts.typeCell]: {\n                nodes: [{ match: { object: 'block' } }],\n                parent: { type: opts.typeRow },\n                normalize(change: Change, error) {\n                    switch (error.code) {\n                        case CHILD_OBJECT_INVALID:\n                            return onlyBlocksInCell(opts, change, error.node);\n                        case PARENT_TYPE_INVALID:\n                            return cellOnlyInRow(opts, change, error);\n                    }\n                },\n            },\n        },\n    };\n}\n\n/*\n * A row's children must be cells.\n * If they're not then we wrap them within a cell.\n */\nfunction onlyCellsInRow(opts: Options, change: Change, error) {\n    const cell = createCell(opts, []);\n    const index = error.node.nodes.findIndex(\n        child => child.key === error.child.key,\n    );\n\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(error.node.key, index, cell);\n        change.moveNodeByKey(error.child.key, cell.key, 0);\n    });\n}\n\n/*\n * Rows can't live outside a table, if one is found then we wrap it within a table.\n */\nfunction rowOnlyInTable(opts: Options, change: Change, error: Object) {\n    return change.wrapBlockByKey(error.node.key, opts.typeTable);\n}\n\n/*\n * A cell's children must be \"block\"s.\n * If they're not then we wrap them within a block with a type of opts.typeContent\n */\nfunction onlyBlocksInCell(opts: Options, change: Change, node: Object) {\n    change.wrapBlockByKey(node.nodes.first().key, opts.typeContent);\n    const wrapper = change.value.document.getDescendant(node.key).nodes.first();\n\n    // Add in the remaining items\n    node.nodes\n        .rest()\n        .forEach((child, index) =>\n            change.moveNodeByKey(child.key, wrapper.key, index + 1),\n        );\n\n    return change;\n    /*     const block = Block.create({\n        type: opts.typeContent,\n    });\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(error.node.key, 0, block);\n        const inlines = error.node.nodes.filter(\n            node => node.object !== 'block',\n        );\n        inlines.forEach((inline, index) => {\n            change.moveNodeByKey(inline.key, block.key, index);\n        });\n    }); */\n}\n\n/*\n * Cells can't live outside a row, if one is found then we wrap it within a row.\n */\nfunction cellOnlyInRow(opts: Options, change: Change, error: Object) {\n    return change.wrapBlockByKey(error.node.key, opts.typeRow);\n}\n\nexport default schema;\n","// @flow\n\nimport type Options from '../options';\nimport { createCell } from '../utils';\n\n/*\n * Ensure each row has the same number of columns.\n */\nfunction normalizeNode(opts: Options) {\n    const isRow = node => node.type === opts.typeRow;\n    const countNodes = row => row.nodes.size;\n\n    return (node, editor, next) => {\n        if (node.type !== opts.typeTable) {\n            return next();\n        }\n        const rows = node.nodes.filter(isRow);\n        const maxColumns = Math.max(\n            // Minimum 1 column\n            1,\n            rows.map(countNodes).max(),\n        );\n        const rowsMissingColumns = rows.filter(\n            row => countNodes(row) < maxColumns,\n        );\n\n        if (rowsMissingColumns.isEmpty()) {\n            return next();\n        }\n\n        return change => {\n            change.withoutNormalizing(() => {\n                rowsMissingColumns.forEach(row => {\n                    const numberOfCellsToAdd = maxColumns - row.nodes.size;\n                    const cells = Array.from({\n                        length: numberOfCellsToAdd,\n                    }).map(() => createCell(opts));\n                    cells.forEach(cell =>\n                        change.insertNodeByKey(row.key, row.nodes.size, cell),\n                    );\n                });\n            });\n        };\n    };\n}\n\nexport default normalizeNode;\n","// @flow\nimport {\n    insertTable,\n    insertTableFragmentAtRange,\n    insertRow,\n    removeRow,\n    insertColumn,\n    removeColumn,\n    removeTable,\n    clearCell,\n    moveSelection,\n    moveSelectionBy,\n    moveSelectionOutOfTable,\n    removeRowByKey,\n    removeColumnByKey,\n    removeTableByKey\n} from './changes';\nimport {\n    isSelectionInTable,\n    isSelectionOutOfTable,\n    getPosition,\n    getPositionByKey,\n    createCell,\n    createRow,\n    createTable,\n    forEachCells,\n    getCellsAtRow,\n    getCellsAtColumn,\n    getCopiedFragment\n} from './utils';\nimport { schema, normalizeNode } from './validation';\n\nimport Options, { type OptionsFormat } from './options';\n\n/**\n * Returns the core of the plugin, limited to the validation and normalization\n * part of `slate-edit-table`, and utils.\n *\n * Import this directly: `import EditTable from 'slate-edit-table/lib/core'`\n * if you don't care about behavior/rendering and you\n * are only manipulating `Slate.Values` without rendering them.\n * That way you do not depend on `slate-react`.\n */\nfunction core(optionsParam: Options | OptionsFormat): Object {\n    const opts = new Options(optionsParam);\n\n    return {\n        schema: schema(opts),\n        normalizeNode: normalizeNode(opts),\n\n        queries: {\n            isSelectionInTable: isSelectionInTable.bind(null, opts),\n            isSelectionOutOfTable: isSelectionOutOfTable.bind(null, opts),\n            getPosition: getPosition.bind(null, opts),\n            getPositionByKey: getPositionByKey.bind(null, opts),\n            createCell: createCell.bind(null, opts),\n            createRow: createRow.bind(null, opts),\n            createTable: createTable.bind(null, opts),\n            forEachCells: forEachCells.bind(null, opts),\n            getCellsAtRow: getCellsAtRow.bind(null, opts),\n            getCellsAtColumn: getCellsAtColumn.bind(null, opts),\n            getCopiedFragment: getCopiedFragment.bind(null, opts)\n        },\n\n        commands: {\n            insertTable: insertTable.bind(null, opts),\n            insertTableFragmentAtRange: insertTableFragmentAtRange.bind(\n                null,\n                opts\n            ),\n            clearCell: clearCell.bind(null, opts),\n            removeRowByKey: removeRowByKey.bind(null, opts),\n            removeColumnByKey: removeColumnByKey.bind(null, opts),\n            removeTableByKey: removeTableByKey.bind(null, opts),\n            insertRow: bindAndScopeChange(opts, insertRow),\n            removeRow: bindAndScopeChange(opts, removeRow),\n            insertColumn: bindAndScopeChange(opts, insertColumn),\n            removeColumn: bindAndScopeChange(opts, removeColumn),\n            removeTable: bindAndScopeChange(opts, removeTable),\n            moveSelection: bindAndScopeChange(opts, moveSelection),\n            moveSelectionBy: bindAndScopeChange(opts, moveSelectionBy),\n            moveSelectionOutOfTable: bindAndScopeChange(opts, moveSelectionOutOfTable)\n        }\n    };\n}\n\n/**\n * Bind a change to given options, and scope it to act only inside a table\n */\nfunction bindAndScopeChange(opts: Options, fn: *): * {\n    return (editor, ...args) => {\n        if (!editor.isSelectionInTable()) {\n            return editor;\n        }\n\n        // $FlowFixMe\n        return fn(...[opts, editor].concat(args));\n    };\n}\n\nexport default core;\n","// @flow\nimport {type Change} from 'slate';\n\nimport type Options from '../options';\nimport {TablePosition} from '../utils';\nimport {insertRow} from '../changes';\n\n/**\n * Insert a new row when pressing \"Enter\"\n */\nfunction onEnter(event: *, editor: *, opts: Options, next: *): void | Change {\n  event.preventDefault();\n  const {selection, document} = editor.value;\n  const pos = TablePosition.create(opts, document, selection.start.key);\n  const isAtEdgeOfCell =\n    selection.focus.isAtStartOfNode(pos.cell) ||\n    selection.focus.isAtEndOfNode(pos.cell);\n\n  if (!opts.insertRowOnEnter || !isAtEdgeOfCell) {\n    return next();\n  }\n\n  if (event.shiftKey) {\n    return editor.splitBlock().setBlocks({type: opts.typeContent, data: {}});\n  }\n\n  return insertRow(opts, editor);\n}\n\nexport default onEnter;\n","// @flow\nimport { Block, Text, type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Exit the current table, by inserting a default block after the table.\n */\nfunction onModEnter(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    if (!value.selection.isCollapsed) {\n        return next();\n    }\n\n    event.preventDefault();\n\n    const exitBlock = Block.create({\n        type: opts.exitBlockType,\n        nodes: [Text.create('')]\n    });\n\n    const table = TablePosition.create(opts, value.document, value.selection.start.key)\n        .table;\n    const tableParent = value.document.getParent(table.key);\n    const insertionIndex = tableParent.nodes.indexOf(table) + 1;\n\n    return editor\n        .insertNodeByKey(tableParent.key, insertionIndex, exitBlock)\n        .moveToStartOfNode(exitBlock);\n}\n\nexport default onModEnter;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport { moveSelectionBy, insertRow } from '../changes';\nimport type Options from '../options';\n\n/**\n * Select all text of current block.\n */\nfunction selectAllText(editor)  {\n    const { value } = editor;\n    const { startBlock } = value;\n\n    return editor.moveTo(0).moveFocusForward(startBlock.text.length);\n}\n\n/**\n * Pressing \"Tab\" moves the cursor to the next cell\n * and select the whole text\n */\nfunction onTab(\n    event: *,\n    editor: *,\n    opts: Options\n): void | Change {\n    event.preventDefault();\n    const { value } = editor;\n    const direction = event.shiftKey ? -1 : +1;\n\n    // Create new row if needed\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    if (pos.isFirstCell() && direction === -1) {\n        insertRow(opts, editor, 0);\n    } else if (pos.isLastCell() && direction === 1) {\n        insertRow(opts, editor);\n    }\n\n    // Move back to initial cell (insertRow moves selection automatically).\n    editor.select(selection);\n\n    // Move\n    moveSelectionBy(opts, editor, direction, 0);\n\n    // Select all cell.\n    return selectAllText(editor);\n}\n\nexport default onTab;\n","// @flow\nimport { type Change } from 'slate';\n\nimport type Options from '../options';\nimport { clearCell } from '../changes';\n\nfunction onBackspace(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    const { startBlock, selection, endBlock, document} = value;\n    const { isCollapsed } = selection;\n\n    const startCell = document.getClosest(startBlock.key, opts.isCell);\n    const endCell = document.getClosest(endBlock.key, opts.isCell);\n\n    const startPath = startCell.getPath(selection.start.key);\n    // If a cursor is collapsed at the start of the first block, do nothing\n    if (selection.start.offset === 0 && isCollapsed && startPath && startPath.every(index => index === 0)) {\n        if (editor.isVoid(startBlock)) {\n            // Delete the block normally if it is a void block\n            return next();\n        }\n\n        event.preventDefault();\n        return editor;\n    }\n\n    // If \"normal\" deletion, we continue\n    if (startCell === endCell) {\n        return next();\n    }\n\n    // If cursor is between multiple blocks,\n    // we clear the content of the cells.\n    event.preventDefault();\n\n    const { blocks } = value;\n\n    // Get all cells that contains the selection\n    const cells = blocks\n        .map(\n            node =>\n                node.type === opts.typeCell\n                    ? node\n                    : document.getClosest(\n                          node.key,\n                          a => a.type === opts.typeCell\n                      )\n        )\n        .toSet();\n\n    // If the cursor is at the very end of the first cell, ignore it.\n    // If the cursor is at the very start of the last cell, ignore it.\n    // This behavior is to compensate hanging selection behaviors:\n    // https://github.com/ianstormtaylor/slate/pull/1605\n    const ignoreFirstCell = value.selection\n        .moveToStart()\n        .anchor.isAtEndOfNode(cells.first());\n    const ignoreLastCell = value.selection\n        .moveToEnd()\n        .anchor.isAtStartOfNode(cells.last());\n\n    let cellsToClear = cells;\n    if (ignoreFirstCell) {\n        cellsToClear = cellsToClear.rest();\n    }\n    if (ignoreLastCell) {\n        cellsToClear = cellsToClear.butLast();\n    }\n\n    // Clear all the selection\n    cellsToClear.forEach(cell => clearCell(opts, editor, cell));\n\n    // Update the selection properly, and avoid reset of selection\n    const updatedStartCell = editor.value.document.getDescendant(\n        cellsToClear.first().key\n    );\n    return editor.moveToStartOfNode(updatedStartCell);\n}\n\nexport default onBackspace;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport { moveSelectionBy, moveSelectionOutOfTable } from '../changes';\nimport type Options from '../options';\n\nfunction onUpDown(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    const direction = event.key === 'ArrowUp' ? -1 : +1;\n    const pos = TablePosition.create(opts, value.document, value.selection.start.key);\n\n    if (\n        (pos.isFirstRow() && direction === -1 && pos.isTopOfCell()) ||\n        (pos.isLastRow() && direction === +1 && pos.isBottomOfCell())\n    ) {\n      if (opts.edgeRowExitOnDirection) {\n        event.preventDefault();\n        return moveSelectionOutOfTable(opts, editor, direction);\n      } else {\n        // Let the default behavior move out of the table\n        return next();\n      }\n    }\n\n    if (direction === -1 && !pos.isTopOfCell()) {\n        return next();\n    }\n\n    if (direction === +1 && !pos.isBottomOfCell()) {\n        return next();\n    }\n\n    event.preventDefault();\n\n    moveSelectionBy(opts, editor, 0, direction);\n\n    return editor;\n}\n\nexport default onUpDown;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { moveSelectionOutOfTable } from '../changes';\nimport type Options from '../options';\n\nfunction onUpDown(\n    event: *,\n    editor: *,\n    opts: Options,\n): void | Change {\n    const direction = event.key === 'ArrowUp' ? -1 : +1;\n\n    event.preventDefault();\n\n    moveSelectionOutOfTable(opts, editor, direction);\n\n    return editor;\n}\n\nexport default onUpDown;\n","// @flow\n\nimport type Options from '../options';\n\nimport onEnter from './onEnter';\nimport onModEnter from './onModEnter';\nimport onTab from './onTab';\nimport onBackspace from './onBackspace';\nimport onUpDown from './onUpDown';\nimport onModUpDown from './onModUpDown';\n\nconst KEY_ENTER = 'Enter';\nconst KEY_TAB = 'Tab';\nconst KEY_BACKSPACE = 'Backspace';\nconst KEY_DOWN = 'ArrowDown';\nconst KEY_UP = 'ArrowUp';\n\n/**\n * User is pressing a key in the editor\n */\nfunction onKeyDown(\n    opts: Options,\n    event: *,\n    editor: *,\n    next: *\n): void | any {\n    // Only handle events in cells\n    if (!editor.isSelectionInTable()) {\n        return next();\n    }\n\n    // Build arguments list\n    const args = [event, editor, opts, next];\n\n    switch (event.key) {\n        case KEY_ENTER:\n            if (event.metaKey && opts.exitBlockType) {\n                return onModEnter(...args);\n            }\n            return onEnter(...args);\n        case KEY_TAB:\n            return onTab(...args);\n        case KEY_BACKSPACE:\n            return onBackspace(...args);\n        case KEY_DOWN:\n        case KEY_UP:\n          if (event.metaKey) {\n            return onModUpDown(...args);\n          }\n          return onUpDown(...args);\n        default:\n            return next();\n    }\n}\n\nexport default onKeyDown;\n","// @flow\n\nimport type Options from '../options';\nimport {Editor, Value} from 'slate';\nimport getCopiedFragment from '../utils/getCopiedFragment';\nimport {cloneFragment} from 'slate-react';\n\nfunction onCopy(opts: Options, event: *, editor: *, next: *): void | any {\n  if (!editor.isSelectionInTable()) {\n    return next();\n  }\n\n  const fragment = getCopiedFragment(opts, editor.value);\n\n  if (!fragment) return next();\n\n  const tempEditor = new Editor({\n    value: Value.fromJSON({document: fragment}),\n  });\n  tempEditor.moveToRangeOfDocument();\n\n  cloneFragment(event, tempEditor);\n}\n\nexport default onCopy;\n","/* @flow */\nimport Options, { type OptionsFormat } from './options';\nimport type { TablePosition as _TablePosition } from './utils/TablePosition';\nimport core from './core';\nimport { onKeyDown, onCopy} from './handlers';\n\n/**\n *  Returns the full plugin object (behavior + rendering + schema)\n */\nfunction EditTable(\n    // The plugin options\n    optionsParam?: OptionsFormat\n): Object {\n    const opts = new Options(optionsParam || {});\n    const corePlugin = core(opts);\n\n    return {\n        ...corePlugin,\n        onKeyDown: onKeyDown.bind(null, opts),\n        onCopy: onCopy.bind(null, opts),\n    };\n}\n\nexport type TablePosition = _TablePosition;\n\nexport default EditTable;\n"],"names":["Options","isCell","node","object","type","typeCell","Record","typeTable","typeRow","typeContent","exitBlockType","insertRowOnEnter","edgeRowExitOnDirection","createCell","opts","nodes","Block","create","createEmptyContent","Text","createRow","columns","getCellContent","cellNodes","Range","map","i","undefined","toJS","createList","createTable","rows","rowNodes","bind","TablePosition","Boolean","cellBlock","rowBlock","tableBlock","getPath","key","every","index","ancestors","getAncestors","next","get","indexOf","size","table","cells","first","row","findIndex","x","cell","isFirstRow","isFirstColumn","isLastRow","isLastColumn","getRowIndex","getHeight","getColumnIndex","getWidth","Error","containerNode","getDescendant","push","findLast","p","contentBlock","skipUntil","ancestor","skip","getPosition","editor","value","selection","start","document","getPositionByKey","isRangeInTable","range","end","startPosition","endPosition","isInTable","isSelectionInTable","isSelectionOutOfTable","forEachCells","fn","forEach","rowIndex","columnIndex","getCellsAtRow","getCellsAtColumn","getCopiedFragment","baseFragment","fragment","copiedCell","getFirstText","n","merge","insertTable","change","insertBlock","insertRow","at","getRow","pos","newRow","insertNodeByKey","moveToEndOfNode","moveSelection","y","isInCell","moveToStartOfNode","insertColumn","getCell","withoutNormalizing","newCell","insertTableFragmentAtRange","insertedTable","targetPosition","fragmentRows","fragmentHeight","fragmentWidth","missingWidth","missingHeight","Array","fill","existingTable","fragmentRow","fragmentRowIndex","fragmentColumnIndex","existingCell","replaceNodeByKey","lastPastedCell","last","clearCell","newBlock","removeNodeByKey","removeRowByKey","removeRow","rowKey","removeColumnByKey","colIndex","removeColumn","columnKey","removeTableByKey","nextFocusBlock","shouldCollapseToEnd","nextBlock","getNextBlock","prevBlock","getPreviousBlock","tableParent","getParent","insertionIndex","focus","removeTable","moveSelectionBy","width","height","normPos","absX","absY","isGoingUp","moveSelectionOutOfTable","direction","previousNode","nextNode","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","PARENT_TYPE_INVALID","schema","blocks","match","parent","normalize","code","insertText","text","error","onlyCellsInRow","rowOnlyInTable","onlyBlocksInCell","cellOnlyInRow","child","moveNodeByKey","wrapBlockByKey","wrapper","rest","normalizeNode","isRow","countNodes","filter","maxColumns","Math","max","rowsMissingColumns","isEmpty","numberOfCellsToAdd","from","length","core","optionsParam","queries","commands","bindAndScopeChange","args","concat","onEnter","event","preventDefault","isAtEdgeOfCell","isAtStartOfNode","isAtEndOfNode","shiftKey","splitBlock","setBlocks","data","onModEnter","isCollapsed","exitBlock","selectAllText","startBlock","moveTo","moveFocusForward","onTab","isFirstCell","isLastCell","select","onBackspace","endBlock","startCell","getClosest","endCell","startPath","offset","isVoid","a","toSet","ignoreFirstCell","moveToStart","anchor","ignoreLastCell","moveToEnd","cellsToClear","butLast","updatedStartCell","onUpDown","isTopOfCell","isBottomOfCell","KEY_ENTER","KEY_TAB","KEY_BACKSPACE","KEY_DOWN","KEY_UP","onKeyDown","metaKey","onModUpDown","onCopy","tempEditor","Editor","Value","fromJSON","moveToRangeOfDocument","cloneFragment","EditTable","corePlugin"],"mappings":"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"}