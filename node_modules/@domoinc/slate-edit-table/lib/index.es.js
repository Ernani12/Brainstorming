import { Record, Range } from 'immutable';
import { Block, Text, Editor, Value } from 'slate';
import { cloneFragment } from 'slate-react';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * The plugin options
 */
var Options =
/*#__PURE__*/
function (_Record) {
  _inherits(Options, _Record);

  function Options() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Options);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Options)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _this.isCell = function (node) {
      return node.object == 'block' && node.type == _this.typeCell;
    };

    return _this;
  }

  return Options;
}(Record({
  typeTable: 'table',
  typeRow: 'table_row',
  typeCell: 'table_cell',
  typeContent: 'paragraph',
  exitBlockType: 'paragraph',
  insertRowOnEnter: true,
  edgeRowExitOnDirection: false
}));

/**
 * Create a new cell
 */
function createCell(opts, nodes) {
  return Block.create({
    type: opts.typeCell,
    nodes: nodes || [createEmptyContent(opts)]
  });
}
/**
 * Create a new default content block
 */


function createEmptyContent(opts) {
  return Block.create({
    type: opts.typeContent,
    nodes: [Text.create()]
  });
}

/**
 * Create a new row block
 */

function createRow(opts, columns, getCellContent) {
  var cellNodes = Range(0, columns).map(function (i) {
    return createCell(opts, getCellContent ? getCellContent(i) : undefined);
  }).toJS();
  return Block.create({
    type: opts.typeRow,
    nodes: Block.createList(cellNodes)
  });
}

/**
 * Create a table
 */

function createTable(opts, columns, rows, getCellContent) {
  var rowNodes = Range(0, rows).map(function (i) {
    return createRow(opts, columns, getCellContent ? getCellContent.bind(null, i) : undefined);
  }).toJS();
  return Block.create({
    type: opts.typeTable,
    nodes: Block.createList(rowNodes)
  });
}

var TablePosition =
/*#__PURE__*/
function (_Record) {
  _inherits(TablePosition, _Record);

  function TablePosition() {
    _classCallCheck(this, TablePosition);

    return _possibleConstructorReturn(this, _getPrototypeOf(TablePosition).apply(this, arguments));
  }

  _createClass(TablePosition, [{
    key: "isInCell",

    /**
     * Check to see if this position is within a cell
     */
    value: function isInCell() {
      return Boolean(this.cellBlock);
    }
    /**
     * Check to see if this position is within a row
     */

  }, {
    key: "isInRow",
    value: function isInRow() {
      return Boolean(this.rowBlock);
    }
    /**
     * Check to see if this position is within a table
     */

  }, {
    key: "isInTable",
    value: function isInTable() {
      return Boolean(this.tableBlock);
    }
    /**
     * Check to see if this position is at the top of the cell.
     */

  }, {
    key: "isTopOfCell",
    value: function isTopOfCell() {
      var cellBlock = this.cellBlock,
          node = this.node;

      if (!cellBlock || !node) {
        return false;
      }

      return cellBlock.getPath(node.key).every(function (index) {
        return index === 0;
      });
    }
    /**
     * Check to see if this position is at the bottom of the cell.
     */

  }, {
    key: "isBottomOfCell",
    value: function isBottomOfCell() {
      var node = this.node,
          cellBlock = this.cellBlock;

      if (!node || !cellBlock) {
        return false;
      }

      var ancestors = cellBlock.getAncestors(node.key);
      return ancestors.every(function (node, index) {
        var next = ancestors.get(index + 1);
        if (!next) return true;
        return node.nodes.indexOf(next) === node.nodes.size - 1;
      });
    }
    /**
     * Get count of columns
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      var table = this.table;
      var rows = table.nodes;
      var cells = rows.first().nodes;
      return cells.size;
    }
    /**
     * Get count of rows
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      var table = this.table;
      var rows = table.nodes;
      return rows.size;
    }
    /**
     * Get index of current row in the table.
     */

  }, {
    key: "getRowIndex",
    value: function getRowIndex() {
      var table = this.table,
          row = this.row;
      var rows = table.nodes;
      return rows.findIndex(function (x) {
        return x === row;
      });
    }
    /**
     * Get index of current column in the row.
     */

  }, {
    key: "getColumnIndex",
    value: function getColumnIndex() {
      var row = this.row,
          cell = this.cell;
      var cells = row.nodes;
      return cells.findIndex(function (x) {
        return x === cell;
      });
    }
    /**
     * True if on first cell of the table
     */

  }, {
    key: "isFirstCell",
    value: function isFirstCell() {
      return this.isFirstRow() && this.isFirstColumn();
    }
    /**
     * True if on last cell of the table
     */

  }, {
    key: "isLastCell",
    value: function isLastCell() {
      return this.isLastRow() && this.isLastColumn();
    }
    /**
     * True if on first row
     */

  }, {
    key: "isFirstRow",
    value: function isFirstRow() {
      return this.getRowIndex() === 0;
    }
    /**
     * True if on last row
     */

  }, {
    key: "isLastRow",
    value: function isLastRow() {
      return this.getRowIndex() === this.getHeight() - 1;
    }
    /**
     * True if on first column
     */

  }, {
    key: "isFirstColumn",
    value: function isFirstColumn() {
      return this.getColumnIndex() === 0;
    }
    /**
     * True if on last column
     */

  }, {
    key: "isLastColumn",
    value: function isLastColumn() {
      return this.getColumnIndex() === this.getWidth() - 1;
    }
  }, {
    key: "table",
    get: function get() {
      if (!this.tableBlock) {
        throw new Error('Not in a table');
      }

      return this.tableBlock;
    }
  }, {
    key: "row",
    get: function get() {
      if (!this.rowBlock) {
        throw new Error('Not in a row');
      }

      return this.rowBlock;
    }
  }, {
    key: "cell",
    get: function get() {
      if (!this.cellBlock) {
        throw new Error('Not in a cell');
      }

      return this.cellBlock;
    }
  }], [{
    key: "create",
    // Block container for the table

    /*::tableBlock: ?Block;*/
    // Block for current row

    /*::rowBlock: ?Block;*/
    // Block for current cell

    /*::cellBlock: ?Block;*/
    // Current content block in the cell

    /*::contentBlock: ?Block;*/

    /**
     * Create a new instance of a TablePosition from a Slate document
     * and a node key.
     */
    value: function create(opts, containerNode, key) {
      var node = containerNode.getDescendant(key);
      var ancestors = containerNode.getAncestors(key).push(node);
      var tableBlock = ancestors.findLast(function (p) {
        return p.type === opts.typeTable;
      });
      var rowBlock = ancestors.findLast(function (p) {
        return p.type === opts.typeRow;
      });
      var cellBlock = ancestors.findLast(function (p) {
        return p.type === opts.typeCell;
      });
      var contentBlock = ancestors.skipUntil(function (ancestor) {
        return ancestor === cellBlock;
      }).skip(1).first();
      return new TablePosition({
        tableBlock: tableBlock,
        rowBlock: rowBlock,
        cellBlock: cellBlock,
        contentBlock: contentBlock,
        node: node
      });
    }
  }]);

  return TablePosition;
}(Record({
  tableBlock: null,
  rowBlock: null,
  cellBlock: null,
  contentBlock: null,
  node: null
}));

/**
 * The position of the selection start block, in the current table
 */

function getPosition(opts, editor) {
  var value = editor.value;
  if (!value.selection.start || !value.selection.start.key) return new TablePosition();
  return TablePosition.create(opts, value.document, value.selection.start.key);
}

/*
 * The position of a particular node, in the current table
 */

function getPositionByKey(opts, editor, containerNode, // Key of the node in desired position
key) {
  return TablePosition.create(opts, containerNode, key);
}

/**
 * True if the given range is inside one table
 */
function isRangeInTable(opts, node, range) {
  var start = range.start,
      end = range.end;
  var startPosition = TablePosition.create(opts, node, start.key);
  var endPosition = TablePosition.create(opts, node, end.key); // Only handle events in tables

  if (!startPosition.isInTable() || !endPosition.isInTable()) {
    return false;
  } // Inside the same table


  return startPosition.table === endPosition.table;
}

/**
 * Is the selection in a table
 */

function isSelectionInTable(opts, editor) {
  var value = editor.value;
  var selection = value.selection;
  if (!selection.start.key) return false;
  return isRangeInTable(opts, value.document, value.selection);
}

/**
 * Are the selection start and end outside a table.
 */
function isSelectionOutOfTable(opts, editor) {
  var value = editor.value;
  var selection = value.selection;
  if (!selection.start.key) return false;
  var startPosition = TablePosition.create(opts, value.document, selection.start.key);
  var endPosition = TablePosition.create(opts, value.document, selection.end.key); // Only handle events in tables

  return !startPosition.isInTable() && !endPosition.isInTable();
}

/**
 * Run the given function against each cells of the table
 */
function forEachCells(opts, // The table
table, fn) {
  return table.nodes.forEach(function (row, rowIndex) {
    return row.nodes.forEach(function (cell, columnIndex) {
      return fn(cell, rowIndex, columnIndex);
    });
  });
}

/**
 * Returns the list of cells at the given row index
 */
function getCellsAtRow(opts, editor, table, rowIndex) {
  return table.nodes.get(rowIndex).nodes;
}

/**
 * Returns the list of cells at the given column index
 */
function getCellsAtColumn(opts, editor, table, columnIndex) {
  return table.nodes.map(function (row) {
    return row.nodes.get(columnIndex);
  });
}

function getCopiedFragment(opts, value) {
  var selection = value.selection,
      document = value.document;
  var startPosition = TablePosition.create(opts, document, selection.start.key);
  var endPosition = TablePosition.create(opts, document, selection.end.key); // Fragment as it would be copied by Slate

  var baseFragment = value.fragment;

  if (endPosition.cell === startPosition.cell) {
    // The selection is inside a single cell. Only copy the content of that cell
    var copiedCell = baseFragment.getAncestors(baseFragment.getFirstText().key).findLast(function (n) {
      return n.type === opts.typeCell;
    });
    return baseFragment.merge({
      nodes: copiedCell.nodes
    });
  }
}

/**
 * Insert a new table
 */
function insertTable(opts, change) {
  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
  var getCellContent = arguments.length > 4 ? arguments[4] : undefined;
  var value = change.value;
  if (!value.selection.start.key) return change; // Create the table node

  var table = createTable(opts, columns, rows, getCellContent);
  return change.insertBlock(table);
}

/**
 * Insert a new row in current table
 */
function insertRow(opts, change, at, // row index
getRow) // Generate the row yourself
{
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);
  var table = pos.table; // Create a new row with the right count of cells

  var columns = table.nodes.get(0).nodes.size;
  var newRow = getRow ? getRow(columns) : createRow(opts, columns);

  if (typeof at === 'undefined') {
    at = pos.getRowIndex() + 1;
  }

  return change.insertNodeByKey(table.key, at, newRow).moveToEndOfNode(newRow.nodes.get(pos.getColumnIndex()));
}

/**
 * Move selection to {x,y}
 */
function moveSelection(opts, change, x, y) {
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);

  if (!pos.isInCell()) {
    throw new Error('moveSelection can only be applied from within a cell');
  }

  var table = pos.table;
  var row = table.nodes.get(y);
  var cell = row.nodes.get(x);
  return change.moveToStartOfNode(cell);
}

/**
 * Insert a new column in current table
 */
function insertColumn(opts, change, at, // Column index
getCell) {
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);
  var table = pos.table;
  var columnIndex = typeof at === 'undefined' ? pos.getColumnIndex() + 1 : at; // Insert the new cell

  change.withoutNormalizing(function () {
    table.nodes.forEach(function (row, rowIndex) {
      var newCell = getCell ? getCell(columnIndex, rowIndex) : createCell(opts);
      change.insertNodeByKey(row.key, columnIndex, newCell);
    });
  }); // Update the selection (not doing can break the undo)

  return moveSelection(opts, change, pos.getColumnIndex() + 1, pos.getRowIndex());
}

/**
 * Used when pasting a fragment of table into another one
 */
function insertTableFragmentAtRange(opts, change, range, // This fragment should contain only one table,
fragment) {
  var insertedTable = fragment.nodes.first();

  if (!(fragment.nodes.size === 1 && insertedTable && insertedTable.type === opts.typeTable)) {
    throw new Error('Expected to insert a fragment containing one table');
  }

  var value = change.value;
  var targetPosition = TablePosition.create(opts, value.document, value.selection.start.key);
  var fragmentRows = insertedTable.nodes;
  var fragmentHeight = fragmentRows.size;
  var fragmentWidth = fragmentRows.first().nodes.size; // Insert columns and rows to accomodate the incoming pasted cells

  var missingWidth = fragmentWidth + targetPosition.getColumnIndex() - targetPosition.getWidth();
  var missingHeight = fragmentHeight + targetPosition.getRowIndex() - targetPosition.getHeight();

  if (missingWidth > 0) {
    // Add columns
    Array(missingWidth).fill().forEach(function () {
      insertColumn(opts, change, targetPosition.getWidth());
    });
  }

  if (missingHeight > 0) {
    // Add rows
    Array(missingHeight).fill().forEach(function () {
      insertRow(opts, change, targetPosition.getHeight());
    });
  } // Patch the inserted table over the target table, overwritting the cells


  var existingTable = change.value.document.getDescendant(targetPosition.table.key);
  change.withoutNormalizing(function () {
    fragmentRows.forEach(function (fragmentRow, fragmentRowIndex) {
      fragmentRow.nodes.forEach(function (newCell, fragmentColumnIndex) {
        var existingCell = existingTable.nodes.get(targetPosition.getRowIndex() + fragmentRowIndex).nodes.get(targetPosition.getColumnIndex() + fragmentColumnIndex);
        change.replaceNodeByKey(existingCell.key, newCell);
      });
    });
  });
  var lastPastedCell = fragmentRows.last().nodes.last();
  return change.moveToEndOfNode(lastPastedCell);
}

/**
 * Clear the content of the given cell
 */
function clearCell(opts, change, cell) {
  var newBlock = Block.create({
    type: opts.typeContent
  });
  var nodes = cell.nodes; // Insert a new empty node

  change.withoutNormalizing(function () {
    change.insertNodeByKey(cell.key, 0, newBlock);
  }); // Remove all previous nodes

  nodes.forEach(function (node) {
    change.removeNodeByKey(node.key);
  });
  return change;
}

/**
 * Remove the row associated to a given key in a table.
 * Clear thw row if last remaining row
 */
function removeRowByKey(opts, change, key) {
  var value = change.value;
  var pos = TablePosition.create(opts, value.document, key); // Update table by removing the row

  if (pos.getHeight() > 1) {
    change.removeNodeByKey(key);
  } else {
    // If last remaining row, clear it instead
    pos.row.nodes.forEach(function (cell) {
      cell.nodes.forEach(function () {
        return clearCell(opts, change, cell);
      });
    });
  } // this will also invalidate the selection - move it to the first cell
  // change.moveToRangeOfNode(pos.row.nodes.first());


  return change;
}

/**
 * Remove current row in a table. Clear it if last remaining row
 */

function removeRow(opts, change, at) {
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);
  var rowKey;

  if (typeof at === 'undefined') {
    rowKey = pos.row.key;
  } else {
    rowKey = pos.table.nodes.get(at).key;
  }

  return removeRowByKey(opts, change, rowKey);
}

/**
 * Delete the column associated with the given cell key in a table
 */
function removeColumnByKey(opts, change, key) {
  var value = change.value;
  var pos = TablePosition.create(opts, value.document, key);
  var table = pos.table;
  var colIndex = pos.getColumnIndex();
  var rows = table.nodes; // Remove the cell from every row

  if (pos.getWidth() > 1) {
    change.withoutNormalizing(function () {
      rows.forEach(function (row) {
        var cell = row.nodes.get(colIndex);
        change.removeNodeByKey(cell.key);
      });
    });
  } else {
    // If last column, clear text in cells instead
    rows.forEach(function (row) {
      row.nodes.forEach(function (cell) {
        cell.nodes.forEach(function () {
          return clearCell(opts, change, cell);
        });
      });
    });
  } // this will also invalidate the selection - move it to the first cell
  // change.moveToRangeOfNode(rows.first().nodes.first());
  // Replace the table


  return change;
}

/**
 * Delete current column in a table
 */
function removeColumn(opts, change, at) {
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);
  var columnKey;

  if (typeof at === 'undefined') {
    columnKey = pos.cell.key;
  } else {
    columnKey = pos.row.nodes.get(at).key;
  }

  return removeColumnByKey(opts, change, columnKey);
}

/**
 * Delete the whole table at the given node key
 */
function removeTableByKey(opts, editor, key) {
  var value = editor.value;
  var pos = TablePosition.create(opts, value.document, key);
  var table = pos.table;
  var document = editor.value.document;
  var nextFocusBlock = null;
  var shouldCollapseToEnd = false;
  var nextBlock = editor.value.document.getNextBlock(table.key);

  if (nextBlock) {
    nextFocusBlock = nextBlock;
  } else {
    var prevBlock = editor.value.document.getPreviousBlock(table.key);

    if (prevBlock) {
      nextFocusBlock = prevBlock;
      shouldCollapseToEnd = true;
    } else if (opts.exitBlockType) {
      nextFocusBlock = Block.create({
        type: opts.exitBlockType,
        nodes: [Text.create('')]
      });
      var tableParent = document.getParent(table.key);
      var insertionIndex = tableParent.nodes.indexOf(table) + 1;
      editor.insertNodeByKey(tableParent.key, insertionIndex, nextFocusBlock);
    }
  }

  editor.removeNodeByKey(table.key);

  if (!nextFocusBlock) {
    return editor;
  }

  if (shouldCollapseToEnd) {
    editor.moveToEndOfNode(nextFocusBlock).focus();
  } else {
    editor.moveToStartOfNode(nextFocusBlock).focus();
  }

  return editor;
}

/**
 * Delete the whole table at position
 */

function removeTable(opts, editor) {
  var value = editor.value;
  var selection = value.selection;
  return removeTableByKey(opts, editor, selection.start.key);
}

/**
 * Move selection by a {x,y} relative movement
 */
function moveSelectionBy(opts, change, x, //  Move horizontally by x
y // Move vertically by y
) {
  var value = change.value;
  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);

  if (!pos.isInCell()) {
    throw new Error('moveSelectionBy can only be applied in a cell');
  }

  var rowIndex = pos.getRowIndex();
  var colIndex = pos.getColumnIndex();
  var width = pos.getWidth();
  var height = pos.getHeight();

  var _normPos = normPos(x + colIndex, y + rowIndex, width, height),
      _normPos2 = _slicedToArray(_normPos, 2),
      absX = _normPos2[0],
      absY = _normPos2[1];

  var isGoingUp = y < 0;

  if (absX === -1) {
    // Out of table
    return change;
  }

  var table = pos.table;
  var row = table.nodes.get(absY);
  var cell = row.nodes.get(absX);

  if (isGoingUp) {
    change.moveToEndOfNode(cell);
  } else {
    change.moveToStartOfNode(cell);
  }

  return change;
}
/**
 * Normalize position in a table. If x is out of the row, update y accordingly.
 * Returns [-1, -1] if the new selection is out of table
 */


function normPos(x, y, width, height) {
  if (x < 0) {
    x = width - 1;
    y -= 1;
  }

  if (y < 0) {
    return [-1, -1];
  }

  if (x >= width) {
    x = 0;
    y += 1;
  }

  if (y >= height) {
    return [-1, -1];
  }

  return [x, y];
}

/**
 * Move selection by a {x,y} relative movement
 */
function moveSelectionOutOfTable(opts, editor) {
  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var value = editor.value;
  var selection = value.selection,
      document = value.document;
  var pos = TablePosition.create(opts, document, selection.start.key);

  if (!pos.isInCell()) {
    throw new Error('moveSelectionOutOfTable can only be applied in a cell');
  }

  var table = pos.table;
  var isGoingUp = direction < 0;

  if (isGoingUp) {
    var previousNode = document.getPreviousBlock(table.key);
    previousNode && editor.moveToEndOfNode(previousNode);
  } else {
    var nextNode = document.getNextBlock(table.key);
    nextNode && editor.moveToStartOfNode(nextNode);
  }

  return editor;
}

var CHILD_OBJECT_INVALID = 'child_object_invalid';
var CHILD_TYPE_INVALID = 'child_type_invalid';
var PARENT_TYPE_INVALID = 'parent_type_invalid';

/*
 * Returns a schema definition for the plugin
 */
function schema(opts) {
  var _blocks;

  return {
    blocks: (_blocks = {}, _defineProperty(_blocks, opts.typeTable, {
      nodes: [{
        match: {
          type: opts.typeRow
        }
      }],
      parent: [{
        object: 'document'
      }],
      normalize: function normalize(editor, _ref) {
        var code = _ref.code,
            node = _ref.node;

        if (code === 'parent_object_invalid') {
          editor.insertText(node.text);
          editor.removeNodeByKey(node.key);
        }
      }
    }), _defineProperty(_blocks, opts.typeRow, {
      nodes: [{
        match: {
          type: opts.typeCell
        }
      }],
      parent: {
        type: opts.typeTable
      },
      normalize: function normalize(change, error) {
        switch (error.code) {
          case CHILD_TYPE_INVALID:
            return onlyCellsInRow(opts, change, error);

          case PARENT_TYPE_INVALID:
            return rowOnlyInTable(opts, change, error);
        }
      }
    }), _defineProperty(_blocks, opts.typeCell, {
      nodes: [{
        match: {
          object: 'block'
        }
      }],
      parent: {
        type: opts.typeRow
      },
      normalize: function normalize(change, error) {
        switch (error.code) {
          case CHILD_OBJECT_INVALID:
            return onlyBlocksInCell(opts, change, error.node);

          case PARENT_TYPE_INVALID:
            return cellOnlyInRow(opts, change, error);
        }
      }
    }), _blocks)
  };
}
/*
 * A row's children must be cells.
 * If they're not then we wrap them within a cell.
 */


function onlyCellsInRow(opts, change, error) {
  var cell = createCell(opts, []);
  var index = error.node.nodes.findIndex(function (child) {
    return child.key === error.child.key;
  });
  change.withoutNormalizing(function () {
    change.insertNodeByKey(error.node.key, index, cell);
    change.moveNodeByKey(error.child.key, cell.key, 0);
  });
}
/*
 * Rows can't live outside a table, if one is found then we wrap it within a table.
 */


function rowOnlyInTable(opts, change, error) {
  return change.wrapBlockByKey(error.node.key, opts.typeTable);
}
/*
 * A cell's children must be "block"s.
 * If they're not then we wrap them within a block with a type of opts.typeContent
 */


function onlyBlocksInCell(opts, change, node) {
  change.wrapBlockByKey(node.nodes.first().key, opts.typeContent);
  var wrapper = change.value.document.getDescendant(node.key).nodes.first(); // Add in the remaining items

  node.nodes.rest().forEach(function (child, index) {
    return change.moveNodeByKey(child.key, wrapper.key, index + 1);
  });
  return change;
  /*     const block = Block.create({
      type: opts.typeContent,
  });
  change.withoutNormalizing(() => {
      change.insertNodeByKey(error.node.key, 0, block);
      const inlines = error.node.nodes.filter(
          node => node.object !== 'block',
      );
      inlines.forEach((inline, index) => {
          change.moveNodeByKey(inline.key, block.key, index);
      });
  }); */
}
/*
 * Cells can't live outside a row, if one is found then we wrap it within a row.
 */


function cellOnlyInRow(opts, change, error) {
  return change.wrapBlockByKey(error.node.key, opts.typeRow);
}

/*
 * Ensure each row has the same number of columns.
 */

function normalizeNode(opts) {
  var isRow = function isRow(node) {
    return node.type === opts.typeRow;
  };

  var countNodes = function countNodes(row) {
    return row.nodes.size;
  };

  return function (node, editor, next) {
    if (node.type !== opts.typeTable) {
      return next();
    }

    var rows = node.nodes.filter(isRow);
    var maxColumns = Math.max( // Minimum 1 column
    1, rows.map(countNodes).max());
    var rowsMissingColumns = rows.filter(function (row) {
      return countNodes(row) < maxColumns;
    });

    if (rowsMissingColumns.isEmpty()) {
      return next();
    }

    return function (change) {
      change.withoutNormalizing(function () {
        rowsMissingColumns.forEach(function (row) {
          var numberOfCellsToAdd = maxColumns - row.nodes.size;
          var cells = Array.from({
            length: numberOfCellsToAdd
          }).map(function () {
            return createCell(opts);
          });
          cells.forEach(function (cell) {
            return change.insertNodeByKey(row.key, row.nodes.size, cell);
          });
        });
      });
    };
  };
}

/**
 * Returns the core of the plugin, limited to the validation and normalization
 * part of `slate-edit-table`, and utils.
 *
 * Import this directly: `import EditTable from 'slate-edit-table/lib/core'`
 * if you don't care about behavior/rendering and you
 * are only manipulating `Slate.Values` without rendering them.
 * That way you do not depend on `slate-react`.
 */

function core(optionsParam) {
  var opts = new Options(optionsParam);
  return {
    schema: schema(opts),
    normalizeNode: normalizeNode(opts),
    queries: {
      isSelectionInTable: isSelectionInTable.bind(null, opts),
      isSelectionOutOfTable: isSelectionOutOfTable.bind(null, opts),
      getPosition: getPosition.bind(null, opts),
      getPositionByKey: getPositionByKey.bind(null, opts),
      createCell: createCell.bind(null, opts),
      createRow: createRow.bind(null, opts),
      createTable: createTable.bind(null, opts),
      forEachCells: forEachCells.bind(null, opts),
      getCellsAtRow: getCellsAtRow.bind(null, opts),
      getCellsAtColumn: getCellsAtColumn.bind(null, opts),
      getCopiedFragment: getCopiedFragment.bind(null, opts)
    },
    commands: {
      insertTable: insertTable.bind(null, opts),
      insertTableFragmentAtRange: insertTableFragmentAtRange.bind(null, opts),
      clearCell: clearCell.bind(null, opts),
      removeRowByKey: removeRowByKey.bind(null, opts),
      removeColumnByKey: removeColumnByKey.bind(null, opts),
      removeTableByKey: removeTableByKey.bind(null, opts),
      insertRow: bindAndScopeChange(opts, insertRow),
      removeRow: bindAndScopeChange(opts, removeRow),
      insertColumn: bindAndScopeChange(opts, insertColumn),
      removeColumn: bindAndScopeChange(opts, removeColumn),
      removeTable: bindAndScopeChange(opts, removeTable),
      moveSelection: bindAndScopeChange(opts, moveSelection),
      moveSelectionBy: bindAndScopeChange(opts, moveSelectionBy),
      moveSelectionOutOfTable: bindAndScopeChange(opts, moveSelectionOutOfTable)
    }
  };
}
/**
 * Bind a change to given options, and scope it to act only inside a table
 */


function bindAndScopeChange(opts, fn) {
  return function (editor) {
    if (!editor.isSelectionInTable()) {
      return editor;
    } // $FlowFixMe


    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return fn.apply(void 0, _toConsumableArray([opts, editor].concat(args)));
  };
}

/**
 * Insert a new row when pressing "Enter"
 */

function onEnter(event, editor, opts, next) {
  event.preventDefault();
  var _editor$value = editor.value,
      selection = _editor$value.selection,
      document = _editor$value.document;
  var pos = TablePosition.create(opts, document, selection.start.key);
  var isAtEdgeOfCell = selection.focus.isAtStartOfNode(pos.cell) || selection.focus.isAtEndOfNode(pos.cell);

  if (!opts.insertRowOnEnter || !isAtEdgeOfCell) {
    return next();
  }

  if (event.shiftKey) {
    return editor.splitBlock().setBlocks({
      type: opts.typeContent,
      data: {}
    });
  }

  return insertRow(opts, editor);
}

/**
 * Exit the current table, by inserting a default block after the table.
 */
function onModEnter(event, editor, opts, next) {
  var value = editor.value;

  if (!value.selection.isCollapsed) {
    return next();
  }

  event.preventDefault();
  var exitBlock = Block.create({
    type: opts.exitBlockType,
    nodes: [Text.create('')]
  });
  var table = TablePosition.create(opts, value.document, value.selection.start.key).table;
  var tableParent = value.document.getParent(table.key);
  var insertionIndex = tableParent.nodes.indexOf(table) + 1;
  return editor.insertNodeByKey(tableParent.key, insertionIndex, exitBlock).moveToStartOfNode(exitBlock);
}

/**
 * Select all text of current block.
 */
function selectAllText(editor) {
  var value = editor.value;
  var startBlock = value.startBlock;
  return editor.moveTo(0).moveFocusForward(startBlock.text.length);
}
/**
 * Pressing "Tab" moves the cursor to the next cell
 * and select the whole text
 */


function onTab(event, editor, opts) {
  event.preventDefault();
  var value = editor.value;
  var direction = event.shiftKey ? -1 : +1; // Create new row if needed

  var selection = value.selection;
  var pos = TablePosition.create(opts, value.document, selection.start.key);

  if (pos.isFirstCell() && direction === -1) {
    insertRow(opts, editor, 0);
  } else if (pos.isLastCell() && direction === 1) {
    insertRow(opts, editor);
  } // Move back to initial cell (insertRow moves selection automatically).


  editor.select(selection); // Move

  moveSelectionBy(opts, editor, direction, 0); // Select all cell.

  return selectAllText(editor);
}

function onBackspace(event, editor, opts, next) {
  var value = editor.value;
  var startBlock = value.startBlock,
      selection = value.selection,
      endBlock = value.endBlock,
      document = value.document;
  var isCollapsed = selection.isCollapsed;
  var startCell = document.getClosest(startBlock.key, opts.isCell);
  var endCell = document.getClosest(endBlock.key, opts.isCell);
  var startPath = startCell.getPath(selection.start.key); // If a cursor is collapsed at the start of the first block, do nothing

  if (selection.start.offset === 0 && isCollapsed && startPath && startPath.every(function (index) {
    return index === 0;
  })) {
    if (editor.isVoid(startBlock)) {
      // Delete the block normally if it is a void block
      return next();
    }

    event.preventDefault();
    return editor;
  } // If "normal" deletion, we continue


  if (startCell === endCell) {
    return next();
  } // If cursor is between multiple blocks,
  // we clear the content of the cells.


  event.preventDefault();
  var blocks = value.blocks; // Get all cells that contains the selection

  var cells = blocks.map(function (node) {
    return node.type === opts.typeCell ? node : document.getClosest(node.key, function (a) {
      return a.type === opts.typeCell;
    });
  }).toSet(); // If the cursor is at the very end of the first cell, ignore it.
  // If the cursor is at the very start of the last cell, ignore it.
  // This behavior is to compensate hanging selection behaviors:
  // https://github.com/ianstormtaylor/slate/pull/1605

  var ignoreFirstCell = value.selection.moveToStart().anchor.isAtEndOfNode(cells.first());
  var ignoreLastCell = value.selection.moveToEnd().anchor.isAtStartOfNode(cells.last());
  var cellsToClear = cells;

  if (ignoreFirstCell) {
    cellsToClear = cellsToClear.rest();
  }

  if (ignoreLastCell) {
    cellsToClear = cellsToClear.butLast();
  } // Clear all the selection


  cellsToClear.forEach(function (cell) {
    return clearCell(opts, editor, cell);
  }); // Update the selection properly, and avoid reset of selection

  var updatedStartCell = editor.value.document.getDescendant(cellsToClear.first().key);
  return editor.moveToStartOfNode(updatedStartCell);
}

function onUpDown(event, editor, opts, next) {
  var value = editor.value;
  var direction = event.key === 'ArrowUp' ? -1 : +1;
  var pos = TablePosition.create(opts, value.document, value.selection.start.key);

  if (pos.isFirstRow() && direction === -1 && pos.isTopOfCell() || pos.isLastRow() && direction === +1 && pos.isBottomOfCell()) {
    if (opts.edgeRowExitOnDirection) {
      event.preventDefault();
      return moveSelectionOutOfTable(opts, editor, direction);
    } else {
      // Let the default behavior move out of the table
      return next();
    }
  }

  if (direction === -1 && !pos.isTopOfCell()) {
    return next();
  }

  if (direction === +1 && !pos.isBottomOfCell()) {
    return next();
  }

  event.preventDefault();
  moveSelectionBy(opts, editor, 0, direction);
  return editor;
}

function onUpDown$1(event, editor, opts) {
  var direction = event.key === 'ArrowUp' ? -1 : +1;
  event.preventDefault();
  moveSelectionOutOfTable(opts, editor, direction);
  return editor;
}

var KEY_ENTER = 'Enter';
var KEY_TAB = 'Tab';
var KEY_BACKSPACE = 'Backspace';
var KEY_DOWN = 'ArrowDown';
var KEY_UP = 'ArrowUp';
/**
 * User is pressing a key in the editor
 */

function onKeyDown(opts, event, editor, next) {
  // Only handle events in cells
  if (!editor.isSelectionInTable()) {
    return next();
  } // Build arguments list


  var args = [event, editor, opts, next];

  switch (event.key) {
    case KEY_ENTER:
      if (event.metaKey && opts.exitBlockType) {
        return onModEnter.apply(void 0, args);
      }

      return onEnter.apply(void 0, args);

    case KEY_TAB:
      return onTab.apply(void 0, args);

    case KEY_BACKSPACE:
      return onBackspace.apply(void 0, args);

    case KEY_DOWN:
    case KEY_UP:
      if (event.metaKey) {
        return onUpDown$1.apply(void 0, args);
      }

      return onUpDown.apply(void 0, args);

    default:
      return next();
  }
}

function onCopy(opts, event, editor, next) {
  if (!editor.isSelectionInTable()) {
    return next();
  }

  var fragment = getCopiedFragment(opts, editor.value);
  if (!fragment) return next();
  var tempEditor = new Editor({
    value: Value.fromJSON({
      document: fragment
    })
  });
  tempEditor.moveToRangeOfDocument();
  cloneFragment(event, tempEditor);
}

/**
 *  Returns the full plugin object (behavior + rendering + schema)
 */

function EditTable( // The plugin options
optionsParam) {
  var opts = new Options(optionsParam || {});
  var corePlugin = core(opts);
  return _objectSpread({}, corePlugin, {
    onKeyDown: onKeyDown.bind(null, opts),
    onCopy: onCopy.bind(null, opts)
  });
}

export default EditTable;
//# sourceMappingURL=index.es.js.map
