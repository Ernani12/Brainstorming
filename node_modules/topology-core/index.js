"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var le5le_store_1 = require("le5le-store");
var options_1 = require("./options");
var node_1 = require("./models/node");
var point_1 = require("./models/point");
var line_1 = require("./models/line");
var data_1 = require("./models/data");
var status_1 = require("./models/status");
var index_1 = require("./middles/index");
var offscreen_1 = require("./offscreen");
var renderLayer_1 = require("./renderLayer");
var hoverLayer_1 = require("./hoverLayer");
var activeLayer_1 = require("./activeLayer");
var animateLayer_1 = require("./animateLayer");
var divLayer_1 = require("./divLayer");
var rect_1 = require("./models/rect");
var uuid_1 = require("./uuid/uuid");
var curve_1 = require("./middles/lines/curve");
var utils_1 = require("./utils");
var resizeCursors = ['nw-resize', 'ne-resize', 'se-resize', 'sw-resize'];
var MoveInType;
(function (MoveInType) {
    MoveInType[MoveInType["None"] = 0] = "None";
    MoveInType[MoveInType["Line"] = 1] = "Line";
    MoveInType[MoveInType["LineMove"] = 2] = "LineMove";
    MoveInType[MoveInType["LineFrom"] = 3] = "LineFrom";
    MoveInType[MoveInType["LineTo"] = 4] = "LineTo";
    MoveInType[MoveInType["LineControlPoint"] = 5] = "LineControlPoint";
    MoveInType[MoveInType["Nodes"] = 6] = "Nodes";
    MoveInType[MoveInType["ResizeCP"] = 7] = "ResizeCP";
    MoveInType[MoveInType["HoverAnchors"] = 8] = "HoverAnchors";
    MoveInType[MoveInType["Rotate"] = 9] = "Rotate";
})(MoveInType || (MoveInType = {}));
var dockOffset = 10;
var Topology = /** @class */ (function () {
    function Topology(parent, options) {
        var _this = this;
        this.data = new data_1.TopologyData();
        this.caches = {
            index: 0,
            list: []
        };
        this.input = document.createElement('textarea');
        this.lastTranlated = { x: 0, y: 0 };
        this.moveIn = {
            type: MoveInType.None,
            activeAnchorIndex: 0,
            hoverAnchorIndex: 0,
            hoverNode: null,
            hoverLine: null,
            lineControlPoint: null
        };
        this.needCache = false;
        this.tip = '';
        this.scheduledAnimationFrame = false;
        this.scrolling = false;
        this.onMouseMove = function (e) {
            if (_this.scheduledAnimationFrame || _this.data.locked === status_1.Lock.NoEvent) {
                return;
            }
            if (_this.mouseDown && _this.moveIn.type === MoveInType.None) {
                var b = false;
                switch (_this.options.translateKey) {
                    case options_1.KeyType.None:
                        b = true;
                        break;
                    case options_1.KeyType.Ctrl:
                        if (e.ctrlKey) {
                            b = true;
                        }
                        break;
                    case options_1.KeyType.Shift:
                        if (e.shiftKey) {
                            b = true;
                        }
                        break;
                    case options_1.KeyType.Alt:
                        if (e.altKey) {
                            b = true;
                        }
                        break;
                    default:
                        if (e.ctrlKey || e.altKey) {
                            b = true;
                        }
                }
                if (b) {
                    _this.translate(e.offsetX - _this.mouseDown.x, e.offsetY - _this.mouseDown.y, true);
                    return false;
                }
            }
            if (_this.data.locked && _this.mouseDown && _this.moveIn.type !== MoveInType.None) {
                return;
            }
            _this.scheduledAnimationFrame = true;
            var pos = new point_1.Point(e.offsetX, e.offsetY);
            requestAnimationFrame(function () {
                _this.scheduledAnimationFrame = false;
                if (!_this.mouseDown) {
                    _this.getMoveIn(pos);
                    // Render hover anchors.
                    if (_this.moveIn.hoverNode !== _this.lastHoverNode) {
                        if (_this.lastHoverNode) {
                            // Send a move event.
                            if (_this.options.on) {
                                _this.options.on('moveOutNode', _this.lastHoverNode);
                            }
                            _this.hideTip();
                            // Clear hover anchors.
                            _this.hoverLayer.node = null;
                        }
                        if (_this.moveIn.hoverNode) {
                            _this.hoverLayer.node = _this.moveIn.hoverNode;
                            // Send a move event.
                            if (_this.options.on) {
                                _this.options.on('moveInNode', _this.moveIn.hoverNode);
                            }
                            _this.showTip(_this.moveIn.hoverNode, pos);
                        }
                    }
                    if (_this.moveIn.hoverLine !== _this.lastHoverLine) {
                        if (_this.lastHoverLine) {
                            if (_this.options.on) {
                                _this.options.on('moveOutLine', _this.lastHoverLine);
                            }
                            _this.hideTip();
                        }
                        if (_this.moveIn.hoverLine) {
                            if (_this.options.on) {
                                _this.options.on('moveInLine', _this.moveIn.hoverLine);
                            }
                            _this.showTip(_this.moveIn.hoverLine, pos);
                        }
                    }
                    if (_this.moveIn.type === MoveInType.LineControlPoint) {
                        _this.hoverLayer.hoverLineCP = _this.moveIn.lineControlPoint;
                    }
                    else if (_this.hoverLayer.hoverLineCP) {
                        _this.hoverLayer.hoverLineCP = null;
                    }
                    if (_this.moveIn.hoverNode !== _this.lastHoverNode ||
                        _this.moveIn.type === MoveInType.HoverAnchors ||
                        _this.hoverLayer.lasthoverLineCP !== _this.hoverLayer.hoverLineCP) {
                        _this.hoverLayer.lasthoverLineCP = _this.hoverLayer.hoverLineCP;
                        _this.render();
                    }
                    return;
                }
                // Move out parent element.
                var moveOutX = pos.x + 50 > _this.parentElem.clientWidth + _this.parentElem.scrollLeft;
                var moveOutY = pos.y + 50 > _this.parentElem.clientHeight + _this.parentElem.scrollTop;
                if (moveOutX || moveOutY) {
                    if (_this.options.on) {
                        _this.options.on('moveOutParent', pos);
                    }
                    var resize = false;
                    if (pos.x + 50 > _this.divLayer.canvas.clientWidth) {
                        _this.canvas.width += 200;
                        resize = true;
                    }
                    if (pos.y + 50 > _this.divLayer.canvas.clientHeight) {
                        _this.canvas.height += 200;
                        resize = true;
                    }
                    if (resize) {
                        _this.resize({ width: _this.canvas.width, height: _this.canvas.height });
                    }
                    _this.scroll(moveOutX ? 100 : 0, moveOutY ? 100 : 0);
                }
                var moveLeft = pos.x - 100 < _this.parentElem.scrollLeft;
                var moveTop = pos.y - 100 < _this.parentElem.scrollTop;
                if (moveLeft || moveTop) {
                    _this.scroll(moveLeft ? -100 : 0, moveTop ? -100 : 0);
                }
                switch (_this.moveIn.type) {
                    case MoveInType.None:
                        _this.hoverLayer.dragRect = new rect_1.Rect(_this.mouseDown.x, _this.mouseDown.y, pos.x - _this.mouseDown.x, pos.y - _this.mouseDown.y);
                        break;
                    case MoveInType.Nodes:
                        if (_this.activeLayer.locked()) {
                            break;
                        }
                        var x = pos.x - _this.mouseDown.x;
                        var y = pos.y - _this.mouseDown.y;
                        if (x || y) {
                            var offset = _this.getDockPos(x, y);
                            _this.activeLayer.moveNodes(offset.x ? offset.x : x, offset.y ? offset.y : y);
                            _this.animateLayer.start(true);
                            _this.needCache = true;
                        }
                        break;
                    case MoveInType.ResizeCP:
                        _this.activeLayer.resizeNodes(_this.moveIn.activeAnchorIndex, _this.mouseDown, pos);
                        _this.animateLayer.start(true);
                        if (_this.options.on) {
                            _this.options.on('resizeNodes', _this.activeLayer.nodes);
                        }
                        _this.needCache = true;
                        break;
                    case MoveInType.LineTo:
                    case MoveInType.HoverAnchors:
                        var arrow = _this.data.toArrowType;
                        if (_this.moveIn.hoverLine) {
                            arrow = _this.moveIn.hoverLine.toArrow;
                        }
                        if (!_this.activeLayer.lines.length && _this.hoverLayer.line) {
                            _this.activeLayer.lines = [_this.hoverLayer.line];
                        }
                        _this.hoverLayer.lineTo(_this.getLineDock(pos), arrow);
                        _this.animateLayer.start(true);
                        _this.needCache = true;
                        break;
                    case MoveInType.LineFrom:
                        _this.hoverLayer.lineFrom(_this.getLineDock(pos));
                        _this.needCache = true;
                        break;
                    case MoveInType.LineMove:
                        _this.hoverLayer.lineMove(pos, _this.mouseDown);
                        _this.animateLayer.start(true);
                        _this.needCache = true;
                        break;
                    case MoveInType.LineControlPoint:
                        _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].x = pos.x;
                        _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].y = pos.y;
                        _this.moveIn.hoverLine.textRect = null;
                        if (index_1.drawLineFns[_this.moveIn.hoverLine.name] && index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn) {
                            index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn(_this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id], _this.moveIn.hoverLine);
                        }
                        _this.animateLayer.start(true);
                        _this.needCache = true;
                        break;
                    case MoveInType.Rotate:
                        if (_this.activeLayer.nodes.length) {
                            _this.activeLayer.offsetRotate(_this.getAngle(pos));
                            _this.activeLayer.updateLines();
                        }
                        _this.animateLayer.start(true);
                        _this.needCache = true;
                        break;
                }
                _this.render();
            });
        };
        this.onmousedown = function (e) {
            if (e.button) {
                return;
            }
            _this.mouseDown = { x: e.offsetX, y: e.offsetY };
            if (e.altKey) {
                _this.divLayer.canvas.style.cursor = 'move';
            }
            if (_this.inputObj) {
                _this.setNodeText();
            }
            switch (_this.moveIn.type) {
                // Click the space.
                case MoveInType.None:
                    _this.activeLayer.clear();
                    _this.hoverLayer.clear();
                    if (_this.options.on) {
                        _this.options.on('space', null);
                    }
                    break;
                // Click a line.
                case MoveInType.Line:
                case MoveInType.LineControlPoint:
                    if (e.ctrlKey) {
                        _this.activeLayer.addLine(_this.moveIn.hoverLine);
                        if (_this.options.on) {
                            if (_this.data.lines.length > 1 || _this.data.nodes.length) {
                                _this.options.on('multi', {
                                    nodes: _this.activeLayer.nodes,
                                    lines: _this.activeLayer.lines
                                });
                            }
                            else {
                                _this.options.on('line', _this.moveIn.hoverLine);
                            }
                        }
                    }
                    else {
                        _this.activeLayer.nodes = [];
                        _this.activeLayer.lines = [_this.moveIn.hoverLine];
                        if (_this.options.on) {
                            _this.options.on('line', _this.moveIn.hoverLine);
                        }
                        _this.link(_this.moveIn.hoverLine);
                    }
                    break;
                case MoveInType.LineMove:
                    _this.hoverLayer.initLine = new line_1.Line(_this.moveIn.hoverLine);
                // tslint:disable-next-line:no-switch-case-fall-through
                case MoveInType.LineFrom:
                case MoveInType.LineTo:
                    _this.activeLayer.nodes = [];
                    _this.activeLayer.lines = [_this.moveIn.hoverLine];
                    if (_this.options.on) {
                        _this.options.on('line', _this.moveIn.hoverLine);
                    }
                    _this.hoverLayer.line = _this.moveIn.hoverLine;
                    break;
                case MoveInType.HoverAnchors:
                    _this.hoverLayer.setLine(new point_1.Point(_this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].x, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].y, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].direction, _this.moveIn.hoverAnchorIndex, _this.moveIn.hoverNode.id), _this.data.fromArrowType, _this.data.lineName);
                // tslint:disable-next-line:no-switch-case-fall-through
                case MoveInType.Nodes:
                    if (!e.ctrlKey) {
                        _this.link(_this.moveIn.hoverNode);
                    }
                    if (!_this.moveIn.hoverNode) {
                        break;
                    }
                    if (e.ctrlKey) {
                        if (_this.activeLayer.hasNode(_this.moveIn.hoverNode)) {
                            break;
                        }
                        _this.activeLayer.addNode(_this.moveIn.hoverNode);
                        if (_this.options.on) {
                            if (_this.activeLayer.nodes.length > 1 || _this.activeLayer.lines.length) {
                                _this.options.on('multi', {
                                    nodes: _this.activeLayer.nodes,
                                    lines: _this.activeLayer.lines
                                });
                            }
                            else {
                                _this.options.on('node', _this.moveIn.hoverNode);
                            }
                        }
                    }
                    else {
                        _this.activeLayer.setNodes([_this.moveIn.hoverNode]);
                        if (_this.options.on) {
                            _this.options.on('node', _this.moveIn.hoverNode);
                        }
                    }
                    break;
            }
            // Save node rects to move.
            if (_this.activeLayer.nodes.length) {
                _this.activeLayer.saveNodeRects();
            }
            _this.render();
        };
        this.onmouseup = function (e) {
            _this.mouseDown = null;
            _this.lastTranlated.x = 0;
            _this.lastTranlated.y = 0;
            _this.hoverLayer.dockAnchor = null;
            _this.hoverLayer.dockLineX = 0;
            _this.hoverLayer.dockLineY = 0;
            _this.divLayer.canvas.style.cursor = 'default';
            if (_this.hoverLayer.dragRect) {
                _this.getRectNodes(_this.data.nodes, _this.hoverLayer.dragRect);
                _this.getRectLines(_this.data.lines, _this.hoverLayer.dragRect);
                if (_this.options.on && _this.activeLayer.nodes && _this.activeLayer.nodes.length) {
                    _this.options.on('multi', {
                        nodes: _this.activeLayer.nodes,
                        lines: _this.activeLayer.lines
                    });
                }
            }
            else {
                switch (_this.moveIn.type) {
                    // Add the line.
                    case MoveInType.HoverAnchors:
                        // New active.
                        if (_this.hoverLayer.line && _this.hoverLayer.line.to) {
                            _this.data.lines.push(_this.hoverLayer.line);
                            // Deactive nodes.
                            _this.activeLayer.nodes = [];
                            if (_this.hoverLayer.line.to.id || !_this.options.disableEmptyLine) {
                                _this.activeLayer.lines = [_this.hoverLayer.line];
                                if (_this.options.on) {
                                    _this.options.on('addLine', _this.hoverLayer.line);
                                }
                            }
                            else {
                                _this.data.lines.pop();
                            }
                        }
                        _this.offscreen.render();
                        _this.hoverLayer.line = null;
                        break;
                    case MoveInType.Rotate:
                        _this.activeLayer.updateRotate();
                        break;
                    case MoveInType.LineControlPoint:
                        le5le_store_1.Store.set('pts-' + _this.moveIn.hoverLine.id, null);
                        break;
                }
            }
            _this.hoverLayer.dragRect = null;
            _this.render();
            if (_this.needCache) {
                _this.cache();
            }
            _this.needCache = false;
        };
        this.ondblclick = function (e) {
            if (_this.moveIn.hoverNode) {
                if (_this.options.on) {
                    _this.options.on('dblclick', {
                        node: _this.moveIn.hoverNode
                    });
                }
                if (_this.moveIn.hoverNode.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {
                    _this.showInput(_this.moveIn.hoverNode);
                }
            }
            else if (_this.moveIn.hoverLine) {
                if (_this.options.on) {
                    _this.options.on('dblclick', {
                        line: _this.moveIn.hoverLine
                    });
                }
                if (!_this.moveIn.hoverLine.text || _this.moveIn.hoverLine.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {
                    _this.showInput(_this.moveIn.hoverLine);
                }
            }
        };
        this.onkeydown = function (key) {
            if (_this.data.locked) {
                return;
            }
            key.preventDefault();
            var done = false;
            var moveX = 0;
            var moveY = 0;
            switch (key.keyCode) {
                // Delete
                case 8:
                case 46:
                    if (!_this.activeLayer.nodes.length && !_this.activeLayer.lines.length) {
                        return;
                    }
                    _this.delete();
                    break;
                // Left
                case 37:
                    moveX = -5;
                    if (key.ctrlKey) {
                        moveX = -1;
                    }
                    done = true;
                    break;
                // Top
                case 38:
                    moveY = -5;
                    if (key.ctrlKey) {
                        moveY = -1;
                    }
                    done = true;
                    break;
                // Right
                case 39:
                    moveX = 5;
                    if (key.ctrlKey) {
                        moveX = 1;
                    }
                    done = true;
                    break;
                // Down
                case 40:
                    moveY = 5;
                    if (key.ctrlKey) {
                        moveY = 1;
                    }
                    done = true;
                    break;
            }
            if (!done) {
                return;
            }
            if (moveX || moveY) {
                _this.activeLayer.saveNodeRects();
                _this.activeLayer.moveNodes(moveX, moveY);
                _this.overflow();
                _this.animateLayer.start(true);
            }
            _this.render();
            _this.cache();
        };
        le5le_store_1.Store.set('topology-data', this.data);
        this.options = options || {};
        if (!this.options.font) {
            this.options.font = {
                color: '#222',
                fontFamily: '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial',
                fontSize: 12,
                lineHeight: 1.5,
                textAlign: 'center',
                textBaseline: 'middle'
            };
        }
        if (!this.options.color) {
            this.options.color = '#222';
        }
        if (!this.options.rotateCursor) {
            this.options.rotateCursor = '/assets/img/rotate.cur';
        }
        if (!this.options.font.fontFamily) {
            this.options.font.fontFamily = '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial';
        }
        if (!this.options.font.color) {
            this.options.font.color = '#222';
        }
        if (!this.options.font.fontSize) {
            // px
            this.options.font.fontSize = 12;
        }
        if (!this.options.font.lineHeight) {
            // number
            this.options.font.lineHeight = 1.5;
        }
        if (!this.options.font.textAlign) {
            this.options.font.textAlign = 'center';
        }
        if (!this.options.font.textBaseline) {
            this.options.font.textBaseline = 'middle';
        }
        if (typeof parent === 'string') {
            this.parentElem = document.getElementById(parent);
        }
        else {
            this.parentElem = parent;
        }
        this.parentElem.style.position = 'relative';
        this.activeLayer = new activeLayer_1.ActiveLayer(this.options);
        this.hoverLayer = new hoverLayer_1.HoverLayer(this.options);
        this.animateLayer = new animateLayer_1.AnimateLayer(this.options);
        this.offscreen = new offscreen_1.Offscreen(this.parentElem, this.options);
        this.canvas = new renderLayer_1.RenderLayer(this.parentElem, this.options);
        this.divLayer = new divLayer_1.DivLayer(this.parentElem, this.options);
        this.resize();
        this.divLayer.canvas.ondragover = function (event) { return event.preventDefault(); };
        this.divLayer.canvas.ondrop = function (event) {
            _this.ondrop(event);
        };
        this.subcribe = le5le_store_1.Store.subscribe('LT:render', function () {
            _this.render();
        });
        this.subcribeImage = le5le_store_1.Store.subscribe('LT:imageLoaded', function () {
            if (_this.imageTimer) {
                clearTimeout(_this.imageTimer);
            }
            _this.imageTimer = setTimeout(function () {
                _this.render();
            }, 100);
        });
        this.subcribeAnimateMoved = le5le_store_1.Store.subscribe('nodeRectChanged', function (e) {
            _this.activeLayer.updateLines(_this.data.nodes);
            _this.animateLayer.updateLines(_this.data.nodes);
        });
        this.subcribeMediaEnd = le5le_store_1.Store.subscribe('mediaEnd', function (node) {
            if (node.nextPlay) {
                _this.animateLayer.getNodes(_this.data.nodes, node.nextPlay);
                _this.animateLayer.getLines(node.nextPlay);
                _this.animateLayer.animate();
            }
            if (_this.options.on) {
                _this.options.on('mediaEnd', node);
            }
        });
        this.subcribeAnimateEnd = le5le_store_1.Store.subscribe('animateEnd', function (e) {
            if (!e) {
                return;
            }
            switch (e.type) {
                case 'node':
                    _this.offscreen.render();
                    break;
            }
            _this.divLayer.playNext(e.data.nextAnimate);
            if (_this.options.on) {
                _this.options.on('animateEnd', e);
            }
        });
        this.divLayer.canvas.onmousemove = this.onMouseMove;
        this.divLayer.canvas.onmousedown = this.onmousedown;
        this.divLayer.canvas.onmouseup = this.onmouseup;
        this.divLayer.canvas.ondblclick = this.ondblclick;
        this.divLayer.canvas.tabIndex = 0;
        this.divLayer.canvas.onkeydown = this.onkeydown;
        this.divLayer.canvas.onblur = function () {
            _this.mouseDown = null;
        };
        this.divLayer.canvas.onwheel = function (event) {
            if (_this.options.disableScale) {
                return;
            }
            switch (_this.options.scaleKey) {
                case options_1.KeyType.None:
                    break;
                case options_1.KeyType.Ctrl:
                    if (!event.ctrlKey) {
                        return;
                    }
                    break;
                case options_1.KeyType.Shift:
                    if (!event.shiftKey) {
                        return;
                    }
                    break;
                case options_1.KeyType.Alt:
                    if (!event.altKey) {
                        return;
                    }
                    break;
                default:
                    if (!event.ctrlKey && !event.altKey) {
                        return;
                    }
            }
            event.preventDefault();
            if (event.deltaY < 0) {
                _this.scale(1.1);
            }
            else {
                _this.scale(0.9);
            }
            _this.divLayer.canvas.focus();
            return false;
        };
        this.divLayer.canvas.ontouchend = function (event) {
            _this.ontouched(event);
        };
        this.input.style.position = 'absolute';
        this.input.style.zIndex = '-1';
        this.input.style.left = '-1000px';
        this.input.style.width = '0';
        this.input.style.height = '0';
        this.input.style.outline = 'none';
        this.input.style.border = '1px solid #cdcdcd';
        this.input.style.resize = 'none';
        this.parentElem.appendChild(this.input);
        this.createMarkdownTip();
        this.cache();
    }
    Topology.prototype.resize = function (size) {
        this.canvas.resize(size);
        this.offscreen.resize(size);
        this.divLayer.resize(size);
        this.render();
        if (this.options.on) {
            this.options.on('resize', size);
        }
    };
    Topology.prototype.ondrop = function (event) {
        event.preventDefault();
        var json = JSON.parse(event.dataTransfer.getData('Text'));
        json.rect.x = (event.offsetX - json.rect.width / 2) << 0;
        json.rect.y = (event.offsetY - json.rect.height / 2) << 0;
        var node = new node_1.Node(json);
        this.addNode(node, true);
        if (node.name === 'div') {
            if (this.options.on) {
                this.options.on('LT:addDiv', node);
            }
        }
        this.divLayer.canvas.focus();
    };
    Topology.prototype.getTouchOffset = function (touch) {
        var currentTarget = this.parentElem;
        var x = 0;
        var y = 0;
        while (currentTarget) {
            x += currentTarget.offsetLeft;
            y += currentTarget.offsetTop;
            currentTarget = currentTarget.offsetParent;
        }
        return { offsetX: touch.pageX - x, offsetY: touch.pageY - y };
    };
    Topology.prototype.ontouched = function (event) {
        if (!this.touchedNode) {
            return;
        }
        var pos = this.getTouchOffset(event.changedTouches[0]);
        this.touchedNode.rect.x = pos.offsetX - this.touchedNode.rect.width / 2;
        this.touchedNode.rect.y = pos.offsetY - this.touchedNode.rect.height / 2;
        this.addNode(new node_1.Node(this.touchedNode), true);
        this.touchedNode = undefined;
    };
    Topology.prototype.addNode = function (node, focus) {
        if (focus === void 0) { focus = false; }
        if (this.data.locked || !index_1.drawNodeFns[node.name]) {
            return false;
        }
        // if it's not a Node
        if (!node.init) {
            node = new node_1.Node(node);
        }
        if (!node.strokeStyle && this.options.color) {
            node.strokeStyle = this.options.color;
        }
        if (!node.font.color) {
            node.font = Object.assign(node.font, this.options.font);
        }
        if (this.data.scale !== 1) {
            node.scale(this.data.scale);
        }
        this.data.nodes.push(node);
        // New active.
        if (focus) {
            this.activeLayer.setNodes([node]);
        }
        this.render();
        this.cache();
        if (this.options.on) {
            this.options.on('addNode', node);
        }
        return true;
    };
    Topology.prototype.addLine = function (line, focus) {
        if (focus === void 0) { focus = false; }
        if (this.data.locked) {
            return false;
        }
        // New active.
        if (focus) {
            this.activeLayer.setLines([line]);
        }
        this.data.lines.push(line);
        this.offscreen.render();
        this.cache();
        if (this.options.on) {
            this.options.on('addLine', line);
        }
    };
    Topology.prototype.addLineByPt = function (name, from, fromArrow, to, toArrow, focus) {
        if (focus === void 0) { focus = false; }
        var line = new line_1.Line({
            name: name,
            from: from,
            fromArrow: fromArrow,
            to: to,
            toArrow: toArrow
        });
        this.addLine(line, focus);
    };
    // Render or redraw
    Topology.prototype.render = function (noFocus) {
        if (noFocus === void 0) { noFocus = false; }
        if (noFocus) {
            this.activeLayer.nodes = [];
            this.activeLayer.lines = [];
            this.hoverLayer.node = null;
            this.hoverLayer.line = null;
        }
        this.offscreen.render();
        this.canvas.render();
    };
    // open - redraw by the data
    Topology.prototype.open = function (data) {
        this.divLayer.clear();
        // tslint:disable-next-line:forin
        for (var key in node_1.images) {
            delete node_1.images[key];
        }
        this.animateLayer.nodes = [];
        this.animateLayer.lines = [];
        this.lock(data.locked || status_1.Lock.None);
        if (data.lineName) {
            this.data.lineName = data.lineName;
        }
        this.data.scale = data.scale || 1;
        le5le_store_1.Store.set('LT:scale', this.data.scale);
        if (this.options.on) {
            this.options.on('scale', this.data.scale);
        }
        this.data.bkColor = data.bkColor;
        this.data.bkImage = data.bkImage;
        this.data.nodes = [];
        this.data.lines = [];
        for (var _i = 0, _a = data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            this.data.nodes.push(new node_1.Node(item));
        }
        for (var _b = 0, _c = data.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            this.data.lines.push(new line_1.Line(item));
        }
        this.caches.list = [];
        this.cache();
        this.overflow();
        this.render(true);
        this.animate();
    };
    Topology.prototype.overflow = function () {
        var rect = this.getRect();
        if (rect.ex > this.canvas.width || rect.ey > this.canvas.height) {
            this.resize({ width: rect.ex + 200, height: rect.ey + 200 });
        }
    };
    Topology.prototype.setNodeText = function () {
        this.inputObj.text = this.input.value;
        this.input.style.zIndex = '-1';
        this.input.style.left = '-1000px';
        this.input.style.width = '0';
        this.cache();
        this.offscreen.render();
        if (this.options.on) {
            this.options.on('setText', this.inputObj);
        }
        this.inputObj = null;
    };
    Topology.prototype.getMoveIn = function (pt) {
        this.lastHoverNode = this.moveIn.hoverNode;
        this.lastHoverLine = this.moveIn.hoverLine;
        this.moveIn.type = MoveInType.None;
        this.moveIn.hoverNode = null;
        this.moveIn.lineControlPoint = null;
        this.moveIn.hoverLine = null;
        this.hoverLayer.hoverAnchorIndex = -1;
        if (!this.data.locked &&
            !this.activeLayer.locked() &&
            this.activeLayer.rotateCPs[0] &&
            this.activeLayer.rotateCPs[0].hit(pt, 15)) {
            this.moveIn.type = MoveInType.Rotate;
            this.divLayer.canvas.style.cursor = "url(\"" + this.options.rotateCursor + "\"), auto";
            return;
        }
        if (this.activeLayer.nodes.length && utils_1.pointInRect(pt, this.activeLayer.sizeCPs)) {
            this.moveIn.type = MoveInType.Nodes;
        }
        if (!this.data.locked && !this.options.hideSizeCP) {
            for (var i = 0; i < this.activeLayer.sizeCPs.length; ++i) {
                if (this.activeLayer.sizeCPs[i].hit(pt, 10)) {
                    this.moveIn.type = MoveInType.ResizeCP;
                    this.moveIn.activeAnchorIndex = i;
                    this.divLayer.canvas.style.cursor = resizeCursors[i];
                    return;
                }
            }
        }
        // In active line.
        for (var _i = 0, _a = this.activeLayer.lines; _i < _a.length; _i++) {
            var item = _a[_i];
            for (var i = 0; i < item.controlPoints.length; ++i) {
                if (!item.locked && item.controlPoints[i].hit(pt, 10)) {
                    item.controlPoints[i].id = i;
                    this.moveIn.type = MoveInType.LineControlPoint;
                    this.moveIn.lineControlPoint = item.controlPoints[i];
                    this.moveIn.hoverLine = item;
                    this.divLayer.canvas.style.cursor = 'pointer';
                    return;
                }
            }
            if (this.inLine(pt, item)) {
                return;
            }
        }
        this.divLayer.canvas.style.cursor = 'default';
        var node = this.inNodes(pt, this.activeLayer.nodes);
        if (node && !node.childStand) {
            return;
        }
        node = this.inNodes(pt, this.data.nodes);
        if (node && !node.childStand) {
            return;
        }
        var index = 0;
        for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            ++index;
            if (!item.to) {
                this.data.lines.splice(index - 1, 1);
                continue;
            }
            if (this.inLine(pt, item)) {
                return;
            }
        }
    };
    Topology.prototype.inNodes = function (pt, nodes) {
        for (var i = nodes.length - 1; i > -1; --i) {
            var node = this.inNode(pt, nodes[i]);
            if (node) {
                return node;
            }
        }
    };
    Topology.prototype.inNode = function (pt, node) {
        if (node.childStand && node.children && node.children.length) {
            var n = this.inNodes(pt, node.children);
            if (n) {
                return n;
            }
        }
        if (node.hit(pt)) {
            this.moveIn.hoverNode = node;
            this.moveIn.type = MoveInType.Nodes;
            if (this.data.locked || node.locked) {
                this.divLayer.canvas.style.cursor = 'pointer';
                return node;
            }
            this.divLayer.canvas.style.cursor = 'move';
            // Too small
            if (node.rect.width < 20 || node.rect.height < 20) {
                return node;
            }
            for (var j = 0; j < node.rotatedAnchors.length; ++j) {
                if (node.rotatedAnchors[j].hit(pt, 5)) {
                    if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {
                        continue;
                    }
                    this.moveIn.hoverNode = node;
                    this.moveIn.type = MoveInType.HoverAnchors;
                    this.moveIn.hoverAnchorIndex = j;
                    this.hoverLayer.hoverAnchorIndex = j;
                    this.divLayer.canvas.style.cursor = 'crosshair';
                    return node;
                }
            }
            return node;
        }
        if (node.hit(pt, 5)) {
            if (this.data.locked || node.locked) {
                return node;
            }
            for (var j = 0; j < node.rotatedAnchors.length; ++j) {
                if (node.rotatedAnchors[j].hit(pt, 5)) {
                    if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {
                        continue;
                    }
                    this.moveIn.hoverNode = node;
                    this.moveIn.type = MoveInType.HoverAnchors;
                    this.moveIn.hoverAnchorIndex = j;
                    this.hoverLayer.hoverAnchorIndex = j;
                    this.divLayer.canvas.style.cursor = 'crosshair';
                    return node;
                }
            }
        }
    };
    Topology.prototype.inLine = function (point, line) {
        if (line.from.hit(point, 10)) {
            this.moveIn.type = MoveInType.LineFrom;
            this.moveIn.hoverLine = line;
            if (this.data.locked || line.locked) {
                this.divLayer.canvas.style.cursor = 'pointer';
            }
            else {
                this.divLayer.canvas.style.cursor = 'move';
            }
            return true;
        }
        if (line.to.hit(point, 10)) {
            this.moveIn.type = MoveInType.LineTo;
            this.moveIn.hoverLine = line;
            if (this.data.locked || line.locked) {
                this.divLayer.canvas.style.cursor = 'pointer';
            }
            else {
                this.divLayer.canvas.style.cursor = 'move';
            }
            return true;
        }
        if (line.pointIn(point)) {
            this.moveIn.type = MoveInType.LineMove;
            this.moveIn.hoverLine = line;
            this.divLayer.canvas.style.cursor = 'pointer';
            if (line.from.id || line.to.id) {
                this.moveIn.type = MoveInType.Line;
            }
            return true;
        }
        return false;
    };
    Topology.prototype.getLineDock = function (point) {
        this.hoverLayer.dockAnchor = null;
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.rect.hit(point, 10)) {
                this.hoverLayer.node = item;
            }
            for (var i = 0; i < item.rotatedAnchors.length; ++i) {
                if (item.rotatedAnchors[i].mode && item.rotatedAnchors[i].mode !== status_1.AnchorMode.In) {
                    continue;
                }
                if (item.rotatedAnchors[i].hit(point, 10)) {
                    point.id = item.id;
                    point.anchorIndex = i;
                    point.direction = item.rotatedAnchors[point.anchorIndex].direction;
                    point.x = item.rotatedAnchors[point.anchorIndex].x;
                    point.y = item.rotatedAnchors[point.anchorIndex].y;
                    this.hoverLayer.dockAnchor = item.rotatedAnchors[i];
                    break;
                }
            }
            if (point.id) {
                break;
            }
        }
        return point;
    };
    Topology.prototype.getRectNodes = function (nodes, rect) {
        if (rect.width < 0) {
            rect.width = -rect.width;
            rect.x = rect.ex;
            rect.ex = rect.x + rect.width;
        }
        if (rect.height < 0) {
            rect.height = -rect.height;
            rect.y = rect.ey;
            rect.ey = rect.y + rect.height;
        }
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var item = nodes_1[_i];
            if (rect.hitRect(item.rect)) {
                this.activeLayer.addNode(item);
            }
        }
    };
    Topology.prototype.getRectLines = function (lines, rect) {
        if (rect.width < 0) {
            rect.width = -rect.width;
            rect.x = rect.ex;
            rect.ex = rect.x + rect.width;
        }
        if (rect.height < 0) {
            rect.height = -rect.height;
            rect.y = rect.ey;
            rect.ey = rect.y + rect.height;
        }
        this.activeLayer.lines = [];
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var item = lines_1[_i];
            if (rect.hit(item.from) && rect.hit(item.to)) {
                this.activeLayer.addLine(item);
            }
        }
    };
    Topology.prototype.getAngle = function (pt) {
        if (pt.x === this.activeLayer.rect.center.x) {
            return pt.y <= this.activeLayer.rect.center.y ? 0 : 180;
        }
        if (pt.y === this.activeLayer.rect.center.y) {
            return pt.x < this.activeLayer.rect.center.x ? 270 : 90;
        }
        var x = pt.x - this.activeLayer.rect.center.x;
        var y = pt.y - this.activeLayer.rect.center.y;
        var angle = (Math.atan(Math.abs(x / y)) / (2 * Math.PI)) * 360;
        if (x > 0 && y > 0) {
            angle = 180 - angle;
        }
        else if (x < 0 && y > 0) {
            angle += 180;
        }
        else if (x < 0 && y < 0) {
            angle = 360 - angle;
        }
        if (this.activeLayer.nodes.length === 1) {
            return angle - this.activeLayer.nodes[0].rotate;
        }
        return angle;
    };
    Topology.prototype.showInput = function (item) {
        if (this.data.locked || item.locked || this.options.hideInput) {
            return;
        }
        this.inputObj = item;
        var textRect = item.getTextRect();
        this.input.value = item.text || '';
        this.input.style.left = textRect.x + 'px';
        this.input.style.top = textRect.y + 'px';
        this.input.style.width = textRect.width + 'px';
        this.input.style.height = textRect.height + 'px';
        this.input.style.zIndex = '1000';
        this.input.focus();
    };
    Topology.prototype.getRect = function () {
        var x1 = 99999;
        var y1 = 99999;
        var x2 = -99999;
        var y2 = -99999;
        var points = [];
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            var pts = item.rect.toPoints();
            if (item.rotate) {
                for (var _b = 0, pts_1 = pts; _b < pts_1.length; _b++) {
                    var pt = pts_1[_b];
                    pt.rotate(item.rotate, item.rect.center);
                }
            }
            points.push.apply(points, pts);
        }
        for (var _c = 0, _d = this.data.lines; _c < _d.length; _c++) {
            var l = _d[_c];
            points.push(l.from);
            points.push(l.to);
            if (l.name === 'curve') {
                for (var i = 0.01; i < 1; i += 0.02) {
                    points.push(curve_1.getBezierPoint(i, l.from, l.controlPoints[0], l.controlPoints[1], l.to));
                }
            }
        }
        for (var _e = 0, points_1 = points; _e < points_1.length; _e++) {
            var item = points_1[_e];
            if (x1 > item.x) {
                x1 = item.x;
            }
            if (y1 > item.y) {
                y1 = item.y;
            }
            if (x2 < item.x) {
                x2 = item.x;
            }
            if (y2 < item.y) {
                y2 = item.y;
            }
        }
        return new rect_1.Rect(x1, y1, x2 - x1, y2 - y1);
    };
    Topology.prototype.getNodesRect = function (nodes) {
        var x1 = 99999;
        var y1 = 99999;
        var x2 = -99999;
        var y2 = -99999;
        var points = [];
        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
            var item = nodes_2[_i];
            var pts = item.rect.toPoints();
            if (item.rotate) {
                for (var _a = 0, pts_2 = pts; _a < pts_2.length; _a++) {
                    var pt = pts_2[_a];
                    pt.rotate(item.rotate, item.rect.center);
                }
            }
            points.push.apply(points, pts);
        }
        for (var _b = 0, points_2 = points; _b < points_2.length; _b++) {
            var item = points_2[_b];
            if (x1 > item.x) {
                x1 = item.x;
            }
            if (y1 > item.y) {
                y1 = item.y;
            }
            if (x2 < item.x) {
                x2 = item.x;
            }
            if (y2 < item.y) {
                y2 = item.y;
            }
        }
        return new rect_1.Rect(x1, y1, x2 - x1, y2 - y1);
    };
    // Get a dock rect for moving nodes.
    Topology.prototype.getDockPos = function (offsetX, offsetY) {
        this.hoverLayer.dockLineX = 0;
        this.hoverLayer.dockLineY = 0;
        var offset = {
            x: 0,
            y: 0
        };
        var x = 0;
        var y = 0;
        var disX = dockOffset;
        var disY = dockOffset;
        for (var _i = 0, _a = this.activeLayer.dockWatchers; _i < _a.length; _i++) {
            var activePt = _a[_i];
            for (var _b = 0, _c = this.data.nodes; _b < _c.length; _b++) {
                var item = _c[_b];
                if (this.activeLayer.hasNode(item) || item.name === 'text') {
                    continue;
                }
                if (!item.dockWatchers) {
                    item.getDockWatchers();
                }
                for (var _d = 0, _e = item.dockWatchers; _d < _e.length; _d++) {
                    var p = _e[_d];
                    x = Math.abs(p.x - activePt.x - offsetX);
                    if (x < disX) {
                        disX = -99999;
                        offset.x = p.x - activePt.x;
                        this.hoverLayer.dockLineX = p.x | 0;
                    }
                    y = Math.abs(p.y - activePt.y - offsetY);
                    if (y < disY) {
                        disY = -99999;
                        offset.y = p.y - activePt.y;
                        this.hoverLayer.dockLineY = p.y | 0;
                    }
                }
            }
        }
        return offset;
    };
    Topology.prototype.cache = function () {
        if (this.caches.index < this.caches.list.length - 1) {
            this.caches.list.splice(this.caches.index + 1, this.caches.list.length - this.caches.index - 1);
        }
        var data = new data_1.TopologyData(this.data);
        this.caches.list.push(data);
        this.caches.index = this.caches.list.length - 1;
    };
    Topology.prototype.undo = function () {
        if (this.data.locked || this.caches.index < 1) {
            return;
        }
        this.divLayer.clear();
        var data = new data_1.TopologyData(this.caches.list[--this.caches.index]);
        this.data.nodes.splice(0, this.data.nodes.length);
        this.data.lines.splice(0, this.data.lines.length);
        this.data.nodes.push.apply(this.data.nodes, data.nodes);
        this.data.lines.push.apply(this.data.lines, data.lines);
        this.render(true);
        this.divLayer.render();
        this.options.on('undo', this.data);
    };
    Topology.prototype.redo = function () {
        if (this.data.locked || this.caches.index > this.caches.list.length - 2) {
            return;
        }
        this.divLayer.clear();
        var data = new data_1.TopologyData(this.caches.list[++this.caches.index]);
        this.data.nodes.splice(0, this.data.nodes.length);
        this.data.lines.splice(0, this.data.lines.length);
        this.data.nodes.push.apply(this.data.nodes, data.nodes);
        this.data.lines.push.apply(this.data.lines, data.lines);
        this.render(true);
        this.divLayer.render();
        this.options.on('redo', this.data);
    };
    Topology.prototype.toImage = function (type, quality, callback) {
        var rect = this.getRect();
        rect.x -= 10;
        rect.y -= 10;
        rect.width += 20;
        rect.height += 20;
        rect.round();
        var srcRect = rect.clone();
        srcRect.scale(this.offscreen.getDpiRatio(), new point_1.Point(0, 0));
        srcRect.round();
        var canvas = document.createElement('canvas');
        canvas.width = srcRect.width;
        canvas.height = srcRect.height;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        var ctx = canvas.getContext('2d');
        if (type && type !== 'image/png') {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        ctx.drawImage(this.offscreen.canvas, srcRect.x, srcRect.y, srcRect.width, srcRect.height, 0, 0, srcRect.width, srcRect.height);
        if (callback) {
            canvas.toBlob(callback);
            return '';
        }
        return canvas.toDataURL(type, quality);
    };
    Topology.prototype.saveAsImage = function (name, type, quality) {
        var a = document.createElement('a');
        a.setAttribute('download', name || 'le5le.topology.png');
        a.setAttribute('href', this.toImage(type, quality));
        var evt = document.createEvent('MouseEvents');
        evt.initEvent('click', true, true);
        a.dispatchEvent(evt);
    };
    Topology.prototype.delete = function () {
        var nodes = [];
        var lines = [];
        var i = 0;
        for (var _i = 0, _a = this.activeLayer.lines; _i < _a.length; _i++) {
            var line = _a[_i];
            i = this.findLine(line);
            if (i > -1) {
                lines.push.apply(lines, this.data.lines.splice(i, 1));
            }
        }
        for (var _b = 0, _c = this.activeLayer.nodes; _b < _c.length; _b++) {
            var node = _c[_b];
            i = this.findNode(node);
            if (i > -1) {
                this.divLayer.removeDiv(this.data.nodes[i]);
                nodes.push.apply(nodes, this.data.nodes.splice(i, 1));
            }
        }
        this.animate(false);
        this.render(true);
        this.cache();
        if (this.options.on) {
            this.options.on('delete', {
                nodes: nodes,
                lines: lines
            });
        }
    };
    Topology.prototype.removeNode = function (node) {
        var i = this.findNode(node);
        if (i > -1) {
            this.divLayer.removeDiv(this.data.nodes[i]);
            var nodes = this.data.nodes.splice(i, 1);
            if (this.options.on) {
                this.options.on('delete', {
                    nodes: nodes
                });
            }
        }
        this.render(true);
        this.cache();
    };
    Topology.prototype.removeLine = function (line) {
        var i = this.findLine(line);
        if (i > -1) {
            var lines = this.data.lines.splice(i, 1);
            if (this.options.on) {
                this.options.on('delete', {
                    lines: lines
                });
            }
        }
        this.render(true);
        this.cache();
    };
    Topology.prototype.cut = function () {
        if (this.data.locked) {
            return;
        }
        this.clipboard = new data_1.TopologyData({
            nodes: [],
            lines: []
        });
        for (var _i = 0, _a = this.activeLayer.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            this.clipboard.nodes.push(new node_1.Node(item));
            var i = this.findNode(item);
            if (i > -1) {
                this.divLayer.removeDiv(this.data.nodes[i]);
                this.data.nodes.splice(i, 1);
            }
        }
        for (var _b = 0, _c = this.activeLayer.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            this.clipboard.lines.push(new line_1.Line(item));
            var i = 0;
            for (var _d = 0, _e = this.data.lines; _d < _e.length; _d++) {
                var line = _e[_d];
                if (item.id === line.id) {
                    this.data.lines.splice(i, 1);
                }
                ++i;
            }
        }
        this.cache();
        this.activeLayer.clear();
        this.hoverLayer.node = null;
        this.moveIn.hoverLine = null;
        this.moveIn.hoverNode = null;
        this.render();
        if (this.options.on) {
            this.options.on('delete', {
                nodes: this.clipboard.nodes,
                lines: this.clipboard.lines
            });
        }
    };
    Topology.prototype.copy = function () {
        this.clipboard = new data_1.TopologyData({
            nodes: [],
            lines: []
        });
        for (var _i = 0, _a = this.activeLayer.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            this.clipboard.nodes.push(new node_1.Node(item));
        }
        for (var _b = 0, _c = this.activeLayer.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            this.clipboard.lines.push(new line_1.Line(item));
        }
    };
    Topology.prototype.parse = function () {
        if (!this.clipboard || this.data.locked) {
            return;
        }
        this.hoverLayer.node = null;
        this.hoverLayer.line = null;
        this.activeLayer.nodes = [];
        this.activeLayer.lines = [];
        var idMaps = {};
        for (var _i = 0, _a = this.clipboard.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            this.newId(item, idMaps);
            item.rect.x += 20;
            item.rect.ex += 20;
            item.rect.y += 20;
            item.rect.ey += 20;
            var node = new node_1.Node(item);
            this.data.nodes.push(node);
            this.activeLayer.nodes.push(node);
        }
        for (var _b = 0, _c = this.clipboard.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            item.id = uuid_1.s8();
            item.from = new point_1.Point(item.from.x + 20, item.from.y + 20, item.from.direction, item.from.anchorIndex, idMaps[item.from.id]);
            item.to = new point_1.Point(item.to.x + 20, item.to.y + 20, item.to.direction, item.to.anchorIndex, idMaps[item.to.id]);
            var controlPoints = [];
            for (var _d = 0, _e = item.controlPoints; _d < _e.length; _d++) {
                var pt = _e[_d];
                controlPoints.push(new point_1.Point(pt.x + 20, pt.y + 20));
            }
            var line = new line_1.Line(item);
            line.controlPoints = controlPoints;
            this.data.lines.push(line);
            this.activeLayer.addLine(line);
        }
        this.render();
        this.cache();
        if (this.options.on) {
            if (this.clipboard.nodes.length > 1 ||
                this.clipboard.lines.length > 1 ||
                (this.clipboard.nodes.length && this.clipboard.lines.length)) {
                this.options.on('multi', {
                    nodes: this.clipboard.nodes,
                    lines: this.clipboard.lines
                });
            }
            else if (this.clipboard.nodes.length) {
                this.options.on('addNode', this.activeLayer.nodes[0]);
            }
            else if (this.clipboard.lines.length) {
                this.options.on('addLine', this.activeLayer.lines[0]);
            }
        }
    };
    Topology.prototype.newId = function (node, idMaps) {
        var old = node.id;
        node.id = uuid_1.s8();
        idMaps[old] = node.id;
        if (node.children) {
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var item = _a[_i];
                this.newId(item, idMaps);
            }
        }
    };
    Topology.prototype.animate = function (autoplay) {
        if (autoplay === void 0) { autoplay = true; }
        var n = Date.now();
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.animatePlay) {
                item.animateStart = autoplay ? n : 0;
            }
        }
        for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            if (item.animatePlay) {
                item.animateStart = autoplay ? n : 0;
            }
        }
        this.animateLayer.start(!autoplay);
    };
    Topology.prototype.updateProps = function (node) {
        if (node) {
            node.round();
            node.init();
            this.activeLayer.updateChildren(node);
            this.activeLayer.updateLines([node]);
        }
        this.activeLayer.calcControlPoints();
        this.activeLayer.saveNodeRects();
        this.activeLayer.changeLineType();
        this.render();
        this.cache();
    };
    Topology.prototype.lock = function (lock) {
        this.data.locked = lock;
        if (this.options.on) {
            this.options.on('locked', this.data.locked);
        }
    };
    Topology.prototype.lockNodes = function (nodes, lock) {
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            for (var _b = 0, nodes_3 = nodes; _b < nodes_3.length; _b++) {
                var node = nodes_3[_b];
                if (item.id === node.id) {
                    item.locked = lock;
                    break;
                }
            }
        }
        if (this.options.on) {
            this.options.on('lockNodes', {
                nodes: nodes,
                lock: lock
            });
        }
    };
    Topology.prototype.lockLines = function (lines, lock) {
        for (var _i = 0, _a = this.data.lines; _i < _a.length; _i++) {
            var item = _a[_i];
            for (var _b = 0, lines_2 = lines; _b < lines_2.length; _b++) {
                var line = lines_2[_b];
                if (item.id === line.id) {
                    item.locked = lock;
                    break;
                }
            }
        }
        if (this.options.on) {
            this.options.on('lockLines', {
                lines: lines,
                lock: lock
            });
        }
    };
    Topology.prototype.top = function (node) {
        var i = this.findNode(node);
        if (i > -1) {
            this.data.nodes.push(this.data.nodes[i]);
            this.data.nodes.splice(i, 1);
        }
    };
    Topology.prototype.bottom = function (node) {
        var i = this.findNode(node);
        if (i > -1) {
            this.data.nodes.unshift(this.data.nodes[i]);
            this.data.nodes.splice(i + 1, 1);
        }
    };
    Topology.prototype.combine = function (nodes, stand) {
        if (!nodes) {
            nodes = this.activeLayer.nodes;
        }
        var rect = this.getNodesRect(nodes);
        for (var _i = 0, nodes_4 = nodes; _i < nodes_4.length; _i++) {
            var item = nodes_4[_i];
            var i = this.findNode(item);
            if (i > -1) {
                this.data.nodes.splice(i, 1);
            }
        }
        var node = new node_1.Node({
            name: 'combine',
            rect: new rect_1.Rect(rect.x, rect.y, rect.width, rect.height),
            text: '',
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            childStand: stand,
            strokeStyle: 'transparent'
        });
        node.children = [];
        for (var _a = 0, nodes_5 = nodes; _a < nodes_5.length; _a++) {
            var item = nodes_5[_a];
            item.stand = stand;
            item.parentId = node.id;
            item.calcRectInParent(node);
            node.children.push(item);
        }
        this.data.nodes.push(node);
        this.activeLayer.setNodes([node]);
        if (this.options.on) {
            this.options.on('node', node);
        }
        this.cache();
    };
    Topology.prototype.uncombine = function (node) {
        if (!node) {
            node = this.activeLayer.nodes[0];
        }
        if (node.name !== 'combine') {
            return;
        }
        var i = this.findNode(node);
        if (i > -1) {
            this.data.nodes.splice(i, 1);
        }
        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
            var item = _a[_i];
            item.parentId = undefined;
            item.rectInParent = undefined;
            item.stand = undefined;
            this.data.nodes.push(item);
        }
        this.cache();
        this.activeLayer.clear();
        this.hoverLayer.clear();
    };
    Topology.prototype.findNode = function (node) {
        for (var i = 0; i < this.data.nodes.length; ++i) {
            if (node.id === this.data.nodes[i].id) {
                return i;
            }
        }
        return -1;
    };
    Topology.prototype.findLine = function (line) {
        for (var i = 0; i < this.data.lines.length; ++i) {
            if (line.id === this.data.lines[i].id) {
                return i;
            }
        }
        return -1;
    };
    Topology.prototype.translate = function (x, y, process) {
        if (!process) {
            this.lastTranlated.x = 0;
            this.lastTranlated.y = 0;
        }
        var offsetX = x - this.lastTranlated.x;
        var offsetY = y - this.lastTranlated.y;
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            item.translate(offsetX, offsetY);
        }
        for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            item.translate(offsetX, offsetY);
        }
        this.lastTranlated.x = x;
        this.lastTranlated.y = y;
        this.overflow();
        this.render();
        this.animateLayer.start();
        this.cache();
        if (this.options.on) {
            this.options.on('translate', { x: x, y: y });
        }
    };
    // scale for scaled canvas:
    //   > 1, expand
    //   < 1, reduce
    Topology.prototype.scale = function (scale) {
        if (this.data.scale * scale < 0.25) {
            return;
        }
        this.data.scale *= scale;
        var center = this.getRect().center;
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            item.scale(scale, center);
        }
        for (var _b = 0, _c = this.data.lines; _b < _c.length; _b++) {
            var item = _c[_b];
            item.scale(scale, center);
        }
        le5le_store_1.Store.set('LT:scale', this.data.scale);
        this.overflow();
        this.render();
        this.animateLayer.start();
        this.cache();
        if (this.options.on) {
            this.options.on('scale', this.data.scale);
        }
    };
    // scale for origin canvas:
    Topology.prototype.scaleTo = function (scale) {
        this.scale(scale / this.data.scale);
    };
    Topology.prototype.round = function () {
        for (var _i = 0, _a = this.data.nodes; _i < _a.length; _i++) {
            var item = _a[_i];
            item.round();
        }
    };
    Topology.prototype.alignNodes = function (align) {
        this.activeLayer.alignNodes(align);
        this.render();
    };
    Topology.prototype.link = function (data) {
        var _this = this;
        if (!data || !data.link || !this.data.locked) {
            return;
        }
        window.open(data.link, '_blank');
        this.mouseDown = null;
        setTimeout(function () {
            _this.divLayer.canvas.focus();
        }, 1000);
    };
    Topology.prototype.createMarkdownTip = function () {
        this.tipMarkdown = document.createElement('div');
        this.tipMarkdown.style.position = 'absolute';
        this.tipMarkdown.style.zIndex = '-1';
        this.tipMarkdown.style.left = '-9999px';
        this.tipMarkdown.style.width = '500px';
        this.tipMarkdown.style.outline = 'none';
        this.tipMarkdown.style.border = '1px solid #d0d0d0';
        this.tipMarkdown.style.backgroundColor = '#fff';
        this.tipMarkdown.style.padding = '10px 15px';
        this.tipMarkdown.style.overflowY = 'auto';
        document.body.appendChild(this.tipMarkdown);
    };
    Topology.prototype.showTip = function (data, pos) {
        if (!this.data.locked || !data || (!data.markdown && !data.tipId && !data.title) || data.id === this.tip) {
            return;
        }
        if (data.title) {
            this.divLayer.canvas.title = data.title;
            this.tip = data.id;
            return;
        }
        if (data.tipId) {
            this.tipElem = document.getElementById(data.tipId);
        }
        var parentRect = this.parentElem.getBoundingClientRect();
        var w = data.markdown ? 500 : (this.tipElem ? this.tipElem.getBoundingClientRect().width : 500);
        var x = pos.x + parentRect.left - w / 2;
        var y = pos.y + parentRect.top;
        if (data instanceof node_1.Node) {
            x = parentRect.left + data.rect.center.x - w / 2;
            y = parentRect.top + data.rect.ey;
        }
        if (x < 0) {
            x = 0;
        }
        if (x + w > document.body.clientWidth) {
            x = document.body.clientWidth - w;
        }
        if (y + 260 > document.body.clientHeight) {
            y = document.body.clientHeight - 260;
        }
        if (data.markdown) {
            this.tipMarkdown.style.height = '30px';
            var marked = window.marked;
            if (marked) {
                this.tipMarkdown.innerHTML = marked(data.markdown);
            }
            else {
                this.tipMarkdown.innerHTML = data.markdown;
            }
            if (this.tipMarkdown.scrollHeight < 260) {
                this.tipMarkdown.style.height = this.tipMarkdown.scrollHeight + 10 + 'px';
            }
            else {
                this.tipMarkdown.style.height = '260px';
            }
            var a = this.tipMarkdown.getElementsByTagName('A');
            for (var i = 0; i < a.length; ++i) {
                a[i].setAttribute('target', '_blank');
            }
            this.tipMarkdown.style.left = x + 'px';
            this.tipMarkdown.style.top = y + 'px';
            this.tipMarkdown.style.zIndex = '100';
        }
        else if (this.tipElem) {
            this.tipElem.style.left = x + 'px';
            this.tipElem.style.top = y + 'px';
            this.tipElem.style.zIndex = '100';
        }
        this.tip = data.id;
    };
    Topology.prototype.hideTip = function () {
        if (!this.tip) {
            return;
        }
        this.tipMarkdown.style.left = '-9999px';
        this.tipMarkdown.style.zIndex = '-1';
        if (this.tipElem) {
            this.tipElem.style.left = '-9999px';
            this.tipElem.style.zIndex = '-1';
            this.tipElem = null;
        }
        this.divLayer.canvas.title = '';
        this.tip = '';
    };
    Topology.prototype.scroll = function (x, y) {
        var _this = this;
        if (this.scrolling) {
            return;
        }
        this.scrolling = true;
        this.parentElem.scrollLeft += x;
        this.parentElem.scrollTop += y;
        setTimeout(function () {
            _this.scrolling = false;
        }, 700);
    };
    Topology.prototype.destroy = function () {
        this.subcribe.unsubscribe();
        this.subcribeImage.unsubscribe();
        this.subcribeAnimateEnd.unsubscribe();
        this.subcribeAnimateMoved.unsubscribe();
        this.subcribeMediaEnd.unsubscribe();
        this.animateLayer.destroy();
        this.divLayer.destroy();
        document.body.removeChild(this.tipMarkdown);
    };
    return Topology;
}());
exports.Topology = Topology;
//# sourceMappingURL=index.js.map