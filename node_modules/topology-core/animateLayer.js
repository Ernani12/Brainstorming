"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var le5le_store_1 = require("le5le-store");
var line_1 = require("./models/line");
var AnimateLayer = /** @class */ (function () {
    function AnimateLayer(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.data = le5le_store_1.Store.get('topology-data');
        this.nodes = [];
        this.lines = [];
        le5le_store_1.Store.set('LT:AnimateLayer', this);
        if (!this.options.animateColor) {
            this.options.animateColor = '#ff6600';
        }
    }
    AnimateLayer.prototype.start = function (clear) {
        if (clear === void 0) { clear = true; }
        if (this.timer) {
            cancelAnimationFrame(this.timer);
        }
        if (clear) {
            this.nodes = [];
            this.lines = [];
        }
        this.getNodes(this.data.nodes);
        this.getLines();
        this.animate();
    };
    AnimateLayer.prototype.getNodes = function (nodes, tag) {
        if (tag === void 0) { tag = ''; }
        if (!nodes) {
            return;
        }
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var item = nodes_1[_i];
            var found = false;
            if (tag && item.tags.indexOf(tag) > -1) {
                item.animateStart = Date.now();
            }
            for (var i = 0; i < this.nodes.length; ++i) {
                if (this.nodes[i].id === item.id) {
                    item.animateCycleIndex = 1;
                    found = true;
                    if (!item.animateStart) {
                        this.nodes.splice(i, 1);
                    }
                }
            }
            if (!found && item.animateStart) {
                item.updateAnimateProps();
                this.nodes.push(item);
                this.getNodes(item.children);
            }
        }
    };
    AnimateLayer.prototype.getLines = function (tag) {
        if (tag === void 0) { tag = ''; }
        for (var _i = 0, _a = this.data.lines; _i < _a.length; _i++) {
            var item = _a[_i];
            var found = false;
            if (tag && item.tags.indexOf(tag) > -1) {
                item.animateStart = Date.now();
            }
            for (var i = 0; i < this.lines.length; ++i) {
                if (this.lines[i].id === item.id) {
                    this.lines[i].animateCycle = item.animateCycle;
                    this.lines[i].animateCycleIndex = 1;
                    this.lines[i].animateColor = item.animateColor || this.options.animateColor;
                    this.lines[i].strokeStyle = item.animateColor || this.options.animateColor;
                    this.lines[i].animateSpan = item.animateSpan;
                    found = true;
                    if (item.animateStart) {
                        this.lines[i].animateStart = item.animateStart;
                    }
                    else {
                        this.lines.splice(i, 1);
                    }
                }
            }
            if (!found && item.animateStart) {
                var l = new line_1.Line(item);
                l.isAnimate = true;
                if (l.fromArrow && l.fromArrow.indexOf('line') < 0) {
                    l.animateFromSize = l.fromArrowSize + l.lineWidth * 5;
                }
                if (l.toArrow && l.toArrow.indexOf('line') < 0) {
                    l.animateToSize = l.toArrowSize + l.lineWidth * 5;
                }
                l.animateStart = item.animateStart;
                l.lineCap = 'round';
                l.fillStyle = '#fff';
                l.strokeStyle = l.animateColor || this.options.animateColor;
                l.length = l.getLen();
                if (!l.fromArrowColor) {
                    l.fromArrowColor = l.strokeStyle || '#222';
                }
                if (!l.toArrowColor) {
                    l.toArrowColor = l.strokeStyle || '#222';
                }
                this.lines.push(l);
            }
        }
    };
    AnimateLayer.prototype.animate = function () {
        var _this = this;
        if (!this.lines.length && !this.nodes.length) {
            this.timer = null;
            return;
        }
        this.timer = requestAnimationFrame(function () {
            var now = Date.now();
            for (var i = 0; i < _this.lines.length; ++i) {
                if (_this.lines[i].animateStart > now) {
                    continue;
                }
                var next = _this.lines[i].animate();
                if (!_this.lines[i].animateStart) {
                    for (var _i = 0, _a = _this.data.lines; _i < _a.length; _i++) {
                        var item = _a[_i];
                        if (_this.lines[i].id === item.id) {
                            item.animateStart = 0;
                            break;
                        }
                    }
                }
                if (next) {
                    _this.lines.splice(i, 1);
                    _this.getNodes(_this.data.nodes, next);
                    _this.getLines(next);
                }
                if (_this.lines[i] && !_this.lines[i].animateStart) {
                    _this.lines.splice(i, 1);
                }
            }
            for (var i = 0; i < _this.nodes.length; ++i) {
                if (_this.nodes[i].animateStart > now) {
                    continue;
                }
                if (_this.nodes[i].animateDuration && _this.nodes[i].animateStart) {
                    var next = _this.nodes[i].animate(now);
                    if (next) {
                        _this.getNodes(_this.data.nodes, next);
                        _this.getLines(next);
                    }
                }
                else {
                    _this.nodes.splice(i, 1);
                }
            }
            le5le_store_1.Store.set('LT:render', true);
            _this.animate();
        });
    };
    AnimateLayer.prototype.updateLines = function (nodes) {
        if (!nodes) {
            nodes = this.nodes;
        }
        for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
            var line = _a[_i];
            var found = false;
            for (var _b = 0, nodes_2 = nodes; _b < nodes_2.length; _b++) {
                var item = nodes_2[_b];
                if (line.from.id === item.id) {
                    line.from.x = item.rotatedAnchors[line.from.anchorIndex].x;
                    line.from.y = item.rotatedAnchors[line.from.anchorIndex].y;
                    found = true;
                }
                if (line.to.id === item.id) {
                    line.to.x = item.rotatedAnchors[line.to.anchorIndex].x;
                    line.to.y = item.rotatedAnchors[line.to.anchorIndex].y;
                    found = true;
                }
                if (item.children) {
                    this.updateLines(item.children);
                }
            }
            if (found) {
                line.calcControlPoints();
                line.length = line.getLen();
            }
        }
    };
    AnimateLayer.prototype.render = function (ctx) {
        for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
            var item = _a[_i];
            item.render(ctx);
        }
    };
    AnimateLayer.prototype.destroy = function () {
        if (this.timer) {
            cancelAnimationFrame(this.timer);
        }
    };
    return AnimateLayer;
}());
exports.AnimateLayer = AnimateLayer;
//# sourceMappingURL=animateLayer.js.map