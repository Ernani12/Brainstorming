import { Options } from './options';
import { Pen } from './models/pen';
import { Node } from './models/node';
import { Point } from './models/point';
import { Line } from './models/line';
import { TopologyData } from './models/data';
import { Offscreen } from './offscreen';
import { RenderLayer } from './renderLayer';
import { HoverLayer } from './hoverLayer';
import { ActiveLayer } from './activeLayer';
import { AnimateLayer } from './animateLayer';
import { DivLayer } from './divLayer';
import { Rect } from './models/rect';
declare enum MoveInType {
    None = 0,
    Line = 1,
    LineMove = 2,
    LineFrom = 3,
    LineTo = 4,
    LineControlPoint = 5,
    Nodes = 6,
    ResizeCP = 7,
    HoverAnchors = 8,
    Rotate = 9
}
interface ICaches {
    index: number;
    list: TopologyData[];
}
export declare class Topology {
    data: TopologyData;
    clipboard: TopologyData;
    caches: ICaches;
    options: Options;
    parentElem: HTMLElement;
    canvas: RenderLayer;
    offscreen: Offscreen;
    hoverLayer: HoverLayer;
    activeLayer: ActiveLayer;
    animateLayer: AnimateLayer;
    divLayer: DivLayer;
    private subcribe;
    private subcribeImage;
    private imageTimer;
    private subcribeAnimateEnd;
    private subcribeAnimateMoved;
    private subcribeMediaEnd;
    touchedNode: any;
    lastHoverNode: Node;
    lastHoverLine: Line;
    input: HTMLTextAreaElement;
    inputObj: Pen;
    mouseDown: {
        x: number;
        y: number;
    };
    lastTranlated: {
        x: number;
        y: number;
    };
    moveIn: {
        type: MoveInType;
        activeAnchorIndex: number;
        hoverAnchorIndex: number;
        hoverNode: Node;
        hoverLine: Line;
        lineControlPoint: Point;
    };
    needCache: boolean;
    private tip;
    tipMarkdown: HTMLElement;
    tipElem: HTMLElement;
    private scheduledAnimationFrame;
    private scrolling;
    constructor(parent: string | HTMLElement, options?: Options);
    resize(size?: {
        width: number;
        height: number;
    }): void;
    private ondrop;
    getTouchOffset(touch: Touch): {
        offsetX: number;
        offsetY: number;
    };
    private ontouched;
    addNode(node: Node | any, focus?: boolean): boolean;
    addLine(line: Line, focus?: boolean): boolean;
    addLineByPt(name: string, from: Point, fromArrow: string, to: Point, toArrow: string, focus?: boolean): void;
    render(noFocus?: boolean): void;
    open(data: any): void;
    overflow(): void;
    private onMouseMove;
    private setNodeText;
    private onmousedown;
    private onmouseup;
    private ondblclick;
    private onkeydown;
    private getMoveIn;
    inNodes(pt: Point, nodes: Node[]): any;
    inNode(pt: Point, node: Node): any;
    inLine(point: Point, line: Line): boolean;
    private getLineDock;
    private getRectNodes;
    private getRectLines;
    private getAngle;
    private showInput;
    getRect(): Rect;
    getNodesRect(nodes: Node[]): Rect;
    getDockPos(offsetX: number, offsetY: number): {
        x: number;
        y: number;
    };
    cache(): void;
    undo(): void;
    redo(): void;
    toImage(type?: string, quality?: any, callback?: any): string;
    saveAsImage(name?: string, type?: string, quality?: any): void;
    delete(): void;
    removeNode(node: Node): void;
    removeLine(line: Line): void;
    cut(): void;
    copy(): void;
    parse(): void;
    newId(node: any, idMaps: any): void;
    animate(autoplay?: boolean): void;
    updateProps(node?: Node): void;
    lock(lock: number): void;
    lockNodes(nodes: Node[], lock: boolean): void;
    lockLines(lines: Line[], lock: boolean): void;
    top(node: Node): void;
    bottom(node: Node): void;
    combine(nodes?: Node[], stand?: boolean): void;
    uncombine(node?: Node): void;
    private findNode;
    private findLine;
    translate(x: number, y: number, process?: boolean): void;
    scale(scale: number): void;
    scaleTo(scale: number): void;
    round(): void;
    alignNodes(align: string): void;
    private link;
    private createMarkdownTip;
    private showTip;
    private hideTip;
    scroll(x: number, y: number): void;
    destroy(): void;
}
export {};
